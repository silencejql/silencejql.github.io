{"meta":{"title":"Silencejql","subtitle":null,"description":null,"author":"Justin","url":"https://silencejql.github.io","root":"/"},"pages":[{"title":"search","date":"2019-07-03T03:40:00.000Z","updated":"2022-06-24T08:54:56.269Z","comments":true,"path":"search/index.html","permalink":"https://silencejql.github.io/search/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-06-14T13:54:31.000Z","updated":"2022-06-24T08:54:56.258Z","comments":true,"path":"archives/index.html","permalink":"https://silencejql.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-12T06:58:45.000Z","updated":"2022-06-24T08:54:56.271Z","comments":false,"path":"tags/index.html","permalink":"https://silencejql.github.io/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-06-12T06:53:46.000Z","updated":"2022-06-24T08:54:56.263Z","comments":false,"path":"categories/index.html","permalink":"https://silencejql.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CSharp补课笔记TypeConverter","slug":"CSharp补课笔记TypeConverter","date":"2025-05-03T08:13:14.000Z","updated":"2025-05-03T08:23:29.681Z","comments":true,"path":"CSharp补课笔记TypeConverter.html","link":"","permalink":"https://silencejql.github.io/CSharp%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0TypeConverter.html","excerpt":"实现不同类型之间的转换, 如动态的将字符串转换为对象实例","text":"实现不同类型之间的转换, 如动态的将字符串转换为对象实例 示例 使用示例 12345678910public void TestTypeConvert()&#123; TypeConverter tc = TypeDescriptor.GetConverter(typeof(ColorRGB)); ColorRGB colorRGB1 = (ColorRGB)tc.ConvertFromString(&quot;#FF8800&quot;); ColorRGB colorRGB2 = (ColorRGB)tc.ConvertFromString(&quot;255, 136, 0&quot;); string colorString1 = tc.ConvertToString(colorRGB1); string colorString2 = tc.ConvertToString(colorRGB2);&#125; 自定义类型 123456789101112//将转换器与目标类型关联[TypeConverter(typeof(ColorRGBConverter))]public class ColorRGB&#123; public byte R; public byte G; public byte B; public ColorRGB(byte r, byte g, byte b) &#123; R = r; G = g; B = b; &#125; public override string ToString() &#123; return string.Format(&quot;#&#123;0:X2&#125;&#123;1:X2&#125;&#123;2:X2&#125;&quot;, R, G, B); &#125;&#125; 定义类型转换器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051internal class ColorRGBConverter : TypeConverter&#123; //定义可以从哪些类型转换 public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) &#123; return sourceType == typeof(string); &#125; public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) &#123; return base.CanConvertTo(context, destinationType); &#125; //实现将字符串转化为对象 public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) &#123; if(value is string strValue) &#123; try &#123; if(strValue.StartsWith(&quot;#&quot;)) &#123; if (strValue.Length == 7) return new ColorRGB(byte.Parse(strValue.Substring(1,2), NumberStyles.HexNumber), byte.Parse(strValue.Substring(3,2), NumberStyles.HexNumber), byte.Parse(strValue.Substring(5,2), NumberStyles.HexNumber)); &#125; else &#123; string[] parts = strValue.Split(&#x27;,&#x27;); return new ColorRGB(byte.Parse(parts[0].Trim()), byte.Parse(parts[1].Trim()), byte.Parse(parts[2].Trim())); &#125; &#125; catch &#123; throw new FormatException(&quot;格式不正确&quot;); &#125; &#125; return base.ConvertFrom(context, culture, value); &#125; public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) &#123; if(value is ColorRGB &amp;&amp; destinationType == typeof(string)) return value.ToString(); return base.ConvertTo(context, culture, value, destinationType); &#125;&#125; 扩展 CultureInfo主要用于特定区域的数字, 日期, 货币等格式化设置","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"BEP软件配置实现与BBK通讯","slug":"BEP软件配置实现与BBK通讯","date":"2025-05-03T05:14:45.000Z","updated":"2025-05-03T05:50:28.669Z","comments":true,"path":"BEP软件配置实现与BBK通讯.html","link":"","permalink":"https://silencejql.github.io/BEP%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E4%B8%8EBBK%E9%80%9A%E8%AE%AF.html","excerpt":"配置BEP四轮软件和注册表实现BBK与BEP通讯","text":"配置BEP四轮软件和注册表实现BBK与BEP通讯 通讯简介 BBK与BEP软件之间可选择串口(232)和TCP两种通讯方式, 现场常用串口通讯 软件之间交互主要有两个, 1. BBK扫码后将车型信息发送给BEP; 2. BEP将测试结果发送给BBK软件 注册表配置 选择通讯方式 串口 ![[BEP软件配置实现与BBK通讯\\RegSerial.PNG]] 如上图Use Host用于配置软件间的通讯方式, 1为串口通讯, 2为网络通讯 当选择串口通讯时需要在软件中配置串口号, BEP软件对串口号的列举有限制,若串口使用扩展设备时串口号大于限值则不会在软件中显示, 这时需要将限值改大后再选择对应串口, 对应更改上图中的Number of Serial Ports on Machine. 网口 ![[BEP软件配置实现与BBK通讯\\RegTcpip.PNG]] 若选择网口通讯则需要配置上图所示的IP及端口号 Host配置 BEP与BBK软件通讯中有相应的协议规则, 为了更方便的使用需要屏蔽一些规则 ![[BEP软件配置实现与BBK通讯\\RegHost.PNG]] 其中最主要的是要将Use Host Handshaking握手的配置改为0屏蔽掉, 否则无法直接与BEP软件进行数据交互 也可将图中所有Use开头值为1的配置改为0 BEP软件配置 串口 ![[BEP软件配置实现与BBK通讯\\BEPSerial.PNG]] 配置完注册表后需要配置BEP软件中的串口号 其中BEP软件通过HOST串口将测试数据发送给BBK 通过SCANNER串口接收BBK发送的车型信息 其他不需要的不用管或者在注册表中屏蔽 网口 ![[BEP软件配置实现与BBK通讯\\BEPTcp.PNG]] 若选择网口通讯则需要在上图中进行配置 车型数据规则配置 ![[BEP软件配置实现与BBK通讯\\BEPVINConfig.PNG]] BEP接收BBK发送车型数据字符串后会解析为VIN和ZTS, 由于ZTS可能存在不同长度所以需要配置不同的解析规则 具体配置参考上图, VIN为17位, ZTS为2位 BBK发送的车型数据也有一定规则, 在上图第二个标签也中进行配置, 默认为0x02STX开头, 0x03ETX结尾 测试结果发送配置 ![[BEP软件配置实现与BBK通讯\\BEPRsm.PNG]] BEP通过图中rsm_hoststring.xml中配置的规则生成数据字符串后发送给BBK, BBK接收后通过同样的规则进行解析, 因此需要保证BEP和BBK调用该文件的一致性, 上图为BEP软件读取路径, 该路径在注册表配置HOST时可更改; BBK文件路径在相应Config文件下","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Docker-composer常用指令","slug":"Docker-composer常用指令","date":"2025-04-01T07:21:20.000Z","updated":"2025-04-01T07:21:50.431Z","comments":true,"path":"Docker-composer常用指令.html","link":"","permalink":"https://silencejql.github.io/Docker-composer%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# 拉取工程中所有服务依赖的镜像docker-compose pull# 拉取工程中 nginx 服务依赖的镜像docker-compose pull nginx# 前台启动docker-compose up# 后台启动docker-compose up -d# -f 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定，指定多个 ymldocker-compose -f docker-compose.yml up -d# 输出日志，不同的服务输出使用不同的颜色来区分docker-compose logs# 跟踪日志输出docker-compose logs -f# 关闭颜色docker-compose logs --no-color# 列出工程中所有服务的容器docker-compose ps# 列出工程中指定服务的容器docker-compose ps nginx# 在工程中指定服务的容器上执行 echo &quot;helloworld&quot;docker-compose run nginx echo &quot;helloworld&quot;# 进入工程中指定服务的容器docker-compose exec nginx bash# 当一个服务拥有多个容器时，可通过 --index 参数进入到该服务下的任何容器docker-compose exec --index=1 nginx bash# 暂停工程中所有服务的容器docker-compose pause# 暂停工程中指定服务的容器docker-compose pause nginx# 恢复工程中所有服务的容器docker-compose unpause# 恢复工程中指定服务的容器docker-compose unpause nginx# 重启工程中所有服务的容器docker-compose restart# 重启工程中指定服务的容器docker-compose restart nginx# 启动工程中所有服务的容器docker-compose start# 启动工程中指定服务的容器docker-compose start nginx# 停止工程中所有服务的容器docker-compose stop# 停止工程中指定服务的容器docker-compose stop nginx# 通过发送 SIGKILL 信号停止工程中指定服务的容器docker-compose kill nginx# 删除所有（停止状态）服务的容器docker-compose rm# 先停止所有服务的容器，再删除所有服务的容器docker-compose rm -s# 不询问是否删除，直接删除docker-compose rm -f# 删除服务容器挂载的数据卷docker-compose rm -v# 删除工程中指定服务的容器docker-compose rm -sv nginx# 停止并删除工程中所有服务的容器、网络docker-compose stop# 停止并删除工程中所有服务的容器、网络、镜像docker-compose down --rmi all# 停止并删除工程中所有服务的容器、网络、数据卷docker-compose down -v# 打印所有服务的容器所对应的镜像docker-compose images# 打印指定服务的容器所对应的镜像docker-compose images nginx# 打印指定服务容器的某个端口所映射的宿主机端口docker-compose port nginx 80# 显示工程中所有服务的容器正在运行的进程docker-compose top# 显示工程中指定服务的容器正在运行的进程docker-compose top nginx","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://silencejql.github.io/tags/Docker/"}]},{"title":"Windows安装配置Docker","slug":"Windows安装配置Docker","date":"2025-04-01T06:12:25.000Z","updated":"2025-04-01T06:29:48.838Z","comments":true,"path":"Windows安装配置Docker.html","link":"","permalink":"https://silencejql.github.io/Windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEDocker.html","excerpt":"windows安装docker, 示例部署gitlab","text":"windows安装docker, 示例部署gitlab 安装 自行下载安装Docker Desktop 安装完成后命令行输入docker -v可查看Docker版本信息 配置 配置镜像源 在配置中添加registry mirrors 1234&quot;registry-mirrors&quot;: [ &quot;https://docker.1ms.run&quot;, &quot;https://docker.xuanyuan.me&quot; ] 修改docker/daemon.json文件设置registry mirrors 拉去镜像 如: 拉取gitlabdocker pull gitlab/gitlab-ee:latest Gitlab配置 新建文件路径存储Gitlab信息如: gitlab config data logs docker-compose.yml 123456789101112131415161718192021version: &#x27;3&#x27;services: gitlab: image: &#x27;gitlab/gitlab-ee:latest&#x27; # 使用 GitLab 企业版镜像，或将 &#x27;gitlab-ee&#x27; 改为 &#x27;gitlab-ce&#x27; 使用社区版 restart: always hostname: &#x27;localhost&#x27; # 配置 GitLab 的主机名，可以改为你自己的域名或 IP 地址 environment: GITLAB_OMNIBUS_CONFIG: | external_url &#x27;http://localhost&#x27; # GitLab 的外部 URL，建议替换为你服务器的域名或 IP ports: - &#x27;80:80&#x27; # 映射 HTTP 端口 - &#x27;443:443&#x27; # 映射 HTTPS 端口 - &#x27;22:22&#x27; # 映射 SSH 端口，供 GitLab 使用 volumes: - ./gitlab/config:/etc/gitlab - ./gitlab/data:/var/opt/gitlab - ./gitlab/logs:/var/log/gitlab logging: driver: &#x27;json-file&#x27; options: max-size: &#x27;2g&#x27; 启动Gitlab 使用命令docker-compose up -d启动容器需要一定时间, 期间可以用docker ps查看状态, 从starting转为healthy则启动成功 访问http://localhost即可登录gitlab 默认用户为：root 密码在gitlab部署目录下gitlab下的gitlab/config/initial_root_password文件中","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://silencejql.github.io/tags/Docker/"}]},{"title":"BBK查询软件新增查询链接","slug":"BBK查询软件新增查询链接","date":"2025-03-24T05:49:18.000Z","updated":"2025-03-24T11:45:53.004Z","comments":true,"path":"BBK查询软件新增查询链接.html","link":"","permalink":"https://silencejql.github.io/BBK%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E6%96%B0%E5%A2%9E%E6%9F%A5%E8%AF%A2%E9%93%BE%E6%8E%A5.html","excerpt":"BBK查询软件新增或修改数据库链接字符串 可手动更改链接字符串或根据以下步骤自动生成","text":"BBK查询软件新增或修改数据库链接字符串 可手动更改链接字符串或根据以下步骤自动生成 新增本地链接Local 登录管理员后勾选编辑模式 双击要更改的名称或点击添加连接 点击创建链接字符串选择相应的数据源, 本地PostgreSql选择如下 配置连接属性如下, 其中Host可配置被访问数据库的ip 单击确定即可 新增服务器链接Server 登录管理员后勾选编辑模式 双击要更改的名称或点击添加连接后点击创建链接字符串选择相应的数据源, 服务器SQLServer选择如下 配置链接属性如下, 其中Server name可配置被访问数据库的ip 单击确定即可","categories":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/categories/BBK/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Obsidain Dataview使用","slug":"Obsidain-Dataview使用","date":"2025-03-11T02:45:05.000Z","updated":"2025-03-11T02:45:05.425Z","comments":true,"path":"Obsidain-Dataview使用.html","link":"","permalink":"https://silencejql.github.io/Obsidain-Dataview%E4%BD%BF%E7%94%A8.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hexo部署到Gitlab","slug":"Hexo部署到Gitlab","date":"2025-03-08T09:24:38.000Z","updated":"2025-03-24T11:46:43.005Z","comments":true,"path":"Hexo部署到Gitlab.html","link":"","permalink":"https://silencejql.github.io/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0Gitlab.html","excerpt":"博客部署到Gitlab与部署到Github等生成静态页面不同, Gitlab中需要存储完整代码.","text":"博客部署到Gitlab与部署到Github等生成静态页面不同, Gitlab中需要存储完整代码. 完整步骤 以下是使用 Hexo 部署到 GitLab Pages 创建个人博客的完整指南，包含详细步骤和常见问题排查： 一、准备工作 安装 Node.js 和 npm Hexo 基于 Node.js，需先安装 Node.js（建议选择 LTS 版本）。 安装 Git 下载并安装 Git，用于代码管理。 注册 GitLab 账号 访问 GitLab 注册账号。 二、安装 Hexo 并初始化博客 全局安装 Hexo 命令行工具 1npm install -g hexo-cli 创建 Hexo 项目 123hexo init my-blog # 创建名为 my-blog 的博客目录cd my-blog # 进入项目目录npm install # 安装依赖 本地预览 1hexo server # 启动本地服务器 访问 http://localhost:4000 查看默认博客。 三、关联 GitLab 仓库 在 GitLab 创建新项目 登录 GitLab → New project → Create blank project。 填写项目名称（如 my-blog），可见性选择 Public。 重要：项目名称需与 Hexo 的 _config.yml 中配置的路径一致（默认无需修改）。 本地关联 GitLab 仓库 12git initgit remote add origin https://gitlab.com/你的用户名/my-blog.git 四、配置 Hexo 部署到 GitLab 安装 Hexo Git 部署插件 1npm install hexo-deployer-git --save 修改 Hexo 配置文件 打开 _config.yml，找到 deploy 部分，修改为： 1234deploy: type: git repo: https://gitlab.com/你的用户名/my-blog.git branch: main # GitLab 默认分支是 main，不是 master！ 测试部署 1hexo clean &amp;&amp; hexo generate --deploy 此命令会将生成的静态文件（在 public 目录下）推送到 GitLab 的 main 分支。 但为了自动化构建，建议使用 GitLab CI/CD（见下一步）。 五、配置 GitLab CI/CD 自动化部署 创建 .gitlab-ci.yml 文件 在项目根目录新建文件，内容如下： 123456789101112131415image: node:16 # 使用 Node.js 16 环境pages: cache: paths: - node_modules/ # 缓存依赖加速构建 script: - npm install - npm install hexo-cli -g # 全局安装 Hexo - hexo generate # 生成静态文件到 public 目录 artifacts: paths: - public # GitLab Pages 默认从 public 目录部署 only: - main # 仅 main 分支触发构建 推送代码到 GitLab 123git add .git commit -m &quot;初始化 Hexo 博客&quot;git push -u origin main 查看构建状态 进入 GitLab 项目 → CI/CD → Pipelines，查看流水线状态。 构建成功后，进入 Settings → Pages，确认网站地址。 六、访问博客 默认地址： 1https://你的用户名.gitlab.io/my-blog 如果项目名称为 my-blog，访问路径需包含项目名。 如果希望直接使用 https://你的用户名.gitlab.io，需将项目重命名为 你的用户名.gitlab.io（如 john.gitlab.io）。 七、自定义域名（可选） 购买域名 在域名服务商（如 GoDaddy、阿里云）购买域名（如 example.com）。 配置 DNS 解析 添加 CNAME 记录： 123主机名：blog 类型：CNAME 值：你的用户名.gitlab.io 或添加 A 记录： 123主机名：@ 类型：A 值：35.185.44.232（GitLab Pages 的 IP） GitLab 配置自定义域名 进入项目 → Settings → Pages → New Domain。 输入域名（如 blog.example.com），点击 Save。 在 Hexo 的 source 目录下创建 CNAME 文件（无后缀），内容为域名： 1blog.example.com 推送代码使配置生效： 123git add source/CNAMEgit commit -m &quot;添加自定义域名&quot;git push origin main 八、更新博客内容 新建文章 1hexo new &quot;我的第一篇文章&quot; 编辑文件 source/_posts/我的第一篇文章.md。 本地预览 1hexo clean &amp;&amp; hexo server 部署到 GitLab 方式一：手动生成并推送 1hexo clean &amp;&amp; hexo generate --deploy 方式二：触发 CI/CD 自动构建（推荐） 123git add .git commit -m &quot;添加新文章&quot;git push origin main 九、常见问题解决 构建失败 错误提示：npm install 失败。 检查 .gitlab-ci.yml 中的 Node.js 版本是否与本地一致。 错误提示：hexo generate 报错。 确保 _config.yml 中语法正确（避免使用 Tab 缩进，需用空格）。 页面 404 原因：访问路径错误。 如果项目名为 my-blog，访问地址应为 https://用户名.gitlab.io/my-blog。 若希望根路径访问，需将项目重命名为 用户名.gitlab.io。 自定义域名不生效 检查 CNAME 文件是否提交到仓库。 等待 DNS 解析生效（最长可能需要 48 小时）。 按照以上步骤，你可以将 Hexo 博客无缝部署到 GitLab Pages，享受免费、稳定的静态网站托管服务！ 部署Github方式部署到Gitlab 在_config.yml中增加部署仓库链接 新建.gitlab-ci.yml文件用于触发流水线 12345678910111213pages:stage: deployscript: - mkdir .public - cp -r ./* .public - rm -rf public - mv .public publicartifacts: paths: - publicrules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH 在执行完hexo g后先将.gitlab-ci.yml复制到.deploy_git中再执行hexo d 官方方式 如果你更希望你的站点部署在 &lt;你的 GitLab 用户名&gt;.gitlab.io 的子目录中，你的 repository 需要直接命名为子目录的名字，这样你的站点可以通过 https://&lt;你的 GitLab 用户名&gt;.gitlab.io/&lt;repository 的名字&gt; 访问。 你需要检查你的 Hexo 配置文件，将 url 的值修改为 https://&lt;你的 GitLab 用户名&gt;.gitlab.io/&lt;repository 的名字&gt;、将 root 的值修改为 /&lt;repository 的名字&gt;/ 通过 Settings &gt; CI/CD &gt; Runners &gt; Enable shared runners for this project 启用共享运行程序。 将你的 Hexo 站点文件夹推送到 repository 中。 默认情况下 public 目录将不会（并且不应该）被推送到 repository 中，建议你检查 .gitignore 文件中是否包含 public 一行，如果没有请加上。 整体文件夹结构应该与 示例储存库 大致相似。 使用 node --version 指令检查你电脑上的 Node.js 版本。 记下主要版本（例如，v16.y.z） 将 .gitlab-ci.yml 文件添加到您的版本库根目录（与 _config.yml &amp; package.json并列），内容如下（将16替换为您在上一步中注意到的 Node.js 主版本） 1234567891011121314151617image: node:16-alpinecache:paths: - node_modules/before_script:- npm install hexo-cli -g- npm installpages:script: - npm run buildartifacts: paths: - publicrules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH GitLab CI 应该会自动开始运行，构建成功以后你应该可以在 https://&lt;你的 GitLab 用户名&gt;.gitlab.io 查看你的网站。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"}]},{"title":"Hexo中修改KaTeX界定符","slug":"Hexo中修改KaTeX界定符","date":"2025-03-07T05:51:28.000Z","updated":"2025-03-24T11:46:21.019Z","comments":true,"path":"Hexo中修改KaTeX界定符.html","link":"","permalink":"https://silencejql.github.io/Hexo%E4%B8%AD%E4%BF%AE%E6%94%B9KaTeX%E7%95%8C%E5%AE%9A%E7%AC%A6.html","excerpt":"在 Hexo 中修改 KaTeX 的界定符（定界符）","text":"在 Hexo 中修改 KaTeX 的界定符（定界符） 主要涉及 两个位置：主题模板文件和 KaTeX 初始化脚本。 以下是详细操作步骤： 1. 修改位置：主题的 footer 模板文件 KaTeX 的界定符配置在初始化脚本中，通常位于 Next 主题的 footer 模板文件中。 文件路径： 123themes/next/layout/_partials/footer.njk或themes/next/layout/_partials/footer.swig 操作步骤： 打开对应的 footer 文件（根据你的主题模板引擎，可能是 .njk 或 .swig）。 找到引入 auto-render.min.js 的脚本，修改 delimiters 参数： 123456789101112&lt;script&gt; document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123; renderMathInElement(document.body, &#123; delimiters: [ // 修改这里的 left 和 right 值 &#123;left: &#x27;$$&#x27;, right: &#x27;$$&#x27;, display: true&#125;, // 块级公式 &#123;left: &#x27;$&#x27;, right: &#x27;$&#x27;, display: false&#125; // 行内公式 ], throwOnError: false // 忽略公式错误 &#125;); &#125;);&lt;/script&gt; 将 left 和 right 的值改为你想要的界定符。例如： 改用 \\(...\\) 和 \\[...\\]（LaTeX 标准风格）： 1234delimiters: [ &#123;left: &#x27;\\\\[&#x27;, right: &#x27;\\\\]&#x27;, display: true&#125;, // 块级公式 &#123;left: &#x27;\\\\(&#x27;, right: &#x27;\\\\)&#x27;, display: false&#125; // 行内公式] 改用自定义符号（如 @...@）： 1234delimiters: [ &#123;left: &#x27;@@&#x27;, right: &#x27;@@&#x27;, display: true&#125;, // 块级公式 &#123;left: &#x27;@&#x27;, right: &#x27;@&#x27;, display: false&#125; // 行内公式] 2. 同步修改 Markdown 中的公式写法 修改界定符后，需在文章的 Markdown 中使用新的定界符。例如： 原写法：$E = mc^2$ 和 $$\\sum_&#123;i=1&#125;^n i$$ 修改后（使用 \\(...\\) 和 \\[...\\]）： 123456行内公式：\\\\(E = mc^2\\\\)块级公式：\\\\[\\sum_&#123;i=1&#125;^n i\\\\] 3. 处理转义问题 如果界定符包含特殊字符（如 \\ 或 @），需确保 Markdown 渲染器不会转义它们： (1) 在 Hexo 的 _config.yml 中配置 1234markdown: html: true # 允许 HTML 标签 breaks: false # 关闭自动换行转换 linkify: false # 关闭自动链接识别（避免 @ 被误识别） (2) 转义反斜杠（仅限 \\( 和 \\[ 场景） 在 Markdown 中，如果使用 \\(...\\) 或 \\[...\\]，需在公式中写双反斜杠： 123\\\\[\\int_a^b f(x) dx\\\\] 4. 测试修改结果 清理缓存并生成： 1hexo clean &amp;&amp; hexo g 启动本地服务器预览： 1hexo s 检查公式是否按新界定符渲染，打开浏览器控制台（F12）： 确保无 JS 报错。 检查公式是否被正确包裹（如 &lt;span class=&quot;katex&quot;&gt;）。 5. 常见问题 问题1：修改后公式未渲染 原因：界定符修改未同步到所有位置（如文章中的公式未改用新符号）。 解决：全局搜索旧界定符（如 $），替换为新的。 问题2：\\ 被转义为 \\\\ 原因：Markdown 渲染器自动转义了反斜杠。 解决：在 Hexo 配置中关闭转义： 123markdown: html: true typographer: false # 关闭智能符号转换 问题3：与代码高亮冲突 现象：@ 或 \\ 被代码语法高亮干扰。 解决：避免使用与代码语法冲突的界定符（如 ` 或 *）。 示例配置 目标界定符 行内公式：\\\\(...\\\\) 块级公式：\\\\[...\\\\] 修改后的 footer 模板脚本 12345678910111213&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js&quot; onload=&quot; document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123; renderMathInElement(document.body, &#123; delimiters: [ &#123;left: &#x27;\\\\[&#x27;, right: &#x27;\\\\]&#x27;, display: true&#125;, &#123;left: &#x27;\\\\(&#x27;, right: &#x27;\\\\)&#x27;, display: false&#125; ], throwOnError: false &#125;); &#125;); &quot;&gt;&lt;/script&gt; 对应的 Markdown 公式写法 123456行内公式：\\\\( \\sqrt&#123;2&#125; \\approx 1.414 \\\\)块级公式：\\\\[\\int_&#123;-\\infty&#125;^\\infty e^&#123;-x^2&#125; dx = \\sqrt&#123;\\pi&#125;\\\\] 通过以上步骤，即可自定义 KaTeX 的界定符，解决与其他语法（如 Markdown 表格、代码块）的冲突问题。","categories":[{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/categories/KaTeX/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"},{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/tags/KaTeX/"}]},{"title":"Hexo添加KaTeX插件-问题处理","slug":"Hexo添加KaTeX插件-问题处理","date":"2025-03-07T05:49:29.000Z","updated":"2025-03-24T11:46:24.876Z","comments":true,"path":"Hexo添加KaTeX插件-问题处理.html","link":"","permalink":"https://silencejql.github.io/Hexo%E6%B7%BB%E5%8A%A0KaTeX%E6%8F%92%E4%BB%B6-%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.html","excerpt":"如果按照 Hexo添加KaTeX插件 仍未生效，可能是某些环节配置错误或冲突导致","text":"如果按照 Hexo添加KaTeX插件 仍未生效，可能是某些环节配置错误或冲突导致 1. 检查关键依赖安装 确保以下依赖已正确安装： 1234567# 确保渲染器和插件存在npm list hexo-renderer-markdown-itnpm list @traptitech/markdown-it-katex# 如果未安装，重新执行：npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it @traptitech/markdown-it-katex --save 2. 确认 Hexo 全局配置 在 Hexo 根目录的 _config.yml 中，检查 markdown-it 的配置： 12345678markdown: render: html: true # 必须开启，否则公式中的 HTML 标签会被转义 plugins: - &quot;@traptitech/markdown-it-katex&quot; # 确保插件名称正确 anchors: level: 2 collisionSuffix: &#x27;v&#x27; 3. 检查 Next 主题配置 在 themes/next/_config.yml 中，确保以下配置： 123456789# 关闭 MathJax 和默认的数学公式渲染math: mathjax: enable: false katex: enable: true # 启用 KaTeX copy_tex: true # 如果 vendor_css 设为 true，需手动添加 CSS（不建议新手开启） vendor_css: false 4. 验证资源加载路径 (1) 检查 CSS 和 JS 是否引入 CSS 位置： 打开生成的网页，按 F12 进入开发者工具 → Network 标签 → 刷新页面，检查是否有 katex.min.css 的请求。若未加载，说明主题模板未正确插入 CSS。 JS 位置： 同样检查 katex.min.js 和 auto-render.min.js 是否加载。如果未加载，检查主题模板文件的修改是否正确。 (2) 修复资源路径 如果使用的是旧版 Next 主题，模板文件路径可能是 .swig 或 .njk，确保修改了正确的文件： CSS：themes/next/layout/_partials/head/head.njk（或 .swig） JS：themes/next/layout/_partials/footer.njk（或 .swig） 手动指定最新版本 CDN（避免缓存问题）： 1234567&lt;!-- CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css&quot; integrity=&quot;sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- JS --&gt;&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js&quot; integrity=&quot;sha384-XjKyOOzGykjIg/xn6ACkxIRv6gm2t6/E2lbLU5ZqH7sBE4k1pL5qfhMcJcH4dZnF&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js&quot; integrity=&quot;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCkM5qKq6gYVvokzNvAQu3fT8KX4l&quot; crossorigin=&quot;anonymous&quot; onload=&quot;renderMathInElement(document.body, &#123; delimiters: [&#123;left: &#x27;$$&#x27;, right: &#x27;$$&#x27;, display: true&#125;, &#123;left: &#x27;$&#x27;, right: &#x27;$&#x27;, display: false&#125;] &#125;);&quot;&gt;&lt;/script&gt; 5. 检查文章 Front-matter 在需要渲染公式的文章头部，确保已添加 katex: true： 12345---title: 测试文章date: 2023-01-01katex: true # 必须开启--- 6. 处理特殊符号转义 如果公式中的 _ 或 * 被错误转义，需调整渲染器配置： 12345678# Hexo 根目录的 _config.ymlmarkdown: html: true xhtmlOut: false breaks: false linkify: true typographer: true quotes: &#x27;“”‘’&#x27; 7. 清理缓存并重新生成 Hexo 的缓存可能导致修改未生效： 1hexo clean &amp;&amp; hexo generate --debug 生成后，检查 public 目录下对应文章的 HTML 文件： 搜索 katex.min.css 和 katex.min.js，确认资源已插入。 检查公式是否被包裹在 &lt;span class=&quot;katex&quot;&gt;...&lt;/span&gt; 中。 8. 常见问题排查 (1) 公式被渲染为纯文本 原因：KaTeX 资源未加载或初始化失败。 解决：按 F12 打开控制台，查看是否有 ReferenceError 或资源加载错误。如果发现 renderMathInElement is not defined，说明 auto-render.min.js 未正确加载。 (2) 公式显示错乱 原因：$ 或 $$ 定界符被其他插件干扰。 解决：在 markdown-it 配置中强制指定定界符： 12345678# Hexo 的 _config.ymlmarkdown: plugins: - name: &quot;@traptitech/markdown-it-katex&quot; options: delimiters: left: &#x27;$&#x27;, right: &#x27;$&#x27;, display: false left: &#x27;$$&#x27;, right: &#x27;$$&#x27;, display: true (3) 与代码高亮冲突 原因：某些代码块语法与 KaTeX 冲突。 解决：在公式前后添加空行，避免与其他内容粘连。 9. 终极测试 创建一个最简单的测试文章，内容如下： 12345678910---title: KaTeX 测试date: 2023-01-01katex: true---行内公式：$E = mc^2$块级公式：$$ \\sum_&#123;i=1&#125;^n i = \\frac&#123;n(n+1)&#125;&#123;2&#125; $$ 如果仍不生效，可能是主题兼容性问题。尝试： 更新 Next 主题到最新版。 换用其他 KaTeX 集成方案（如 hexo-filter-mathjax）。 按以上步骤逐一排查，可解决 99% 的 KaTeX 未生效问题。如果问题依旧，请提供以下信息： 浏览器控制台截图（Network 和 Console 标签）。 测试文章的生成后的 HTML 片段。 Hexo 和 Next 主题的版本号。","categories":[{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/categories/KaTeX/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"},{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/tags/KaTeX/"}]},{"title":"Hexo添加KaTeX插件","slug":"Hexo添加KaTeX插件","date":"2025-03-07T05:46:30.000Z","updated":"2025-03-24T11:46:33.780Z","comments":true,"path":"Hexo添加KaTeX插件.html","link":"","permalink":"https://silencejql.github.io/Hexo%E6%B7%BB%E5%8A%A0KaTeX%E6%8F%92%E4%BB%B6.html","excerpt":"在 Hexo 的 Next 主题中集成 KaTeX 数学公式渲染","text":"在 Hexo 的 Next 主题中集成 KaTeX 数学公式渲染 1. 更换 Markdown 渲染器 Hexo 默认的渲染器可能不支持 KaTeX，需更换为兼容的渲染器： 123npm un hexo-renderer-marked --save # 卸载默认渲染器npm i hexo-renderer-markdown-it --save # 安装 markdown-it 渲染器npm install @traptitech/markdown-it-katex --save # 安装 KaTeX 插件 2. 配置 markdown-it 在 Hexo 根目录的 _config.yml 中添加配置： 123456markdown: plugins: - &quot;@traptitech/markdown-it-katex&quot; anchors: level: 2 collisionSuffix: &#x27;v&#x27; 3. 修改 Next 主题配置 在 Next 主题的配置文件 (themes/next/_config.yml) 中： 关闭 MathJax（避免冲突）： 123math: mathjax: enable: false 启用 KaTeX： 1234katex: enable: true copy_tex: true # 允许复制公式代码 vendor_css: false # 如果手动加载 CSS 可设为 true 4. 引入 KaTeX 资源 在主题布局文件中添加 KaTeX 的 CSS 和 JS： 编辑 themes/next/layout/_partials/head/head.swig，在 &lt;head&gt; 内添加： 123&#123;% if theme.katex.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css&quot;&gt;&#123;% endif %&#125; 编辑 themes/next/layout/_partials/footer.njk（或类似文件），在末尾添加： 123456&#123;% if theme.katex.enable %&#125; &lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js&quot; onload=&quot;renderMathInElement(document.body, &#123; delimiters: [&#123;left: &#x27;$$&#x27;, right: &#x27;$$&#x27;, display: true&#125;, &#123;left: &#x27;$&#x27;, right: &#x27;$&#x27;, display: false&#125;] &#125;);&quot;&gt; &lt;/script&gt;&#123;% endif %&#125; 5. 文章启用 KaTeX 在文章的 Front-matter 中添加 katex: true： 12345678910---title: 测试文章date: 2023-01-01katex: true---行内公式：$E = mc^2$块级公式：$$ \\sum_&#123;i=1&#125;^n i = \\frac&#123;n(n+1)&#125;&#123;2&#125; $$ 6. 处理特殊符号转义 若公式中的 _ 被转义，需调整渲染器配置。在 Hexo 的 _config.yml 中： 1234567markdown: html: true # 允许 HTML 标签 xhtmlOut: false breaks: false linkify: true typographer: true quotes: &#x27;“”‘’&#x27; 7. 测试与清理缓存 生成并预览效果： 1hexo clean &amp;&amp; hexo generate --debug &amp;&amp; hexo server 访问 http://localhost:4000 查看公式是否正确渲染。 常见问题 公式未渲染：检查控制台是否有资源加载错误，确认 CDN 链接有效。 符号错位：确保没有多余的转义字符，使用 \\\\ 代替 \\。 主题版本差异：不同 Next 版本配置项可能不同，参考官方文档调整。 完成以上步骤后，即可在 Hexo 博客中使用 KaTeX 渲染数学公式。","categories":[{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/categories/KaTeX/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"},{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/tags/KaTeX/"}]},{"title":"Katex Test","slug":"Katex-Test","date":"2025-03-07T03:34:34.000Z","updated":"2025-03-07T12:09:12.108Z","comments":true,"path":"Katex-Test.html","link":"","permalink":"https://silencejql.github.io/Katex-Test.html","excerpt":"","text":"行内公式：(E=mc2)(E = mc^2)(E=mc2) 块级公式： ∑i=1ni=n(n+1)2\\sum_{i=1}^n i = \\frac{n(n+1)}{2} i=1∑n​i=2n(n+1)​ K=[fx0cx0fycy001]K = \\begin{bmatrix} f_x &amp; 0 &amp; c_x \\\\ 0 &amp; f_y &amp; c_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} K=​fx​00​0fy​0​cx​cy​1​​","categories":[{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/categories/KaTeX/"}],"tags":[{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/tags/KaTeX/"}]},{"title":"特性使用示例-1","slug":"特性使用示例-1","date":"2025-03-06T02:19:29.000Z","updated":"2025-03-24T11:47:21.956Z","comments":true,"path":"特性使用示例-1.html","link":"","permalink":"https://silencejql.github.io/%E7%89%B9%E6%80%A7%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1.html","excerpt":"实现ini文件的序列化与反序列化","text":"实现ini文件的序列化与反序列化 反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class IniAttribute : Attribute&#123; public string KeyName; public IniAttribute(string keyName) &#123; KeyName = keyName; &#125;&#125;public class Result&#123; [Ini(&quot;长(mm)&quot;)] public object length; [Ini(&quot;宽(mm)&quot;)] public object width; [Ini(&quot;高(mm)&quot;)] public object height;&#125;IniFile iniFile = new IniFile(&quot;D:\\\\Test.ini&quot;);//读取ini文件键值对Dictionary&lt;string, string&gt; resultDic = iniFile.ReadKeyValues(&quot;Test&quot;);Result result = new Result();//获取所有字段foreach (var field in result.GetType().GetFields())&#123; //获取字段的特性 var att = field.GetCustomAttributes(typeof(IniAttribute), true)[0] as IniAttribute; if(att != null) &#123; //特性KeyName与ini中key匹配则给对应字段赋值 if(resultDic.ContainsKey(att.KeyName)) &#123; Type type = field.FieldType; if(type == typeof(string)) field.SetValue(result, resultDic[att.KeyName]); else field.SetValue(result, Convert.ChangeType(resultDic[att.KeyName], type)); &#125; &#125;&#125;//获取所有属性foreach (var prop in result.GetType().GetProperties())&#123; var att = prop.GetCustomAttributes(typeof(IniAttribute), true)[0] as IniAttribute; if(att != null) &#123; if (resultDic.ContainsKey(att.KeyName)) prop.SetValue(result, resultDic[att.KeyName], null); &#125;&#125; 进阶 解析多个Session 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980IniFile iniFile = new IniFile(&quot;D:\\\\Test.ini&quot;);Dictionary&lt;string, Dictionary&lt;string, string&gt;&gt; iniResultDic = new Dictionary&lt;string, Dictionary&lt;string, string&gt;&gt;();TestResult testResult = new TestResult();foreach (var fieldClass in testResult.GetType().GetFields())&#123; //获取特性作为Session var attClass = fieldClass.GetCustomAttributes(typeof(IniSessionAttribute), true)[0] as IniSessionAttribute; if(attClass != null) &#123; //存储该Session下的Key Value Dictionary&lt;string, string&gt; resultDic = iniFile.ReadKeyValues(attClass.SessionName); var obj = fieldClass.GetValue(testResult); foreach (var field in fieldClass.FieldType.GetFields()) &#123; //获取包含IniKey特性的字段 var att = field.GetCustomAttributes(typeof(IniKeyAttribute), true)[0] as IniKeyAttribute; if (att != null) &#123; if (resultDic.ContainsKey(att.KeyName)) &#123; Type type = field.FieldType; if (type == typeof(string)) field.SetValue(obj, resultDic[att.KeyName]); else field.SetValue(obj, Convert.ChangeType(resultDic[att.KeyName], type)); &#125; &#125; &#125; iniResultDic.Add(attClass.SessionName, resultDic); &#125;&#125;public class TestResult&#123; [IniSession(&quot;Result&quot;)] public Result result = new Result(); [IniSession(&quot;Info&quot;)] public Info info = new Info();&#125;public class Result&#123; [IniKey(&quot;长(mm)&quot;)] public double length; [IniKey(&quot;宽(mm)&quot;)] public object width; [IniKey(&quot;高(mm)&quot;)] public string height;&#125;public class Info&#123; [IniKey(&quot;ID&quot;)] public int ID; [IniKey(&quot;结果&quot;)] public string result;&#125;public class IniKeyAttribute : Attribute&#123; public string KeyName; public IniKeyAttribute(string keyName) &#123; KeyName = keyName; &#125;&#125;public class IniSessionAttribute : Attribute&#123; public string SessionName; public IniSessionAttribute(string sessionName) &#123; SessionName = sessionName; &#125;&#125; 封装 12345678910111213141516171819202122232425262728293031323334public T Deserialize&lt;T&gt;(string path)&#123; IniFile iniFile = new IniFile(path); T testResult = (T)Activator.CreateInstance(typeof(T)); foreach (var fieldClass in testResult.GetType().GetFields()) &#123; //获取特性作为Session var attClass = fieldClass.GetCustomAttributes(typeof(IniSessionAttribute), true)[0] as IniSessionAttribute; if (attClass != null) &#123; //存储该Session下的Key Value Dictionary&lt;string, string&gt; resultDic = iniFile.ReadKeyValues(attClass.SessionName); var obj = fieldClass.GetValue(testResult); foreach (var field in fieldClass.FieldType.GetFields()) &#123; //获取包含IniKey特性的字段 var att = field.GetCustomAttributes(typeof(IniKeyAttribute), true)[0] as IniKeyAttribute; if (att != null) &#123; if (resultDic.ContainsKey(att.KeyName)) &#123; Type type = field.FieldType; if (type == typeof(string)) field.SetValue(obj, resultDic[att.KeyName]); else field.SetValue(obj, Convert.ChangeType(resultDic[att.KeyName], type)); &#125; &#125; &#125; &#125; &#125; return testResult;&#125; 序列化 12345678910111213141516171819IniFile iniFile = new IniFile(&quot;D:\\\\Test1.ini&quot;);Result result = new Result();result.width = 235;StringBuilder sb = new StringBuilder();sb.AppendLine(&quot;[SessionName]&quot;)foreach (var field in result.GetType().GetFields())&#123; var att = field.GetCustomAttributes(typeof(IniAttribute), true)[0] as IniAttribute; if (att != null) &#123; object o = field.GetValue(result); if (o != null) &#123; sb.AppendLine(string.Format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, att.KeyName, o.ToString())); &#125; else sb.AppendLine(string.Format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, att.KeyName, &quot;&quot;)); &#125;&#125;File.WriteAllText(&quot;D:\\\\Test1.ini&quot;, sb.ToString()); 进阶 序列化多个Session 12345678910111213141516171819202122232425262728TestResult testResult = new TestResult();testResult.info.ID = 235;testResult.info.result = &quot;不合格&quot;;testResult.result.length = 0;testResult.result.width = 1;testResult.result.height = &quot;&quot;;StringBuilder sb = new StringBuilder();foreach (var fieldClass in testResult.GetType().GetFields())&#123; //获取特性作为Session var attClass = fieldClass.GetCustomAttributes(typeof(IniSessionAttribute), true)[0] as IniSessionAttribute; if (fieldClass != null) &#123; sb.AppendLine(string.Format(&quot;[&#123;0&#125;]&quot;, attClass.SessionName)); var obj = fieldClass.GetValue(testResult); foreach (var field in fieldClass.FieldType.GetFields()) &#123; //获取包含IniKey特性的字段 var att = field.GetCustomAttributes(typeof(IniKeyAttribute), true)[0] as IniKeyAttribute; if (att != null) sb.AppendLine(string.Format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, att.KeyName, field.GetValue(obj))); else sb.AppendLine(string.Format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, att.KeyName, &quot;&quot;)); &#125; &#125;&#125;File.WriteAllText(&quot;D:\\\\Test1.ini&quot;, sb.ToString()); 封装 123456789101112131415161718192021222324public string Serialize&lt;T&gt;(T testResult)&#123; StringBuilder sb = new StringBuilder(); foreach (var fieldClass in testResult.GetType().GetFields()) &#123; //获取特性作为Session var attClass = fieldClass.GetCustomAttributes(typeof(IniSessionAttribute), true)[0] as IniSessionAttribute; if (fieldClass != null) &#123; sb.AppendLine(string.Format(&quot;[&#123;0&#125;]&quot;, attClass.SessionName)); var obj = fieldClass.GetValue(testResult); foreach (var field in fieldClass.FieldType.GetFields()) &#123; //获取包含IniKey特性的字段 var att = field.GetCustomAttributes(typeof(IniKeyAttribute), true)[0] as IniKeyAttribute; if (att != null) sb.AppendLine(string.Format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, att.KeyName, field.GetValue(obj))); else sb.AppendLine(string.Format(&quot;&#123;0&#125;=&#123;1&#125;&quot;, att.KeyName, &quot;&quot;)); &#125; &#125; &#125; return sb.ToString();&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"特性","slug":"特性","permalink":"https://silencejql.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"反射","slug":"反射","permalink":"https://silencejql.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"CSharp读写Ini文件","slug":"CSharp读写Ini文件","date":"2025-03-06T02:16:12.000Z","updated":"2025-03-25T03:26:27.113Z","comments":true,"path":"CSharp读写Ini文件.html","link":"","permalink":"https://silencejql.github.io/CSharp%E8%AF%BB%E5%86%99Ini%E6%96%87%E4%BB%B6.html","excerpt":"自用","text":"自用 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class IniFile&#123; [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)] private static extern long WritePrivateProfileString(byte[] section, byte[] key, byte[] val, string filePath); [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)] private static extern int GetPrivateProfileString(byte[] section, byte[] key, byte[] def, System.Text.StringBuilder retVal, int size, string filePath); [System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;, EntryPoint = &quot;GetPrivateProfileString&quot;)] private static extern uint GetPrivateProfileString2(byte[] section, byte[] key, byte[] def, byte[] retVal, int size, string filePath); private string sPath = null; public IniFile(string path) &#123; this.sPath = path; &#125; // section=配置节，key=键名，value=键值 public void WriteIni(string section, string key, string value) &#123; WritePrivateProfileString(GetBytes(section), GetBytes(key), GetBytes(value), sPath); &#125; public void WriteIni(string section, string key, string value, string sPath) &#123; WritePrivateProfileString(GetBytes(section), GetBytes(key), GetBytes(value), sPath); &#125; // section=配置节，key=键名 public string ReadIni(string section, string key, string sPath) &#123; System.Text.StringBuilder temp = new System.Text.StringBuilder(255); GetPrivateProfileString(GetBytes(section), GetBytes(key), GetBytes(&quot;&quot;), temp, 255, sPath); //return temp.ToString(); return Encoding.UTF8.GetString(Encoding.Default.GetBytes(temp.ToString())); &#125; public string ReadIni(string section, string key) &#123; System.Text.StringBuilder temp = new System.Text.StringBuilder(255); GetPrivateProfileString(GetBytes(section), GetBytes(key), GetBytes(&quot;&quot;), temp, 255, sPath); //return temp.ToString(); return Encoding.UTF8.GetString(Encoding.Default.GetBytes(temp.ToString())); &#125; public void GreatIni(string path) &#123; if (!File.Exists(path)) &#123; FileStream FS = new FileStream(path, FileMode.CreateNew); FS.Close(); &#125; &#125; private byte[] GetBytes(string str, string encodingName = &quot;utf-8&quot;) &#123; return str == null ? null : Encoding.GetEncoding(encodingName).GetBytes(str); &#125; public List&lt;string&gt; ReadSections(string iniFilename) &#123; List&lt;string&gt; result = new List&lt;string&gt;(); Byte[] buf = new Byte[65536]; uint len = GetPrivateProfileString2(null, null, null, buf, buf.Length, iniFilename); int j = 0; for (int i = 0; i &lt; len; i++) if (buf[i] == 0) &#123; result.Add(Encoding.UTF8.GetString(buf, j, i - j)); j = i + 1; &#125; return result; &#125; public List&lt;string&gt; ReadKeys(string SectionName) &#123; List&lt;string&gt; result = new List&lt;string&gt;(); Byte[] buf = new Byte[65536]; uint len = GetPrivateProfileString2(GetBytes(SectionName), null, null, buf, buf.Length, sPath); int j = 0; for (int i = 0; i &lt; len; i++) if (buf[i] == 0) &#123; result.Add(Encoding.UTF8.GetString(buf, j, i - j)); j = i + 1; &#125; return result; &#125; public Dictionary&lt;string, string&gt; ReadKeyValues(string SectionName) &#123; Dictionary&lt;string, string&gt; keyValues = new Dictionary&lt;string, string&gt;(); List&lt;string&gt; keys = ReadKeys(SectionName); keys.ForEach((key) =&gt; &#123; keyValues.Add(key, ReadIni(SectionName, key)); &#125;); return keyValues; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"Ini","slug":"Ini","permalink":"https://silencejql.github.io/tags/Ini/"}]},{"title":"利用反射给字段赋值","slug":"利用反射给字段赋值","date":"2025-03-05T10:41:27.000Z","updated":"2025-03-24T11:47:02.074Z","comments":true,"path":"利用反射给字段赋值.html","link":"","permalink":"https://silencejql.github.io/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BB%99%E5%AD%97%E6%AE%B5%E8%B5%8B%E5%80%BC.html","excerpt":"在 C# 中通过反射给字段赋值是一种动态操作对象成员的常用方法，尤其适用于需要绕过编译时类型检查的场景。以下是完整的实现步骤和代码示例：","text":"在 C# 中通过反射给字段赋值是一种动态操作对象成员的常用方法，尤其适用于需要绕过编译时类型检查的场景。以下是完整的实现步骤和代码示例： 反射赋值的核心步骤 获取类型信息：通过 Type 类获取目标对象的类型元数据。 获取字段信息：通过 GetField 或 GetFields 方法获取目标字段。 设置字段值：使用 FieldInfo.SetValue 方法为字段赋值。 处理类型转换：确保输入值与字段类型兼容（可能需要类型转换）。 完整代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Reflection;public class Person&#123; public string Name; private int Age; public static string Country = &quot;China&quot;;&#125;public class ReflectionDemo&#123; public static void Main() &#123; // 1. 创建对象实例 Person person = new Person(); // 2. 获取类型信息 Type type = typeof(Person); // 3. 设置公共字段 FieldInfo nameField = type.GetField(&quot;Name&quot;); nameField.SetValue(person, &quot;Alice&quot;); Console.WriteLine($&quot;Name: &#123;person.Name&#125;&quot;); // 输出: Alice // 4. 设置私有字段（需要 BindingFlags） FieldInfo ageField = type.GetField(&quot;Age&quot;, BindingFlags.NonPublic | BindingFlags.Instance); ageField.SetValue(person, 30); Console.WriteLine($&quot;Age: &#123;ageField.GetValue(person)&#125;&quot;); // 输出: 30 // 5. 设置静态字段 FieldInfo countryField = type.GetField(&quot;Country&quot;, BindingFlags.Public | BindingFlags.Static); countryField.SetValue(null, &quot;USA&quot;); // 静态字段实例参数传 null Console.WriteLine($&quot;Country: &#123;Person.Country&#125;&quot;); // 输出: USA // 6. 动态类型转换示例 string inputValue = &quot;42&quot;; FieldInfo dynamicField = type.GetField(&quot;Age&quot;, BindingFlags.NonPublic | BindingFlags.Instance); dynamicField.SetValue(person, Convert.ChangeType(inputValue, typeof(int))); &#125;&#125; 关键注意事项 字段可见性： 公共字段直接使用 GetField(&quot;Name&quot;)。 私有字段需要指定 BindingFlags： 1BindingFlags.NonPublic | BindingFlags.Instance 静态字段： 设置静态字段时，SetValue 的第一个参数传 null： 1countryField.SetValue(null, &quot;USA&quot;); 类型转换： 如果字段类型与输入值类型不匹配，需手动转换： 1Convert.ChangeType(value, targetType); 性能优化： 反射操作较慢，频繁调用时可缓存 FieldInfo 对象： 1private static readonly FieldInfo _cachedAgeField = typeof(Person).GetField(...); 安全性： 修改私有字段可能破坏封装性，需谨慎使用。 可通过 fieldInfo.IsInitOnly 检查字段是否为只读。 高级用法：泛型扩展方法 1234567891011121314151617181920212223public static class ReflectionExtensions&#123; public static void SetFieldValue&lt;T&gt;(this T obj, string fieldName, object value) &#123; FieldInfo field = typeof(T).GetField( fieldName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance ); if (field != null) &#123; field.SetValue(obj, value); &#125; else &#123; throw new ArgumentException($&quot;Field &#123;fieldName&#125; not found&quot;); &#125; &#125;&#125;// 使用示例Person person = new Person();person.SetFieldValue(&quot;Age&quot;, 25); // 直接通过扩展方法赋值 适用场景 动态配置加载（如将 JSON/XML 数据映射到对象）。 实现通用序列化/反序列化工具。 编写测试框架时动态修改对象状态。 依赖注入容器等底层框架开发。 替代方案 表达式树（Expression Trees）： 通过编译后的表达式树操作字段，性能接近直接赋值： 12345678var param = Expression.Parameter(typeof(Person));var field = Expression.Field(param, &quot;Name&quot;);var setter = Expression.Lambda&lt;Action&lt;Person, string&gt;&gt;( Expression.Assign(field, Expression.Convert(paramValue, typeof(string))), param, paramValue).Compile();setter(person, &quot;Bob&quot;); dynamic 关键字： 简单场景下快速访问公共字段（但无法访问私有成员）： 12dynamic dynPerson = person;dynPerson.Name = &quot;Charlie&quot;; 通过反射赋值提供了极大的灵活性，但需权衡性能与代码可维护性。在需要高性能的场景，推荐使用预编译的表达式树或代码生成技术（如 Source Generators）。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"特性","slug":"特性","permalink":"https://silencejql.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"反射","slug":"反射","permalink":"https://silencejql.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"利用特性将数据映射到字段","slug":"利用特性将数据映射到字段","date":"2025-03-05T10:40:16.000Z","updated":"2025-03-24T11:47:13.124Z","comments":true,"path":"利用特性将数据映射到字段.html","link":"","permalink":"https://silencejql.github.io/%E5%88%A9%E7%94%A8%E7%89%B9%E6%80%A7%E5%B0%86%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%AD%97%E6%AE%B5.html","excerpt":"以下是利用 C# 特性（Attributes） 将外部数据（如 JSON、数据库记录）动态映射到对象字段的完整实现方法，结合反射和自定义特性实现自动化映射","text":"以下是利用 C# 特性（Attributes） 将外部数据（如 JSON、数据库记录）动态映射到对象字段的完整实现方法，结合反射和自定义特性实现自动化映射 实现步骤 定义自定义特性：创建特性类标记字段与数据源的映射关系。 标记目标字段：在类中使用自定义特性标注需要映射的字段。 编写映射逻辑：通过反射解析特性并动态赋值。 完整代码 1. 定义映射特性 12345678910111213using System;// 自定义特性：标记字段对应的数据源键名[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]public class MapToAttribute : Attribute&#123; public string Key &#123; get; &#125; public MapToAttribute(string key) &#123; Key = key; &#125;&#125; 2. 标记目标类字段 1234567891011public class User&#123; [MapTo(&quot;user_name&quot;)] // 映射数据源中的 &quot;user_name&quot; 键 public string Name; [MapTo(&quot;age&quot;)] private int Age; [MapTo(&quot;registration_date&quot;)] public DateTime RegisterDate &#123; get; set; &#125;&#125; 3. 数据映射工具类 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.Reflection;public static class DataMapper&#123; // 将字典数据映射到对象 public static T MapToObject&lt;T&gt;(Dictionary&lt;string, object&gt; data) where T : new() &#123; T obj = new T(); Type type = typeof(T); foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) &#123; var attribute = field.GetCustomAttribute&lt;MapToAttribute&gt;(); if (attribute != null &amp;&amp; data.TryGetValue(attribute.Key, out object value)) &#123; // 类型转换处理 object convertedValue = Convert.ChangeType(value, field.FieldType); field.SetValue(obj, convertedValue); &#125; &#125; // 处理属性（可选） foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)) &#123; var attribute = prop.GetCustomAttribute&lt;MapToAttribute&gt;(); if (attribute != null &amp;&amp; data.TryGetValue(attribute.Key, out object value)) &#123; prop.SetValue(obj, Convert.ChangeType(value, prop.PropertyType)); &#125; &#125; return obj; &#125;&#125; 使用示例 12345678910111213// 模拟从数据库/JSON获取的数据var data = new Dictionary&lt;string, object&gt;&#123; &#123; &quot;user_name&quot;, &quot;Alice&quot; &#125;, &#123; &quot;age&quot;, 30 &#125;, &#123; &quot;registration_date&quot;, &quot;2023-10-01&quot; &#125;&#125;;// 自动映射数据到对象User user = DataMapper.MapToObject&lt;User&gt;(data);Console.WriteLine(user.Name); // 输出: AliceConsole.WriteLine(user.RegisterDate); // 输出: 2023/10/01 高级优化 1. 支持嵌套对象 123456789101112131415161718public class Address&#123; [MapTo(&quot;city&quot;)] public string City &#123; get; set; &#125;&#125;public class User&#123; [MapTo(&quot;address_info&quot;)] // 假设数据源中 address_info 是嵌套字典 public Address Address;&#125;// 修改映射逻辑，递归处理嵌套类型if (field.FieldType.IsClass &amp;&amp; field.FieldType != typeof(string))&#123; object nestedObj = MapToObject(field.FieldType, data[attribute.Key] as Dictionary&lt;string, object&gt;); field.SetValue(obj, nestedObj);&#125; 2. 类型转换增强 1234567891011// 添加自定义类型转换器public static object SafeConvert(object value, Type targetType)&#123; if (targetType == typeof(DateTime)) &#123; return DateTime.Parse(value.ToString()); &#125; return Convert.ChangeType(value, targetType);&#125;// 替换代码中的 Convert.ChangeType 为 SafeConvert 3. 缓存反射信息 1234567891011121314151617181920// 使用 MemoryCache 缓存 FieldInfo 和特性private static readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions());public static T MapToObjectOptimized&lt;T&gt;(Dictionary&lt;string, object&gt; data) where T : new()&#123; Type type = typeof(T); var fields = _cache.GetOrCreate(type.FullName, entry =&gt; &#123; return type.GetFields() .Select(f =&gt; new &#123; Field = f, Attribute = f.GetCustomAttribute&lt;MapToAttribute&gt;() &#125;) .Where(x =&gt; x.Attribute != null) .ToList(); &#125;); // ... 使用缓存的 fields 进行赋值&#125; 关键注意事项 性能优化： 反射操作较慢，建议缓存 FieldInfo 和特性信息 对于高频调用场景，可使用表达式树或 Source Generators 预编译映射逻辑 错误处理： 处理 Convert.ChangeType 的类型转换异常 检查数据源键是否存在 特性扩展： 可增加更多属性控制映射行为（如是否必填、默认值） 123456public class MapToAttribute : Attribute&#123; public string Key &#123; get; &#125; public bool Required &#123; get; set; &#125; public object DefaultValue &#123; get; set; &#125;&#125; 兼容性： 同时支持字段 (Field) 和属性 (Property) 处理私有字段需指定 BindingFlags.NonPublic 替代方案对比 方法 优点 缺点 反射+特性 灵活，无需预编译代码 性能较低 表达式树 性能接近原生代码 实现复杂度高 Source Generators 零运行时开销，高性能 需要学习 Roslyn API 第三方库 功能完善（如 AutoMapper） 引入外部依赖 通过自定义特性结合反射，可以实现灵活的数据到对象的映射逻辑，适用于配置文件解析、ORM 框架、API 响应反序列化等场景。对于性能敏感项目，建议使用缓存或编译时生成方案。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"特性","slug":"特性","permalink":"https://silencejql.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"反射","slug":"反射","permalink":"https://silencejql.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"ini文件序列化与反序列化","slug":"ini文件序列化与反序列化","date":"2025-03-05T10:37:24.000Z","updated":"2025-03-25T03:26:34.068Z","comments":true,"path":"ini文件序列化与反序列化.html","link":"","permalink":"https://silencejql.github.io/ini%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html","excerpt":"以下是利用 C# 实现 INI 文件序列化与反序列化 的完整解决方案，结合反射和自定义特性，实现对象与 INI 文件的双向转换","text":"以下是利用 C# 实现 INI 文件序列化与反序列化 的完整解决方案，结合反射和自定义特性，实现对象与 INI 文件的双向转换 实现方案 定义特性：标记类和字段对应的 INI 文件区域（Section）和键（Key）。 核心序列化类：通过反射解析特性，动态读写 INI 文件。 支持类型转换：自动处理基本类型、日期、枚举等常见数据类型。 完整代码 1. 定义特性类 12345678910111213141516171819202122232425using System;// 标记类对应的 INI 文件区域（Section）[AttributeUsage(AttributeTargets.Class)]public class IniSectionAttribute : Attribute&#123; public string SectionName &#123; get; &#125; public IniSectionAttribute(string sectionName) &#123; SectionName = sectionName; &#125;&#125;// 标记字段/属性对应的 INI 键（Key）[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]public class IniKeyAttribute : Attribute&#123; public string KeyName &#123; get; &#125; public IniKeyAttribute(string keyName = null) &#123; KeyName = keyName; &#125;&#125; 2. 序列化工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126using System;using System.Collections.Generic;using System.IO;using System.Reflection;using System.Text;public static class IniSerializer&#123; // 序列化对象到 INI 文件 public static void Serialize&lt;T&gt;(T obj, string filePath) &#123; var type = typeof(T); var sectionAttr = type.GetCustomAttribute&lt;IniSectionAttribute&gt;(); string section = sectionAttr?.SectionName ?? type.Name; var sb = new StringBuilder(); foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.Instance)) &#123; ProcessMember(sb, section, field, field.GetValue(obj)); &#125; foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)) &#123; ProcessMember(sb, section, prop, prop.GetValue(obj)); &#125; File.WriteAllText(filePath, sb.ToString()); &#125; // 反序列化 INI 文件到对象 public static T Deserialize&lt;T&gt;(string filePath) where T : new() &#123; var obj = new T(); var type = typeof(T); var sectionAttr = type.GetCustomAttribute&lt;IniSectionAttribute&gt;(); string section = sectionAttr?.SectionName ?? type.Name; var lines = File.ReadAllLines(filePath); var data = new Dictionary&lt;string, string&gt;(); foreach (var line in lines) &#123; if (line.StartsWith(&quot;[&quot;) &amp;&amp; line.EndsWith(&quot;]&quot;)) &#123; // 处理多 Section（此处示例仅处理单个 Section） &#125; else if (line.Contains(&quot;=&quot;)) &#123; var parts = line.Split(new[] &#123; &#x27;=&#x27; &#125;, 2); data[parts[0].Trim()] = parts[1].Trim(); &#125; &#125; foreach (var field in type.GetFields(BindingFlags.Public | BindingFlags.Instance)) &#123; SetMemberValue(obj, field, data); &#125; foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance)) &#123; SetMemberValue(obj, prop, data); &#125; return obj; &#125; private static void ProcessMember(StringBuilder sb, string section, MemberInfo member, object value) &#123; var keyAttr = member.GetCustomAttribute&lt;IniKeyAttribute&gt;(); string keyName = keyAttr?.KeyName ?? member.Name; if (value != null) &#123; sb.AppendLine($&quot;&#123;keyName&#125;=&#123;ConvertToString(value)&#125;&quot;); &#125; &#125; private static void SetMemberValue&lt;T&gt;(T obj, MemberInfo member, Dictionary&lt;string, string&gt; data) &#123; var keyAttr = member.GetCustomAttribute&lt;IniKeyAttribute&gt;(); string keyName = keyAttr?.KeyName ?? member.Name; if (data.TryGetValue(keyName, out string strValue)) &#123; object value = ConvertFromString(strValue, GetMemberType(member)); if (member is FieldInfo field) field.SetValue(obj, value); else if (member is PropertyInfo prop &amp;&amp; prop.CanWrite) prop.SetValue(obj, value); &#125; &#125; private static Type GetMemberType(MemberInfo member) &#123; return member.MemberType switch &#123; MemberTypes.Field =&gt; ((FieldInfo)member).FieldType, MemberTypes.Property =&gt; ((PropertyInfo)member).PropertyType, _ =&gt; throw new NotSupportedException() &#125;; &#125; // 类型转换方法 private static string ConvertToString(object value) &#123; return value switch &#123; DateTime dt =&gt; dt.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;), Enum e =&gt; e.ToString(), _ =&gt; value.ToString() &#125;; &#125; private static object ConvertFromString(string value, Type targetType) &#123; if (targetType == typeof(string)) return value; if (targetType.IsEnum) return Enum.Parse(targetType, value); return Convert.ChangeType(value, targetType); &#125;&#125; 使用示例 1. 定义数据类 123456789101112131415[IniSection(&quot;UserSettings&quot;)]public class UserConfig&#123; [IniKey(&quot;username&quot;)] public string Name &#123; get; set; &#125; [IniKey(&quot;age&quot;)] public int Age; [IniKey(&quot;last_login&quot;)] public DateTime LastLogin; [IniKey(&quot;theme&quot;)] // 使用默认键名 &quot;theme&quot; public string InterfaceTheme = &quot;default&quot;;&#125; 2. 序列化对象到 INI 123456789var config = new UserConfig&#123; Name = &quot;Alice&quot;, Age = 30, LastLogin = DateTime.Now, InterfaceTheme = &quot;dark&quot;&#125;;IniSerializer.Serialize(config, &quot;user_config.ini&quot;); 生成文件内容 (user_config.ini)： 1234username=Aliceage=30last_login=2023-10-05 14:30:00theme=dark 3. 反序列化 INI 到对象 1234var loadedConfig = IniSerializer.Deserialize&lt;UserConfig&gt;(&quot;user_config.ini&quot;);Console.WriteLine(loadedConfig.Name); // 输出: AliceConsole.WriteLine(loadedConfig.Age); // 输出: 30Console.WriteLine(loadedConfig.LastLogin); // 输出: 2023/10/5 14:30:00 高级功能扩展 1. 支持多 Section 123456789101112131415161718192021222324252627public class AppConfig&#123; [IniSection(&quot;User&quot;)] public UserConfig User &#123; get; set; &#125; [IniSection(&quot;System&quot;)] public SystemConfig System &#123; get; set; &#125;&#125;// 修改序列化逻辑，递归处理嵌套对象private static void ProcessMember(StringBuilder sb, string parentSection, MemberInfo member, object value)&#123; var sectionAttr = member.DeclaringType.GetCustomAttribute&lt;IniSectionAttribute&gt;(); string currentSection = sectionAttr?.SectionName ?? parentSection; if (value.GetType().IsClass &amp;&amp; value.GetType() != typeof(string)) &#123; foreach (var subMember in value.GetType().GetMembers()) &#123; ProcessMember(sb, currentSection, subMember, subMember.GetValue(value)); &#125; &#125; else &#123; // 原有处理逻辑 &#125;&#125; 2. 自定义类型转换器 1234567891011121314151617181920public interface IIniTypeConverter&#123; string ConvertToString(object value); object ConvertFromString(string value, Type targetType);&#125;// 注册自定义转换器public static class IniConverters&#123; public static Dictionary&lt;Type, IIniTypeConverter&gt; Converters = new Dictionary&lt;Type, IIniTypeConverter&gt; &#123; &#123; typeof(Version), new VersionConverter() &#125; &#125;;&#125;public class VersionConverter : IIniTypeConverter&#123; public string ConvertToString(object value) =&gt; ((Version)value).ToString(); public object ConvertFromString(string value, Type targetType) =&gt; Version.Parse(value);&#125; 3. 处理注释（扩展特性） 12345678910111213141516[AttributeUsage(AttributeTargets.Class | AttributeTargets.Field | AttributeTargets.Property)]public class IniCommentAttribute : Attribute&#123; public string Comment &#123; get; &#125; public IniCommentAttribute(string comment) &#123; Comment = comment; &#125;&#125;// 在序列化时添加注释if (member.GetCustomAttribute&lt;IniCommentAttribute&gt;() is &#123; &#125; commentAttr)&#123; sb.AppendLine($&quot;; &#123;commentAttr.Comment&#125;&quot;);&#125; 关键注意事项 性能优化： 对频繁调用的类型缓存 MemberInfo 和特性信息 使用 StringBuilder 替代字符串拼接 错误处理： 12345678try&#123; return Convert.ChangeType(value, targetType);&#125;catch (Exception ex)&#123; throw new IniSerializationException($&quot;Type conversion failed: &#123;value&#125; -&gt; &#123;targetType.Name&#125;&quot;, ex);&#125; 编码处理： 使用 Encoding.UTF8 读写文件： 1File.WriteAllText(filePath, sb.ToString(), Encoding.UTF8); 安全限制： 处理私有成员需添加 BindingFlags.NonPublic 对不可写属性跳过赋值 方案对比 方法 优点 缺点 手动读写 完全控制逻辑 代码冗余，维护成本高 反射+特性 自动化，代码简洁 性能较低 第三方库 功能完善（如 IniParser） 需要引入外部依赖 Source Generators 零运行时开销，高性能 实现复杂度高 本方案通过反射和特性实现了 INI 文件与对象的双向转换，适用于配置管理、游戏存档等场景。对于高性能需求，建议结合缓存机制或使用预编译技术优化。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"Ini","slug":"Ini","permalink":"https://silencejql.github.io/tags/Ini/"},{"name":"特性","slug":"特性","permalink":"https://silencejql.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"反射","slug":"反射","permalink":"https://silencejql.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"BBK-相机外参标定","slug":"BBK-相机外参标定","date":"2025-03-04T06:27:30.000Z","updated":"2025-03-24T11:45:46.456Z","comments":true,"path":"BBK-相机外参标定.html","link":"","permalink":"https://silencejql.github.io/BBK-%E7%9B%B8%E6%9C%BA%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A.html","excerpt":"主要利用Opencv中的Cv2.SolvePnP计算旋转平移矩阵来计算轮眉高度","text":"主要利用Opencv中的Cv2.SolvePnP计算旋转平移矩阵来计算轮眉高度 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100List&lt;Point2f&gt; ImagePointlist = new List&lt;Point2f&gt;();ImagePointlist.Add(new Point2f(_calibrationAgorithm.DotLeftTop.X, _calibrationAgorithm.DotLeftTop.Y));ImagePointlist.Add(new Point2f(_calibrationAgorithm.DotRightTop.X, _calibrationAgorithm.DotRightTop.Y));ImagePointlist.Add(new Point2f(_calibrationAgorithm.DotLeftBottom.X, _calibrationAgorithm.DotLeftBottom.Y));ImagePointlist.Add(new Point2f(_calibrationAgorithm.DotRightBottom.X, _calibrationAgorithm.DotRightBottom.Y));float LengthHor = (float)(_calibrationAgorithm.DotHorLength);float LengthVer = (float)(_calibrationAgorithm.DotVerLength);List&lt;Point3f&gt; WorldPointlist = new List&lt;Point3f&gt;();if (_calibrationAgorithm.CoordinateType == ImageAgorithmDot.xCoordinateType.Theory)&#123; WorldPointlist.Add(new Point3f(0, 0, 0)); WorldPointlist.Add(new Point3f(LengthHor, 0, 0)); WorldPointlist.Add(new Point3f(0, LengthVer * -1, 0)); WorldPointlist.Add(new Point3f(LengthHor , LengthVer * -1 , 0)); Camera.ExtrinsicsCalibriton(WorldPointlist, ImagePointlist);&#125;if (_calibrationAgorithm.CoordinateType == ImageAgorithmDot.xCoordinateType.Actual)&#123; Camera.Point3DX = _calibrationAgorithm.W_DotLeftTop.X; Camera.Point3DY = _calibrationAgorithm.W_DotLeftTop.Y; Camera.Point3DZ = Math.Abs(_calibrationAgorithm.W_DotLeftTop.Z); WorldPointlist.Add(new Point3f(0, 0, 0)); WorldPointlist.Add(new Point3f((float)(_calibrationAgorithm.W_DotRightTop.X + _calibrationAgorithm.W_DotLeftTop.X), (float)(_calibrationAgorithm.W_DotRightTop.Y + _calibrationAgorithm.W_DotLeftTop.Y), (float)(_calibrationAgorithm.W_DotRightTop.Z + Math.Abs(_calibrationAgorithm.W_DotLeftTop.Z)))); WorldPointlist.Add(new Point3f((float)(_calibrationAgorithm.W_DotLeftBottom.X + _calibrationAgorithm.W_DotLeftTop.X), (float)(_calibrationAgorithm.W_DotLeftBottom.Y + _calibrationAgorithm.W_DotLeftTop.Y), (float)(_calibrationAgorithm.W_DotLeftBottom.Z + Math.Abs(_calibrationAgorithm.W_DotLeftTop.Z)))); WorldPointlist.Add(new Point3f((float)(_calibrationAgorithm.W_DotRightBottom.X + _calibrationAgorithm.W_DotLeftTop.X), (float)(_calibrationAgorithm.W_DotRightBottom.Y + _calibrationAgorithm.W_DotLeftTop.Y), (float)(_calibrationAgorithm.W_DotRightBottom.Z + Math.Abs(_calibrationAgorithm.W_DotLeftTop.Z)))); Camera.ExtrinsicsCalibriton(WorldPointlist, ImagePointlist,true);&#125;public void ExtrinsicsCalibriton(List&lt;Point3f&gt; WorldPoint, List&lt;Point2f&gt; ImagePoint, bool bActual = false)&#123; double[] Tvecs = new double[3]; double[] Rvecs = new double[3]; double[] tvecs = new double[3]; double[] rvecs = new double[3]; double[,] camera_matrix = new double[3, 3]; double[] dist_coeffs = new double[5]; camera_matrix[0, 0] = Intrinsics_Fx; camera_matrix[0, 1] = 0; camera_matrix[0, 2] = Intrinsics_Cx; camera_matrix[1, 0] = 0; camera_matrix[1, 1] = Intrinsics_Fy; camera_matrix[1, 2] = Intrinsics_Cy; camera_matrix[2, 0] = 0; camera_matrix[2, 1] = 0; camera_matrix[2, 2] = 1; //dist_coeffs[0] = Distortion_K1; //dist_coeffs[1] = Distortion_K2; //dist_coeffs[2] = Distortion_P1; //dist_coeffs[3] = Distortion_P2; //dist_coeffs[4] = Distortion_K3; Cv2.SolvePnP(WorldPoint, ImagePoint, camera_matrix, dist_coeffs.ToList(), ref Rvecs, ref Tvecs); Extrinsics_Rx = Rvecs[0]; Extrinsics_Ry = Rvecs[1]; Extrinsics_Rz = Rvecs[2]; Extrinsics_Tx = Tvecs[0]; Extrinsics_Ty = Tvecs[1]; Extrinsics_Tz = Tvecs[2]; double[,] rotM = new double[3, 3]; Cv2.Rodrigues(Rvecs, out rotM); //将旋转向量变换成旋转矩阵 //不参与计算 double theta_x = Math.Atan2(rotM[2, 1], rotM[2, 2]); double theta_y = Math.Atan2(-rotM[2, 0], Math.Sqrt(rotM[0, 0] * rotM[0, 0] + rotM[1, 0] * rotM[1, 0])); double theta_z = Math.Atan2(rotM[1, 0], rotM[0, 0]); //和上面一样 //theta_x = Math.Atan2(rotM[2, 1], rotM[2, 2]); //theta_y = Math.Atan2(-rotM[2, 0], Math.Sqrt(rotM[2, 1] * rotM[2, 1] + rotM[2, 2] * rotM[2, 2])); //theta_z = Math.Atan2(rotM[1, 0], rotM[0, 0]); //将弧度转化为角度 Extrinsics_Rx_Angle = theta_x * (180 / Math.PI); if (Extrinsics_Rx_Angle &gt; 90) Extrinsics_Rx_Angle = 180 - Extrinsics_Rx_Angle; if (Extrinsics_Rx_Angle &lt; -90) Extrinsics_Rx_Angle = -180 - Extrinsics_Rx_Angle; Extrinsics_Ry_Angle = theta_y * (180 / Math.PI); Extrinsics_Rz_Angle = theta_z * (180 / Math.PI); Matrix matrix = (new Matrix(Tvecs) * Matrix.transpose(new Matrix(rotM))); matrix = new Matrix(new double[] &#123; 0, 0, 0 &#125;) - matrix; Extrinsics_Tx_mm = matrix[0, 0]; Extrinsics_Ty_mm = matrix[0, 1]; Extrinsics_Tz_mm = matrix[0, 2]; if (bActual) &#123; Extrinsics_Tx_mm = Extrinsics_Tx_mm + Point3DX; Extrinsics_Ty_mm = Extrinsics_Ty_mm + Point3DY; Extrinsics_Tz_mm = Extrinsics_Tz_mm + Point3DZ; &#125;&#125;","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Opencv内参标定","slug":"Opencv内参标定","date":"2025-03-04T06:24:58.000Z","updated":"2025-03-07T12:07:27.334Z","comments":true,"path":"Opencv内参标定.html","link":"","permalink":"https://silencejql.github.io/Opencv%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A.html","excerpt":"相机内参标定（Camera Intrinsic Calibration）的目的是确定相机的内部参数，包括焦距、主点坐标和畸变系数等。这些参数描述了相机如何将三维世界中的点投影到二维图像平面上。以下是相机内参标定的原理和步骤。","text":"相机内参标定（Camera Intrinsic Calibration）的目的是确定相机的内部参数，包括焦距、主点坐标和畸变系数等。这些参数描述了相机如何将三维世界中的点投影到二维图像平面上。以下是相机内参标定的原理和步骤。 1. 相机模型 相机的成像过程可以用针孔相机模型描述。相机内参包括以下参数： 焦距(fx,fy)(f_x, f_y)(fx​,fy​)：相机在 xxx 和 yyy 方向上的焦距（以像素为单位）。 主点（cx,cyc_x, c_ycx​,cy​）：图像平面的主点坐标（通常是图像中心）。 畸变系数：描述镜头畸变的参数，包括径向畸变和切向畸变。 相机内参矩阵 KKK 可以表示为： K=[fx0cx0fycy001]K = \\begin{bmatrix} f_x &amp; 0 &amp; c_x \\\\ 0 &amp; f_y &amp; c_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} K=​fx​00​0fy​0​cx​cy​1​​ 2. 畸变模型 镜头畸变主要包括： 径向畸变：由镜头形状引起，通常用多项式模型描述： xcorrected=x(1+k1r2+k2r4+k3r6)x_{\\text{corrected}} = x (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) xcorrected​=x(1+k1​r2+k2​r4+k3​r6) ycorrected=y(1+k1r2+k2r4+k3r6)y_{\\text{corrected}} = y (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) ycorrected​=y(1+k1​r2+k2​r4+k3​r6) 其中 r2=x2+y2r^2 = x^2 + y^2r2=x2+y2，k1,k2,k3k_1, k_2, k_3k1​,k2​,k3​ 是径向畸变系数。 切向畸变：由镜头安装误差引起，通常用以下模型描述： xcorrected=x+[2p1xy+p2(r2+2x2)]x_{\\text{corrected}} = x + [2 p_1 xy + p_2 (r^2 + 2 x^2)] xcorrected​=x+[2p1​xy+p2​(r2+2x2)] ycorrected=y+[p1(r2+2y2)+2p2xy]y_{\\text{corrected}} = y + [p_1 (r^2 + 2 y^2) + 2 p_2 xy] ycorrected​=y+[p1​(r2+2y2)+2p2​xy] 其中 p1,p2p_1, p_2p1​,p2​ 是切向畸变系数。 3. 标定原理 相机内参标定通常使用已知几何形状的标定板（如棋盘格或圆点阵列）。标定过程包括以下步骤： 采集图像：从不同角度拍摄标定板的图像。 检测特征点：在图像中检测标定板的特征点（如棋盘格的角点）。 建立对应关系：将图像中的特征点与标定板的已知 3D 坐标对应起来。 优化求解：通过最小化重投影误差，求解相机内参和畸变系数。 4. 重投影误差 重投影误差是标定的关键指标，表示标定板的 3D 点投影到图像平面后与实际检测到的 2D 点之间的距离。标定的目标是最小化重投影误差： 误差=∑i=1n∥pi−p^i∥2\\text{误差} = \\sum_{i=1}^{n} \\| \\mathbf{p}_i - \\hat{\\mathbf{p}}_i \\|^2 误差=i=1∑n​∥pi​−p^​i​∥2 其中： pi\\mathbf{p}_ipi​ 是实际检测到的 2D 点。 p^i\\hat{\\mathbf{p}}_ip^​i​ 是通过相机模型投影得到的 2D 点。 5. 标定步骤 以下是相机内参标定的具体步骤： 准备标定板：使用棋盘格或圆点阵列作为标定板。 采集图像：从不同角度拍摄标定板的图像（通常需要 10-20 张）。 检测特征点：使用 OpenCV 或其他工具检测标定板的特征点。 建立 3D-2D 对应关系：将标定板的 3D 坐标与图像中的 2D 点对应起来。 调用标定函数：使用 OpenCV 的 calibrateCamera 函数求解相机内参和畸变系数。 评估标定结果：检查重投影误差，确保标定精度。 6. 示例代码（OpenCV） 以下是使用 OpenCV 进行相机内参标定的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport cv2# 1. 准备标定板的 3D 坐标square_size = 1.0 # 棋盘格方块的尺寸（单位：任意）pattern_size = (9, 6) # 棋盘格内角点数量objp = np.zeros((pattern_size[0] * pattern_size[1], 3), np.float32)objp[:, :2] = np.mgrid[0:pattern_size[0], 0:pattern_size[1]].T.reshape(-1, 2)objp *= square_size# 2. 存储 3D 点和 2D 点objpoints = [] # 3D 点imgpoints = [] # 2D 点# 3. 读取标定图像images = [&quot;calib1.jpg&quot;, &quot;calib2.jpg&quot;, &quot;calib3.jpg&quot;] # 标定图像路径for fname in images: img = cv2.imread(fname) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 检测棋盘格角点 ret, corners = cv2.findChessboardCorners(gray, pattern_size, None) if ret: objpoints.append(objp) imgpoints.append(corners) # 可视化角点 cv2.drawChessboardCorners(img, pattern_size, corners, ret) cv2.imshow(&quot;Corners&quot;, img) cv2.waitKey(500)cv2.destroyAllWindows()# 4. 标定相机ret, K, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)# 5. 输出结果print(&quot;相机内参矩阵 K:\\n&quot;, K)print(&quot;畸变系数 dist:\\n&quot;, dist)print(&quot;重投影误差:&quot;, ret) 7. 输出结果 相机内参矩阵 KKK：包含焦距和主点坐标。 畸变系数 distdistdist：包含径向和切向畸变系数。 重投影误差：表示标定的精度，误差越小越好。 8. 注意事项 标定板的质量：标定板的角点检测必须准确。 图像数量：通常需要 10-20 张图像以确保标定精度。 图像角度：标定图像应覆盖不同的角度和位置，以提高标定鲁棒性。 通过上述方法，可以完成相机内参标定，并获得相机的内部参数和畸变系数。","categories":[],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://silencejql.github.io/tags/OpenCV/"}]},{"title":"BBK-相机内参标定","slug":"BBK-相机内参标定","date":"2025-03-04T06:05:40.000Z","updated":"2025-03-28T05:15:05.224Z","comments":true,"path":"BBK-相机内参标定.html","link":"","permalink":"https://silencejql.github.io/BBK-%E7%9B%B8%E6%9C%BA%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A.html","excerpt":"介绍BBK软件中采用的简易内参标定, 用于计算相机焦距, 本文主要用于老版本HUD和轮眉软件. 新版本相机内参在公司出厂前就会标定好, 不需要现场标定, 并且标定方式也与本文不同","text":"介绍BBK软件中采用的简易内参标定, 用于计算相机焦距, 本文主要用于老版本HUD和轮眉软件. 新版本相机内参在公司出厂前就会标定好, 不需要现场标定, 并且标定方式也与本文不同 BBK使用的内参标定方法一 原理 小孔成像图自行脑补 D_{\\text{物距}} / f_{\\text{焦距}} = L_{\\text{物体尺寸}} / p_{\\text{图像尺寸}}$$$$(D-f)/f = L/p 其中, DDD为感光芯片到物体的距离, fff为相机焦距, LLL为物体实际尺寸, ppp为物体在图像中的像素尺寸 由于无法准确测量像距所以近似认为,D=D物距+f(近似认为像距=焦距)D= D_{\\text{物距}} + f(近似认为像距=焦距)D=D物距​+f(近似认为像距=焦距) 推导出焦距计算公式为: (D−f)/f=D/f−1=L/p(D-f)/f = D/f-1 = L/p (D−f)/f=D/f−1=L/p D/f=L/p+1=(L+p)/pD/f = L/p + 1 = (L+p)/p D/f=L/p+1=(L+p)/p f/D = p/(L+p)$$$$f = D*p / (L+p) 误差说明 首先公式中唯一需要测量的D即标靶到相机感光芯片的距离要求测量准确 其次由于近似认为物体成像在一倍焦距上, 所以D−fD-fD−f会根据焦距大小不同存在几毫米到到十几毫米的误差, 被测图像越远误差越小 示例: D=2400D = 2400D=2400, p=1983∗0.00167p = 1983 * 0.00167p=1983∗0.00167, L=280L = 280L=280 f=2400∗1983∗0.00167/(280+1983∗0.00167)=2400∗3.3116/(280+3.3116)=28.0533518571f = 2400 * 1983 * 0.00167 / (280 + 1983 * 0.00167) = 2400 * 3.3116 / (280 + 3.3116) = 28.0533518571f=2400∗1983∗0.00167/(280+1983∗0.00167)=2400∗3.3116/(280+3.3116)=28.0533518571 测量误差和像距误差均体现在D上, 假设误差为10mm, 会导致f=2410∗3.3116/(280+3.3116)=28.17024f = 2410 * 3.3116 / (280 + 3.3116) = 28.17024f=2410∗3.3116/(280+3.3116)=28.17024, 焦距误差为0.116888 焦距误差对测量值的影响如下: 体现在投影距离上: 单目: 测量值: Distance=1082/(2495∗0.00167/28.0533518571)=7284.92471Distance = 1082 / (2495 * 0.00167 / 28.0533518571) = 7284.92471Distance=1082/(2495∗0.00167/28.0533518571)=7284.92471 实际值: Distance=1082/(2495∗0.00167/28.17024)=7315.25928Distance = 1082 / (2495 * 0.00167 / 28.17024) = 7315.25928Distance=1082/(2495∗0.00167/28.17024)=7315.25928 焦距误差导致的投影距离误差约为: 30mm 双目: 测量值: Distance=28.0533518571/0.00167∗65/(1584−1169)=28.0533518571/0.00167∗65/150=7279.31Distance = 28.0533518571 / 0.00167 * 65 / (1584 - 1169) = 28.0533518571 / 0.00167 * 65 / 150 = 7279.31Distance=28.0533518571/0.00167∗65/(1584−1169)=28.0533518571/0.00167∗65/150=7279.31 实际值: Distance=28.17024/0.00167∗65/150=7309.643Distance = 28.17024 / 0.00167 * 65 / 150 = 7309.643Distance=28.17024/0.00167∗65/150=7309.643 焦距误差导致的投影距离误差约为: 30mm 体现在角度上: 测量值: Lda=atan(132∗0.00167/28.0533518571)=0.45°Lda = atan(132 * 0.00167 / 28.0533518571) = 0.45°Lda=atan(132∗0.00167/28.0533518571)=0.45° 实际值: Lda=atan(132∗0.00167/28.17024)=0.448°Lda = atan(132 * 0.00167 / 28.17024) = 0.448°Lda=atan(132∗0.00167/28.17024)=0.448° 焦距误差导致的角度误差约为:0.002° BBK软件实现 123456789101112131415161718192021222324252627282930313233Camera.IntrinsicsCalibriton(_calibrationAgorithm.DotLeftTop, _calibrationAgorithm.DotRightTop, _calibrationAgorithm.DotLeftBottom, _calibrationAgorithm.DotRightBottom, _calibrationAgorithm.DotHorLength, _calibrationAgorithm.DotVerLength, _calibrationAgorithm.DotDistance);public void IntrinsicsCalibriton(PointF LeftTop, PointF RightTop, PointF LeftBottom, PointF RightBottom, double LengthHor, double LengthVer, double Distance)&#123; // 计算四点组成矩形的四条边长(单位像素) double L1 = Math.Sqrt((RightTop.X - LeftTop.X) * (RightTop.X - LeftTop.X) + (RightTop.Y - LeftTop.Y) * (RightTop.Y - LeftTop.Y)); double L2 = Math.Sqrt((LeftBottom.X - LeftTop.X) * (LeftBottom.X - LeftTop.X) + (LeftBottom.Y - LeftTop.Y) * (LeftBottom.Y - LeftTop.Y)); double L3 = Math.Sqrt((RightBottom.X - LeftBottom.X) * (RightBottom.X - LeftBottom.X) + (RightBottom.Y - LeftBottom.Y) * (RightBottom.Y - LeftBottom.Y)); double L4 = Math.Sqrt((RightBottom.X - RightTop.X) * (RightBottom.X - RightTop.X) + (RightBottom.Y - RightTop.Y) * (RightBottom.Y - RightTop.Y)); double diffPixelX = (L1 + L3) / 2;// 图像平均横向长度(像素) double diffPixelY = (L2 + L4) / 2;// 图像平均竖向长度(像素) if ((diffPixelX == 0) || (diffPixelY == 0)) throw new ArgumentOutOfRangeException(&quot;boardParam.RightTop , boardParam.LeftTop , boardParam.RightBottom , boardParam.LeftBottom&quot;); double fx = (Distance * diffPixelX * PixelSize) / (LengthHor + diffPixelX * PixelSize); double fy = (Distance * diffPixelY * PixelSize) / (LengthVer + diffPixelY * PixelSize); // 相机焦距为XY方向的平均焦距(单位毫米) Intrinsics_f = fx / 2 + fy / 2; // 相机内参(单位像素) Intrinsics_Fx = (fx / PixelSize).Round(4); Intrinsics_Fy = (fy / PixelSize).Round(4); // 相机内参(单位像素) Intrinsics_Cx = PixelWidth / 2; Intrinsics_Cy = PixelHeight / 2;&#125;","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"图像坐标转换为世界坐标","slug":"图像坐标转换为世界坐标","date":"2025-03-04T05:53:13.000Z","updated":"2025-03-28T03:00:06.694Z","comments":true,"path":"图像坐标转换为世界坐标.html","link":"","permalink":"https://silencejql.github.io/%E5%9B%BE%E5%83%8F%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87.html","excerpt":"理解轮眉测试中如何通过识别图像点计算实际轮眉高度, 转换函数为:CameraLib.CameraAgorithm下的public static PointF3D Pixel2World(PointF Pixel, CameraBase _camera, double Distance) 图像坐标转换为空间坐标的过程涉及相机的内参矩阵、外参矩阵（旋转矩阵和平移向量）以及可能的深度信息.","text":"理解轮眉测试中如何通过识别图像点计算实际轮眉高度, 转换函数为:CameraLib.CameraAgorithm下的public static PointF3D Pixel2World(PointF Pixel, CameraBase _camera, double Distance) 图像坐标转换为空间坐标的过程涉及相机的内参矩阵、外参矩阵（旋转矩阵和平移向量）以及可能的深度信息. 1. 坐标系定义 世界坐标系（World Coordinate System）：三维空间中的绝对坐标系，记为 (Xw,Yw,Zw)(X_w, Y_w, Z_w)(Xw​,Yw​,Zw​)。 相机坐标系（Camera Coordinate System）：以相机光心为原点，记为 (Xc,Yc,Zc)(X_c, Y_c, Z_c)(Xc​,Yc​,Zc​)。 图像坐标系（Image Coordinate System）：二维像素坐标系，记为 (u,v)(u, v)(u,v)。 2. 转换流程 图像坐标到空间坐标的转换需要以下步骤： 从图像坐标系到相机坐标系（逆投影）： 利用相机内参矩阵和深度信息，将像素坐标转换为相机坐标系下的三维坐标。 从相机坐标系到世界坐标系： 利用相机的外参矩阵（旋转矩阵 RRR 和平移向量 TTT），将相机坐标系下的坐标转换为世界坐标系。 3. 公式推导 （1）相机模型与投影公式 相机的投影公式为： Zc[uv1]=K[RT][XwYwZw1]Z_c \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} = K \\begin{bmatrix} R &amp; T \\end{bmatrix} \\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\\\ 1 \\end{bmatrix} Zc​​uv1​​=K[R​T​]​Xw​Yw​Zw​1​​ 其中： KKK 为内参矩阵：K=[fx0cx0fycy001]K = \\begin{bmatrix} f_x &amp; 0 &amp; c_x \\\\ 0 &amp; f_y &amp; c_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} K=​fx​00​0fy​0​cx​cy​1​​ RRR 和 TTT 为外参矩阵（旋转和平移）。 （2）逆投影：图像坐标 → 相机坐标系 假设已知深度 ZcZ_cZc​，图像坐标 (u,v)(u, v)(u,v) 对应的相机坐标系坐标为： {Xc=(u−cx)⋅ZcfxYc=(v−cy)⋅ZcfyZc=已知深度值\\begin{cases} X_c = \\frac{(u - c_x) \\cdot Z_c}{f_x} \\\\ Y_c = \\frac{(v - c_y) \\cdot Z_c}{f_y} \\\\ Z_c = \\text{已知深度值} \\end{cases} ⎩⎨⎧​Xc​=fx​(u−cx​)⋅Zc​​Yc​=fy​(v−cy​)⋅Zc​​Zc​=已知深度值​ 矩阵形式： [XcYcZc]=K−1⋅Zc⋅[uv1]\\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\end{bmatrix} = K^{-1} \\cdot Z_c \\cdot \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} ​Xc​Yc​Zc​​​=K−1⋅Zc​⋅​uv1​​ 其中 K−1K^{-1}K−1 为内参矩阵的逆： K−1=[1fx0−cxfx01fy−cyfy001]K^{-1} = \\begin{bmatrix} \\frac{1}{f_x} &amp; 0 &amp; -\\frac{c_x}{f_x} \\\\ 0 &amp; \\frac{1}{f_y} &amp; -\\frac{c_y}{f_y} \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} K−1=​fx​1​00​0fy​1​0​−fx​cx​​−fy​cy​​1​​ （3）相机坐标系 → 世界坐标系 利用外参矩阵将相机坐标系坐标转换到世界坐标系： [XwYwZw1]=[RT−RTT01]⋅[XcYcZc1]\\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} R^T &amp; -R^T T \\\\ 0 &amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} X_c \\\\ Y_c \\\\ Z_c \\\\ 1 \\end{bmatrix} ​Xw​Yw​Zw​1​​=[RT0​−RTT1​]⋅​Xc​Yc​Zc​1​​ 其中 RTR^TRT 是旋转矩阵的转置，−RTT-R^T T−RTT 是平移向量的逆变换。 4. 整合公式 若已知深度 ZcZ_cZc​，完整的转换公式为： [XwYwZw]=RT(K−1⋅Zc⋅[uv1]−T)\\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\end{bmatrix} = R^T \\left( K^{-1} \\cdot Z_c \\cdot \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} - T \\right) ​Xw​Yw​Zw​​​=RT​K−1⋅Zc​⋅​uv1​​−T​ 5. 特殊情况说明 深度未知（单目相机）： 单张图像无法唯一确定三维坐标，需通过多视图几何（如立体匹配）或已知约束（如平面假设）求解。 平面场景假设： 若物体位于已知平面 Zw=0Z_w = 0Zw​=0，可通过单应性矩阵（Homography）直接转换。 6. 总结 核心公式：[XwYwZw]=RT(K−1⋅Zc⋅[uv1]−T)\\begin{bmatrix} X_w \\\\ Y_w \\\\ Z_w \\end{bmatrix} = R^T \\left( K^{-1} \\cdot Z_c \\cdot \\begin{bmatrix} u \\\\ v \\\\ 1 \\end{bmatrix} - T \\right) ​Xw​Yw​Zw​​​=RT​K−1⋅Zc​⋅​uv1​​−T​ 依赖参数： 相机内参 KKK、外参 R,TR, TR,T、深度 ZcZ_cZc​。 适用场景： 深度已知（如 RGB-D 相机）或多视图几何（双目视觉）。 1234567891011121314151617181920212223242526272829public static PointF3D Pixel2World(PointF Pixel, CameraBase _camera, double Distance)&#123; Mat Rvecs = new Mat(3, 1, MatType.CV_64FC1, new double[] &#123; _camera.Extrinsics_Rx, _camera.Extrinsics_Ry, _camera.Extrinsics_Rz &#125;); Mat Tvecs = new Mat(3, 1, MatType.CV_64FC1, new double[] &#123; _camera.Extrinsics_Tx, _camera.Extrinsics_Ty, _camera.Extrinsics_Tz &#125;); Mat RotationMatrix = new Mat(3, 3, MatType.CV_64FC1); Mat RotationMatrix_Invert = new Mat(3, 3, MatType.CV_64FC1); Mat CameraMatrix = new Mat(3,3,MatType.CV_64FC1,new double[3,3]&#123; &#123;_camera.Intrinsics_Fx,0,_camera.Intrinsics_Cx&#125;, &#123;0,_camera.Intrinsics_Fy,_camera.Intrinsics_Cy&#125;, &#123;0,0,1&#125;&#125;); Mat CameraMatrix_Invert = new Mat(3,3,MatType.CV_64FC1); Mat ImagePoint = new Mat(3, 1, MatType.CV_64FC1, new double[] &#123; Pixel.X, Pixel.Y, 1 &#125;); Cv2.Rodrigues(Rvecs, RotationMatrix); Cv2.Invert(RotationMatrix, RotationMatrix_Invert, DecompTypes.SVD); Cv2.Invert(CameraMatrix, CameraMatrix_Invert, DecompTypes.SVD); //计算坐标(相机坐标系) Mat wcPoint = RotationMatrix_Invert * (Distance * CameraMatrix_Invert * ImagePoint - Tvecs); PointF3D worldPoint = new PointF3D( wcPoint.At&lt;double&gt;(0, 0) + _camera.Point3DX, wcPoint.At&lt;double&gt;(1, 0) + _camera.Point3DY, wcPoint.At&lt;double&gt;(2, 0) + _camera.Point3DZ); return worldPoint;&#125;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://silencejql.github.io/tags/OpenCV/"}]},{"title":"Git 修改历史提交的Commit信息","slug":"Git-修改历史提交的Commit信息","date":"2025-03-04T05:21:59.000Z","updated":"2025-04-01T04:48:28.237Z","comments":true,"path":"Git-修改历史提交的Commit信息.html","link":"","permalink":"https://silencejql.github.io/Git-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E7%9A%84Commit%E4%BF%A1%E6%81%AF.html","excerpt":"在提交远程仓库前先精简本地主分支的commit, 然后再提交, 保证远程仓库commit的整洁 每次提交最好只包含一个功能性更改, 方便后续回溯 在 Git 中修改历史提交需要谨慎操作，因为这会影响仓库的提交历史。以下是几种常见的修改历史提交的方法，以及它们的适用场景和注意事项：","text":"在提交远程仓库前先精简本地主分支的commit, 然后再提交, 保证远程仓库commit的整洁 每次提交最好只包含一个功能性更改, 方便后续回溯 在 Git 中修改历史提交需要谨慎操作，因为这会影响仓库的提交历史。以下是几种常见的修改历史提交的方法，以及它们的适用场景和注意事项： 1. 修改最近一次提交（尚未推送） 场景：修改最后一次提交的提交信息或文件内容。 命令： 1git commit --amend 修改提交信息：直接运行后会进入编辑器修改信息。 添加文件到提交：先 git add &lt;file&gt;，再运行 git commit --amend --no-edit（保留原提交信息）。 2. 修改更早的提交（交互式变基） 场景：修改某个历史提交（如提交信息、文件内容）或合并多个提交。 步骤： 启动交互式变基： 1git rebase -i HEAD~n # 例如 HEAD~3 表示最近 3 次提交 在编辑器中找到要修改的提交行，将 pick 改为 edit，保存退出。 Git 会停在目标提交处，此时可以： 修改文件内容：git add &lt;file&gt;。 修改提交信息：git commit --amend。 继续变基： 1git rebase --continue 如果中途出错，可以用 git rebase --abort 终止变基。 3. 删除历史中的某个提交 场景：完全删除某个错误的提交。 步骤： 运行交互式变基： 1git rebase -i HEAD~n 删除对应提交的行（或将其标记为 drop）。 保存退出，Git 会自动跳过该提交。 4. 合并多个提交 场景：将多个小提交合并为一个逻辑完整的提交。 步骤： 运行交互式变基： 1git rebase -i HEAD~n 将需要合并的提交行的 pick 改为 squash（合并并保留提交信息）或 fixup（合并但丢弃提交信息）。 保存后 Git 会提示编辑合并后的提交信息。 5. 强制推送修改后的历史 如果修改的是已推送到远程仓库的历史，需强制推送： 123git push --force# 更安全的选项（避免覆盖他人提交）git push --force-with-lease 注意：强制推送会覆盖远程历史，需确保团队其他成员已同步你的修改。 6. 彻底删除敏感信息 如果提交中误添加了敏感信息（如密码），需使用 git filter-repo 工具： 安装 git-filter-repo： 1pip install git-filter-repo 删除包含敏感信息的文件： 1git filter-repo --path-sensitive-file --invert-paths 强制推送清理后的仓库： 1git push origin --force --all ⚠️ 注意事项 仅限本地未推送的提交：修改已推送的历史会影响他人，需与团队协商。 备份分支：操作前备份当前分支（git branch backup）。 慎用 --force：强制推送可能导致他人代码丢失。 示例：修改某次旧提交的信息 123456789101112# 1. 启动交互式变基（假设修改倒数第3次提交）git rebase -i HEAD~3# 2. 将目标提交行的 &quot;pick&quot; 改为 &quot;edit&quot;，保存退出# 3. 修改提交信息git commit --amend -m &quot;New commit message&quot;# 4. 继续变基git rebase --continue# 5. 强制推送（如果已推送过）git push --force-with-lease 如果需要更复杂的操作（如拆分提交），可结合 git reset 逐步重构历史。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"CSharp 获取当前运行函数名","slug":"CSharp-获取当前运行函数名","date":"2025-02-06T09:26:02.000Z","updated":"2025-03-24T11:45:34.967Z","comments":true,"path":"CSharp-获取当前运行函数名.html","link":"","permalink":"https://silencejql.github.io/CSharp-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E5%87%BD%E6%95%B0%E5%90%8D.html","excerpt":"Generated by AI","text":"Generated by AI 在 C# 中，可以通过 System.Reflection 命名空间和 System.Diagnostics 命名空间提供的工具来获取当前运行的函数名。以下是几种常见方法： 方法 1：使用 MethodBase.GetCurrentMethod()（推荐） 通过反射直接获取当前执行的方法名： 1234567891011using System.Reflection;public class Example&#123; public void MyMethod() &#123; // 获取当前方法名 string methodName = MethodBase.GetCurrentMethod().Name; Console.WriteLine($&quot;当前方法名: &#123;methodName&#125;&quot;); &#125;&#125; 输出 1当前方法名: MyMethod 特点 简单直接：无需复杂堆栈操作。 性能优化：避免堆栈遍历，效率较高。 注意：如果方法被内联优化（如 Release 模式），可能无法准确获取方法名，需禁用内联（添加 [MethodImpl(MethodImplOptions.NoInlining)]）。 方法 2：使用 StackTrace 和 StackFrame 通过分析调用堆栈获取当前方法名： 12345678910111213using System.Diagnostics;public class Example&#123; public void MyMethod() &#123; // 获取当前方法名 StackTrace stackTrace = new StackTrace(); StackFrame stackFrame = stackTrace.GetFrame(0); // 0 表示当前方法 string methodName = stackFrame.GetMethod().Name; Console.WriteLine($&quot;当前方法名: &#123;methodName&#125;&quot;); &#125;&#125; 输出 1当前方法名: MyMethod 特点 灵活性：可获取调用链中任意层级的方法名（通过调整 GetFrame(n) 的索引 n）。 潜在问题：在 Release 模式下可能因编译器优化（如方法内联或尾调用优化）导致堆栈信息不准确。 性能开销：遍历堆栈的开销较大，频繁调用需谨慎。 方法 3：获取调用者的方法名 若需获取调用当前方法的上层方法名： 123456789101112131415161718using System.Diagnostics;public class Example&#123; public void MethodA() &#123; MethodB(); &#125; public void MethodB() &#123; // 获取调用者方法名（MethodA） StackTrace stackTrace = new StackTrace(); StackFrame stackFrame = stackTrace.GetFrame(1); // 1 表示上层调用 string callerName = stackFrame.GetMethod().Name; Console.WriteLine($&quot;调用者方法名: &#123;callerName&#125;&quot;); &#125;&#125; 输出 1调用者方法名: MethodA 注意 索引值：GetFrame(0) 是当前方法，GetFrame(1) 是调用者，依此类推。 编译器优化：可能导致堆栈层级变化，需实际测试验证。 方法 4：使用 nameof 表达式（C# 6+） 如果只需要当前方法的静态名称（非动态获取），可以使用 nameof： 12345678public class Example&#123; public void MyMethod() &#123; string methodName = nameof(MyMethod); Console.WriteLine($&quot;方法名: &#123;methodName&#125;&quot;); &#125;&#125; 输出 1方法名: MyMethod 特点 编译时确定：名称在编译时解析，无法动态获取运行时调用的方法名。 类型安全：避免拼写错误，适合硬编码方法名的场景。 总结 方法 场景 优点 缺点 MethodBase.GetCurrentMethod() 直接获取当前方法名 简单高效 可能受编译器优化影响 StackTrace/StackFrame 分析调用堆栈，灵活获取层级信息 支持多层调用链分析 性能开销大，优化环境下不可靠 nameof 编译时获取静态方法名 类型安全，无运行时开销 无法动态获取运行时方法名 根据具体需求选择合适的方法！","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp Linq","slug":"CSharp-Linq","date":"2024-12-29T02:59:51.000Z","updated":"2025-03-24T11:45:27.640Z","comments":true,"path":"CSharp-Linq.html","link":"","permalink":"https://silencejql.github.io/CSharp-Linq.html","excerpt":"Linqpad8 linq","text":"Linqpad8 linq 123456789101112131415161718192021222324252627282930313233//1.var numbers = new List&lt;int&gt;();numbers.Add (1);IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * 10); // Build querynumbers.Add (2); // Sneak in an extra elementquery.Dump (&quot;Notice both elements are returned in the result set&quot;);numbers.Add (3);query.Dump();//10,20,30//2. var numbers = new List&lt;int&gt;() &#123; 1, 2 &#125;;List&lt;int&gt; timesTen = numbers .Select (n =&gt; n * 10) .ToList(); // Executes immediately into a List&lt;int&gt;numbers.Clear();timesTen.Count.Dump (&quot;Still two elements present&quot;);//3.int[] numbers = &#123; 1, 2 &#125;;int factor = 10;IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * factor);factor = 20;query.Dump (&quot;Notice both numbers are multiplied by 20, not 10&quot;);","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"WindowsTerminal配置","slug":"WindowsTerminal配置","date":"2024-11-27T06:15:48.000Z","updated":"2025-03-07T12:42:20.983Z","comments":true,"path":"WindowsTerminal配置.html","link":"","permalink":"https://silencejql.github.io/WindowsTerminal%E9%85%8D%E7%BD%AE.html","excerpt":"配置windows终端","text":"配置windows终端 终端 1. 下载 可于windows应用商店下载 2. 下载安装Scoop 2.1 设置远程权限 Set-ExecutionPolicy RemoteSigned -scope CurrentUser 2.2 下载安装 irm get.scoop.sh | iex 3. 安装 PSReadline 包，该插件可以让命令行很好用，类似 zsh Install-Module -Name PSReadLine -Scope CurrentUser 4. 安装 posh-git 包，让你的 git 更好用 Install-Module posh-git -Scope CurrentUser 5. 安装 oh-my-posh 包，让你的命令行更酷炫、优雅 Install-Module oh-my-posh -Scope CurrentUser 6. 添加Powershell配置参数 notepad $Profile 在文件中添加如下 12345678910111213141516171819202122232425262728293031323334353637383940414243# 引入 posh-gitImport-Module posh-git# 引入 oh-my-poshImport-Module oh-my-posh# 引入 ps-read-lineImport-Module PSReadLine# oh-my-posh init pwsh | Invoke-Expression#oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/jandedobbeleer.omp.json&quot; | Invoke-Expression#oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/1_shell.omp.json&quot; | Invoke-Expressionoh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/kushal.omp.json&quot; | Invoke-Expression#oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/montys.omp.json&quot; | Invoke-Expression#oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/honukai.omp.json&quot; | Invoke-Expression#oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH/atomic.omp.json&quot; | Invoke-Expression# 设置预测文本来源为历史记录Set-PSReadLineOption -PredictionSource History# 每次回溯输入历史，光标定位于输入内容末尾Set-PSReadLineOption -HistorySearchCursorMovesToEnd# 设置 Tab 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Key &quot;Tab&quot; -Function MenuComplete# 设置 Ctrl+d 为退出 PowerShellSet-PSReadlineKeyHandler -Key &quot;Ctrl+d&quot; -Function ViExit# 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo# 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward# 设置向下键为前向搜索历史纪录Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForwardImport-Module posh-git # git的自动补全Import-Module -Name Terminal-IconsSet-Alias cl clear 7. 添加完成后执行 . $PROFILE 8. 美化icon Install-Module -Name Terminal-Icons -Repository PSGallery 9. 安装Busybox 可使用linux的部分命令 安装方式scoop 10. 设置别名 Set-Alias cl clear function ll &#123;busybox ls -l&#125; 11. 下载字体 推荐使用 Nerd Font 下载 https://www.nerdfonts.com/font-downloads 如: JetBrainsMono Nerd Font Mono 12. 主题 查看主题样式后在$Profile中更改主题名即可 https://ohmyposh.dev/docs/themes/","categories":[{"name":"WindowsTerminal","slug":"WindowsTerminal","permalink":"https://silencejql.github.io/categories/WindowsTerminal/"}],"tags":[]},{"title":"CSharp闭包","slug":"CSharp闭包","date":"2024-11-20T08:10:45.000Z","updated":"2025-03-24T11:45:22.523Z","comments":true,"path":"CSharp闭包.html","link":"","permalink":"https://silencejql.github.io/CSharp%E9%97%AD%E5%8C%85.html","excerpt":"闭包是指有权访问另一个函数作用域中的变量的函数","text":"闭包是指有权访问另一个函数作用域中的变量的函数 局部方法调用外部参数时会将传入的参数封装到一个类中 静态局部方法或静态匿名表达式不能访问外部参数, 因此不会形成闭包 示例 123456789101112131415161718int count = 0;//此处将count封装到一个类中传入var demo = new Demo(()=&gt;count++);//count = 0demo.Do();//count = 1class Demo()&#123; private readonly Action _callBack; public Demo(Action action) &#123; _callBack = action; &#125; public void Do() &#123; _callBack.Invoke(); &#125;&#125; 12345678910var cnt = CreateCounter();cnt.Invoke();//counter = 1cnt.Invoke();//counter = 2cnt.Invoke();//counter = 3cnt.Invoke();//counter = 4Action CreateCounter()&#123; int counter = 0; return ()=&gt;Console.Write(++counter);&#125; 问题分析 12345678910111213var actions = CreateActions();actions[0].Invoke(10);actions[1].Invoke(10);actions[2].Invoke(10);Action&lt;int&gt;[] CreateActions(int count = 3)&#123; var actions = new Action&lt;int&gt;[count]; for(int i = 0; i &lt; count; i++) &#123; action[i] = x =&gt; Console.WriteLine(x * i);//此处传入匿名函数时会在for循环外将i封装到一个类中, 导致最终的i为3, 具体可看编译后的IL &#125;&#125;//输出均为30 1234567891011121314var actions = CreateActions();actions[0].Invoke(10);actions[1].Invoke(10);actions[2].Invoke(10);Action&lt;int&gt;[] CreateActions(int count = 3)&#123; var actions = new Action&lt;int&gt;[count]; for(int i = 0; i &lt; count; i++) &#123; int j = i; action[i] = x =&gt; Console.WriteLine(x * j);//此处传入匿名函数时会在for循环内将j封装到一个类中 &#125;&#125;//输出均为0, 10, 20","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp冷知识-特性","slug":"CSharp冷知识-特性","date":"2024-11-20T06:37:26.000Z","updated":"2025-03-24T11:45:18.968Z","comments":true,"path":"CSharp冷知识-特性.html","link":"","permalink":"https://silencejql.github.io/CSharp%E5%86%B7%E7%9F%A5%E8%AF%86-%E7%89%B9%E6%80%A7.html","excerpt":"特性的一些特殊用法","text":"特性的一些特殊用法 Conditional 满足特定条件才会执行 1234567891011121314151617181920212223#define ABCusing System;public class Test()&#123; static void Main() &#123; var test = new Test() test.Func1(); test.Func2();//只有定义了ABC后才会执行 &#125; public void Func1() &#123; &#125; //只能用于void函数 [Conditional(&quot;ABC&quot;)] public void Func2() &#123; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"特性","slug":"特性","permalink":"https://silencejql.github.io/tags/%E7%89%B9%E6%80%A7/"}]},{"title":"CSharp冷知识-IEnumerator","slug":"CSharp冷知识-IEnumerator","date":"2024-11-20T04:02:13.000Z","updated":"2025-03-24T11:45:14.969Z","comments":true,"path":"CSharp冷知识-IEnumerator.html","link":"","permalink":"https://silencejql.github.io/CSharp%E5%86%B7%E7%9F%A5%E8%AF%86-IEnumerator.html","excerpt":"类实现 IEnumerator 接口可以实现foreach循环 只要提供IEnumerator GetEnumerator便可实现foreach循环","text":"类实现 IEnumerator 接口可以实现foreach循环 只要提供IEnumerator GetEnumerator便可实现foreach循环 IEnumerator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var mc = new MyClass(5);foreach(var item in mc)&#123;&#125;class MyClass : IEnumerator&#123; int length; public MyClass(int length) &#123; this.length = length; &#125; public IEnumerator GetEnumerator() &#123; for (int i = 0; i &lt; length; i++) &#123; yield return i.ToString(); &#125; &#125;&#125;//var mc = new MyClass(5);foreach(var item in mc)&#123;&#125;class MyClass&#123; int length; public MyClass(int length) &#123; this.length = length; &#125; public IEnumerator GetEnumerator() &#123; for (int i = 0; i &lt; length; i++) &#123; yield return i.ToString(); &#125; &#125;&#125;//foreach(var item in 5)&#123;&#125;public class MyExtensions&#123; public static IEnumerator GetEnumerator(this int count) &#123; for (int i = 0; i &lt; count; i++) &#123; yield return i.ToString(); &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp冷知识-await","slug":"CSharp冷知识-await","date":"2024-11-20T03:46:24.000Z","updated":"2025-03-24T11:45:08.485Z","comments":true,"path":"CSharp冷知识-await.html","link":"","permalink":"https://silencejql.github.io/CSharp%E5%86%B7%E7%9F%A5%E8%AF%86-await.html","excerpt":"await 可以作用于任何提供GetAwaiter方法的类","text":"await 可以作用于任何提供GetAwaiter方法的类 await 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//常用await FuncAsync();async Task FuncAsync()&#123; await Task.Delay(1000);&#125;//自定义var myDelay = new MyDelay(2);await myDelay;class MyDelay&#123; int second; public MyDelay(int second) &#123; this.second = second; &#125; public TaskAwaiter GetAwaiter() &#123; return Task.Delay(TimeSpan.FromSeconds(second)).GetAwaiter(); &#125;&#125;//进阶var myDelay = new MyDelay(2);await myDelay;class MyDelay&#123; public int second; public MyDelay(int second) &#123; this.second = second; &#125;&#125;static class MyExtensions()&#123; public static TaskAwaiter GetAwaiter(this MyDelay md) &#123; return Task.Delay(TimeSpan.FromSeconds(md.second)).GetAwaiter(); &#125;&#125;//进进阶await TimeSpan.FromSeconds(2);static class MyExtensions()&#123; public static TaskAwaiter GetAwaiter(this MyDelay md) &#123; return Task.Delay(TimeSpan.FromSeconds(md.second)).GetAwaiter(); &#125; public static TaskAwaiter GetAwaiter(this TimeSpan ts) =&gt;Task.Delay(ts).GetAwaiter();&#125;//进进进阶await 2;static class MyExtensions()&#123; public static TaskAwaiter GetAwaiter(this MyDelay md) &#123; return Task.Delay(TimeSpan.FromSeconds(md.second)).GetAwaiter(); &#125; public static TaskAwaiter GetAwaiter(this TimeSpan ts) =&gt;Task.Delay(ts).GetAwaiter(); public static TaskAwaiter GetAwaiter(this int second) =&gt;Task.Delay(TimeSpan.FromSeconds(second)).GetAwaiter();&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"常用Tcp程序","slug":"常用Tcp程序","date":"2024-11-04T02:20:20.000Z","updated":"2024-11-04T02:20:20.417Z","comments":true,"path":"常用Tcp程序.html","link":"","permalink":"https://silencejql.github.io/%E5%B8%B8%E7%94%A8Tcp%E7%A8%8B%E5%BA%8F.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"合并不同仓库的历史提交","slug":"合并不同仓库的历史提交","date":"2024-09-10T05:38:26.000Z","updated":"2025-03-25T03:28:25.060Z","comments":true,"path":"合并不同仓库的历史提交.html","link":"","permalink":"https://silencejql.github.io/%E5%90%88%E5%B9%B6%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93%E7%9A%84%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4.html","excerpt":"目的: 如两个开发人员分别在本地创建了自己的仓库进行同一项目的开发工作, 后需合并的同时需要保留所有历史提交或其中某个重要的历史提交","text":"目的: 如两个开发人员分别在本地创建了自己的仓库进行同一项目的开发工作, 后需合并的同时需要保留所有历史提交或其中某个重要的历史提交 合并部分提交 1234567891011121314151617181920# 如将repo1合并到repo中# 在repo中添加repo1为远程分支git remote add rrepo1 //repo1的路径# 拉取repo1的变更记录git fetch rrepo1 # 自动创建rrepo1/master的分支# 查看rrepo1/master的历史提交git log rrepo1/master# 合并某一次提交git cherry-pick &lt;commit-hash&gt;# 合并连续的几次提交git cherry-pick A..B # 合并从A~B的提交(不含A)git cherry-pick A^..B # 合并从A~B的提交(含A)# 查看提交记录git log 合并所有提交 12345678910111213# 如将repo1合并到repo中# 在repo中添加repo1为远程分支git remote add rrepo1 //repo1的路径# 拉取repo1的变更记录git fetch rrepo1 # 自动创建rrepo1/master的分支# 合并到repogit merge rrepo1/master# 查看提交记录git log","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"聚类算法","slug":"聚类算法","date":"2024-06-29T06:28:35.000Z","updated":"2025-03-25T03:28:05.279Z","comments":true,"path":"聚类算法.html","link":"","permalink":"https://silencejql.github.io/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95.html","excerpt":"聚类: 将相似或满足条件的样本归类到同一类别中","text":"聚类: 将相似或满足条件的样本归类到同一类别中 DBSCAN DBSCAN(Density-Based Spatial Clustering of Applications with Noise)基于密度的聚类算法 聚类方式 以任一点开始, 判断当前点ep范围内点数是否大于minPts, 若大于则为核心点, 否则为噪点 然后以邻域内任一点重复步骤1, 将样本归类为不同簇 算法参数 ep: 邻域半径 minPts: 最少点数 点类别 核心点是指那些在邻域内具有足够多的点的对象(&gt;minPts) 边界点则是那些邻近核心点但自身不是核心点的点 噪声点则既不是核心点也不是边界点 K-MEANS","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"HUD单双目测距说明","slug":"HUD单双目测距说明","date":"2024-06-01T01:24:25.000Z","updated":"2025-03-24T11:44:49.796Z","comments":true,"path":"HUD单双目测距说明.html","link":"","permalink":"https://silencejql.github.io/HUD%E5%8D%95%E5%8F%8C%E7%9B%AE%E6%B5%8B%E8%B7%9D%E8%AF%B4%E6%98%8E.html","excerpt":"","text":"","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"AlgorithmLearning-D&C","slug":"AlgorithmLearning-D-C","date":"2024-05-28T07:37:16.000Z","updated":"2025-03-24T11:43:50.239Z","comments":true,"path":"AlgorithmLearning-D-C.html","link":"","permalink":"https://silencejql.github.io/AlgorithmLearning-D-C.html","excerpt":"Divide and Conquer分治","text":"Divide and Conquer分治 快速排序 1234567891011121314151617181920212223242526static void QuickSort(int[] data, int left, int right)&#123; if(left &gt; right) return; int i = left; int j = right; int mark = data[left]; while (i != j) &#123; while (data[j] &gt;= mark &amp;&amp; i &lt; j) j--; while (data[i] &lt;= mark &amp;&amp; i &lt; j) i++; if (i &lt; j) &#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; &#125; &#125; data[left] = data[i]; data[i] = mark; QuickSort(data, left, i - 1); QuickSort(data, i + 1, right);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"AlgorithmLearning-二分查找","slug":"AlgorithmLearning-二分查找","date":"2024-05-28T07:18:50.000Z","updated":"2025-03-25T03:30:13.117Z","comments":true,"path":"AlgorithmLearning-二分查找.html","link":"","permalink":"https://silencejql.github.io/AlgorithmLearning-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html","excerpt":"二分查找法","text":"二分查找法 示例 1234567891011121314151617181920//返回一组数中某个数的索引int BinarySearch(List&lt;int&gt; list, int target)&#123; int low = 0; int high = list.Count - 1; while (low &lt;= high) &#123; int mid = (low + high) / 2; int tmp = list[mid]; if(tmp == target) return mid; if(tmp &gt; target) high = mid - 1; else low = mid + 1; &#125; return -1;&#125;int pos = BinarySearch(new List&lt;int&gt;&#123;1, 3, 5, 7, 9&#125;, 3);//1","categories":[{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"CSharp","slug":"算法/CSharp","permalink":"https://silencejql.github.io/categories/%E7%AE%97%E6%B3%95/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"AlgorithmLearning-DFS","slug":"AlgorithmLearning-DFS","date":"2024-05-27T07:30:37.000Z","updated":"2025-03-24T11:44:02.996Z","comments":true,"path":"AlgorithmLearning-DFS.html","link":"","permalink":"https://silencejql.github.io/AlgorithmLearning-DFS.html","excerpt":"深度优先","text":"深度优先 深度优先 示例 XXX + XXX = XXX 将数字1~9分别填入X中,每个数字只能使用一次使得等式成立, 如173+286=459为一组结果, 求总共有多少组. 注:173+286=459与286+173=459为一组. 分析 每个X均有9中可能的数字, 第一个X 123456int[] result = new int[10];//保存结果int x = 1;//第几个Xfor(int i = 1; i &lt; 10; i++)&#123; result[x] = i;&#125; 要保证每个数字只能出现一次, 增加标记 12345678910int[] result = new int[10];//保存结果bool[] marked = new bool[10];int x = 1;//第几个Xfor(int i = 1; i &lt; 10; i++)&#123; if(marked[i]) continue; result[x] = i; marked[i] = true;&#125; 第二个X与第一个X相同, 将上述封装 123456789101112void dfs(int x)&#123; for(int i = 1; i &lt; 10; i++) &#123; if(marked[i]) continue; result[x] = i; marked[i] = true; dfs(x + 1); marked[i] = false;//当每次执行到最后一步后,再返回到前一步填入下一个数 &#125;&#125; 加入返回条件, 计算组数 1234567891011121314151617181920212223int steps = 0;void dfs(int x)&#123; if(x == 10)//总共9个X &#123; if((result[1] * 100 + result[2] * 10 + result[3]) + (result[4] * 100 + result[5] * 10 + result[6]) == (result[7] * 100 + result[8] * 10 + result[9])) &#123; step++; return; &#125; &#125; for(int i = 1; i &lt; 10; i++) &#123; if(marked[i]) continue; result[x] = i; marked[i] = true; dfs(x + 1); marked[i] = false;//当每次执行到最后一步后,再返回到前一步填入下一个数 &#125;&#125; 代码实现 123456789101112131415161718192021222324252627282930int[] result = new int[10];//保存结果bool[] marked = new bool[10];int steps = 0;void dfs(int x)&#123; if(x == 10)//总共9个X &#123; //满足条件计数 if((result[1] * 100 + result[2] * 10 + result[3]) + (result[4] * 100 + result[5] * 10 + result[6]) == (result[7] * 100 + result[8] * 10 + result[9])) &#123; step++; return; &#125; &#125; for(int i = 1; i &lt; 10; i++) &#123; if(marked[i]) continue; result[x] = i; marked[i] = true; dfs(x + 1); marked[i] = false;//当每次执行到最后一步后,再返回到前一步填入下一个数 &#125;&#125;//Clientdfs(1);steps /= 2;","categories":[{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C# Open Protocol","slug":"C-Open-Protocol","date":"2024-05-22T04:52:36.000Z","updated":"2025-03-24T11:44:13.984Z","comments":true,"path":"C-Open-Protocol.html","link":"","permalink":"https://silencejql.github.io/C-Open-Protocol.html","excerpt":"基于Open Protocol的扳手程序设计 基于TcpIP, 扳手为Server端口一般为4545","text":"基于Open Protocol的扳手程序设计 基于TcpIP, 扳手为Server端口一般为4545 数据组成 通讯数据内容均为ASCII格式 数据包含三部分: Header, DataField和MessageEnd Header Byte parameter Value 1-4 Length Header+DataField的长度 5-8 MID MessageID 9-11 Revision The revision of the MID 12 No ack lag 13-14 Station ID 15-16 Spindle ID 17-20 Spare DataField Byte parameter Value 21-22 01 Parameter ID 23-n Parameter 01 value Parameter 01的内容 n+1-n+2 02 Parameter ID n+3 Parameter 02 value Parameter 02的内容 MessageEnd 以空字符NUL结尾, '\\0’或0x00 程序部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public class Header&#123; public int Length &#123; get; set; &#125; public int Mid &#123; get; set; &#125; public int Revision &#123; get; set; &#125; public bool NoAckFlag &#123; get; set; &#125; public int? StationId &#123; get; set; &#125; public int? SpindleId &#123; get; set; &#125; public const int DefaultSize = 20; public Header() &#123; Length = DefaultSize; &#125; public override string ToString() &#123; var sb = new StringBuilder(Length.ToString(&quot;D4&quot;)); //var sb = new StringBuilder(); sb.Append(Mid.ToString(&quot;D4&quot;)); sb.Append(Revision.ToString(&quot;D3&quot;)); sb.Append(NoAckFlag ? &quot;1&quot; : &quot;0&quot;); sb.Append(&quot; &quot;); return sb.ToString(); &#125;&#125;public class Mid&#123; public Header Header &#123; get; set; &#125; public string? DataFieldsString &#123; get; set; &#125; public bool PositiveResponse &#123; get =&gt; Header.Mid == 5; &#125; public Mid() &#123; Header = new Header(); &#125; public Mid(Header header) &#123; Header = header; &#125; public Mid(int mid, int revision, bool noAckFlag = false) : this(new Header() &#123; Mid = mid, Revision = revision, NoAckFlag = noAckFlag &#125;) &#123; &#125; public virtual Mid AppendDataFields(string dataFields) &#123; DataFieldsString = dataFields; return this; &#125; public virtual string Pack() &#123; if (DataFieldsString != null) Header.Length += DataFieldsString.Length; var builder = new StringBuilder(Header.ToString()); builder.Append(DataFieldsString); builder.Append(&#x27;\\0&#x27;); return builder.ToString(); &#125; //解析Header protected virtual Header ProcessHeader(string package) &#123; if (package.Length &lt; 20) &#123; package = package.PadRight(20, &#x27; &#x27;); &#125; var header = new Header &#123; Length = int.Parse(package.Substring(0, 4)), Mid = int.Parse(package.Substring(4, 4)), Revision = int.TryParse(package.Substring(8, 3), out var revision) ? revision : 1, NoAckFlag = !string.IsNullOrWhiteSpace(package.Substring(11, 1)), StationId = int.TryParse(package.Substring(12, 2), out var stationId) ? stationId : 1, SpindleId = int.TryParse(package.Substring(14, 2), out var spindleId) ? spindleId : 1, &#125;; return header; &#125; //截取返回数据段 protected string SubDataFieldsString(string package) &#123; return package.Substring(20, Header.Length - 20); &#125; //根据给定数据字段解析, 要求加入所有字段或者ID从1开始连续的字段 public virtual void ProcessDataFields(List&lt;DataField&gt; dataFields) &#123; if (DataFieldsString == null) throw new Exception(&quot;数据段为空&quot;); dataFields = dataFields.OrderBy(df =&gt; df.id).ToList(); int startIndex = 0; int idCount = 1; dataFields.ForEach(df =&gt; &#123; if (idCount++ == Convert.ToInt32(DataFieldsString.Substring(startIndex, 2))) &#123; //throw new Exception(&quot;数据解析ID与实际不匹配&quot;); if (startIndex &gt; DataFieldsString.Length) throw new Exception(&quot;接收到的数据长度不正确: 长度应大于&quot; + startIndex + &quot;;实际长度=&quot; + DataFieldsString.Length); df.data = DataFieldsString.Substring(startIndex + 2, df.length).Trim().Trim(&#x27;\\0&#x27;); startIndex += df.length + 2; &#125; else df.data = &quot;List Order Error&quot;; &#125;); &#125; //根据字段的索引值取值, 数据段起始为0 public virtual void ProcessDataFieldsWithIndex(List&lt;DataField&gt; dataFields, int dataIndexOffset = 0) &#123; if (DataFieldsString == null) throw new Exception(&quot;数据段为空&quot;); dataFields.ForEach(df =&gt; &#123; df.index -= dataIndexOffset; if (df.id == Convert.ToInt32(DataFieldsString.Substring(df.index, 2))) &#123; if (df.index + df.length &gt; DataFieldsString.Length) throw new Exception(&quot;数据长度不正确&quot;); df.data = DataFieldsString.Substring(df.index + 2, df.length).Trim().Trim(&#x27;\\0&#x27;); &#125; else df.data = &quot;Index Error&quot;; &#125;); &#125; //解析出Header和DateField public virtual Mid Parse(string package) &#123; Header = ProcessHeader(package); DataFieldsString = SubDataFieldsString(package); return this; &#125; public virtual Mid Parse(byte[] package) &#123; var pack = ToAscii(package); return Parse(pack); &#125; protected static string ToAscii(byte[] bytes) =&gt; Encoding.ASCII.GetString(bytes); protected static byte[] ToBytes(string value) =&gt; Encoding.ASCII.GetBytes(value); public class DataField &#123; public int id; public int length; public string data; public int index;//数据段起始为0(不计算Header长度) public DataField(List&lt;DataField&gt; dfList, int id, int length) &#123; this.id = id; this.length = length; this.data = &quot;&quot;; this.index = -1; // if(dfList.Find(df =&gt; df.id == id) == null) dfList.Add(this); &#125; public DataField(List&lt;DataField&gt; dfList, int id, int length, int index) : this(dfList, id, length) &#123; this.index = index; &#125; &#125;&#125; Client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258public class OpenProtocolClient : xStringEx&#123; private static readonly object locker = new object(); private xString Connected = new(); private static TcpClient tcpClient = new(); public Mid recvMid; public Mid lastRecvMid; private bool EnableLog = false; private string LogFile = &quot;DesoutterOpenProtocol&quot;; private string remoteIP = string.Empty; private int remotePort = 502; private int recvTimeout = 100; bool online = false; public OpenProtocolClient() &#123; Connected = TCreate&lt;xString&gt;(new xString(), &quot;Connected&quot;); &#125; public xState Init(string sPara) &#123; try &#123; online = false; Dictionary&lt;string, object&gt; PortCif = new Dictionary&lt;string, object&gt; &#123; &#123; &quot;IPAddr&quot;, &quot;127.0.0.1&quot; &#125;, &#123; &quot;PortNo&quot;, 502 &#125;, &#123; &quot;RecvTimeout&quot;, 1000 &#125;, &#123; &quot;EnableLog&quot;, true &#125;, &#123; &quot;LogFileName&quot;, &quot;TCPClientOpra&quot; &#125; &#125;; XmlFO.Configs.Get(&quot;TCPClient&quot;, sPara, PortCif); remoteIP = Convert.ToString(PortCif[&quot;IPAddr&quot;]); remotePort = Convert.ToInt32(PortCif[&quot;PortNo&quot;]); recvTimeout = Convert.ToInt32(PortCif[&quot;RecvTimeout&quot;]); EnableLog = Convert.ToBoolean(PortCif[&quot;EnableLog&quot;]); LogFile = Convert.ToString(PortCif[&quot;LogFileName&quot;]); ThreadEx.New(TcpRecvThread, &quot;TcpRecvThread&quot;, 50); ThreadEx.New(Online, &quot;Online&quot;, 1000); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125; &#125; public xState StartCommunication(string sParam) &#123; try &#123; online = true; int i = 0; Mid mid; do &#123; mid = SendAndRecv(new Mid(1, 1)); if (mid == null) break; &#125; while (mid.Header.Mid != 2 &amp;&amp; ++i &lt; 5); if (lastRecvMid != null &amp;&amp; recvMid.Header.Mid == 2) &#123; Connected.xValue = &quot;True&quot;; return xState.xTrue; &#125; else &#123; Connected.xValue = &quot;False&quot;; return xState.xFalse; &#125; &#125; catch (Exception e) &#123; Connected.xValue = &quot;False&quot;; xErrorOutException(e); return xState.xFalse; &#125; &#125; public xState StopCommunication(string sParam) &#123; try &#123; online = false; Mid mid = SendAndRecv(new Mid(3,1)); Connected.xValue = &quot;False&quot;; return mid.PositiveResponse ? xState.xTrue : xState.xFalse; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125; &#125; public xState PostVehicleCode(string sParam) &#123; try &#123; string code = XmlFO.StringAnalysis(sParam); if (code.Length &lt; 19) return xState.xFalse; StartCommunication(&quot;&quot;); Mid mid = SendAndRecv(new Mid(50, 1).AppendDataFields(code)); return mid.PositiveResponse ? xState.xTrue : xState.xFalse; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125; &#125; public xState SubscribeLastResult(string sParam) &#123; try &#123; Mid mid = SendAndRecv(new Mid(60, 4)); return mid.PositiveResponse ? xState.xTrue : xState.xFalse; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125; &#125; public xState RecvLastResult(string sParam) &#123; try &#123; if (lastRecvMid.Header.Mid != 61) return xState.xFalse; if (lastRecvMid.DataFieldsString == null) return xState.xFalse; Mid61DataResult mid61Result = new Mid61DataResult(); lastRecvMid.ProcessDataFields(Mid61DataResult.dfList); double torque = Convert.ToInt32(mid61Result.torque.data) / 100; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125; &#125; //Online void Online() &#123; if (!online) return; Mid mid = SendAndRecv(new Mid(9999, 0)); &#125; private void TcpRecvThread() &#123; byte[] tcpRecvByts; //while (true) &#123; if (!IsOnline()) &#123; Connect(); return; &#125; tcpRecvByts = new byte[2048]; int recvLength = 20; try &#123; recvLength = tcpClient.Client.Receive(tcpRecvByts); &#125; catch (Exception e) &#123; recvMid = null; return; &#125; byte[] tmpRecvData = new byte[recvLength]; Array.Copy(tcpRecvByts, tmpRecvData, recvLength); string tcpRecvString = Encoding.ASCII.GetString(tmpRecvData); Logout(&quot;Recv:&lt;-&quot; + tcpRecvString); recvMid = new Mid().Parse(tcpRecvString); lastRecvMid = recvMid; &#125; &#125; public Mid SendAndRecv(Mid sendMid) &#123; SendMsg(sendMid.Pack()); int t = Environment.TickCount; while ((Environment.TickCount - t) &lt; recvTimeout) &#123; Thread.Sleep(10); if(recvMid != null) return recvMid; &#125; Logout(&quot;Recv Timeout&quot;); throw new Exception(&quot;Recv Timeout&quot;); &#125; public void SendMsg(string data) &#123; if (!IsOnline()) Connect(); lock (locker) &#123; tcpClient.Client.Send(Encoding.ASCII.GetBytes(data)); recvMid = null;//考虑发出去后置空, recv中好判断 Logout(&quot;Send:-&gt;&quot; + data); &#125; &#125; private void Connect() &#123; if (tcpClient == null) tcpClient = new TcpClient(); if (tcpClient.Connected) return; tcpClient.Close(); tcpClient = new TcpClient(); tcpClient.Connect(IPAddress.Parse(remoteIP), remotePort); tcpClient.Client.ReceiveTimeout = recvTimeout; &#125; public bool IsOnline() &#123; if (tcpClient == null) return false; bool onLine = !((tcpClient.Client.Poll(100, SelectMode.SelectRead) &amp;&amp; (tcpClient.Client.Available == 0)) || !tcpClient.Client.Connected); if (!onLine) tcpClient = null; return onLine; &#125; private void Logout(string msg) &#123; string path = Environment.CurrentDirectory + &quot;\\\\Log&quot;; string fullPath = path + &quot;\\\\log&quot; + DateTime.Now.ToString(&quot;yyyyMMdd&quot;) + &quot;.log&quot;; if (!File.Exists(path)) System.IO.Directory.CreateDirectory(path); if (EnableLog) &#123; using (StreamWriter sw = new StreamWriter(fullPath, true)) &#123; sw.WriteLine(DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss:ffff &quot;) + msg); &#125; &#125; &#125; //Just for test public class Mid61DataResult &#123; public static List&lt;Mid.DataField&gt; dfList = new List&lt;Mid.DataField&gt;(); public DataField sensorID = new DataField(dfList, 1, 4, 0); public DataField channelID = new DataField(dfList, 2, 2, 6); public DataField controlerName = new DataField(dfList, 3, 25, 10); public DataField torque = new DataField(dfList, 4, 40,37); public double TorqueResult &#123; get =&gt; Convert.ToDouble(torque.data) ; &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"C#高精度定时器","slug":"C-高精度定时器","date":"2024-05-22T01:23:22.000Z","updated":"2025-03-24T11:44:25.194Z","comments":true,"path":"C-高精度定时器.html","link":"","permalink":"https://silencejql.github.io/C-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%AE%9A%E6%97%B6%E5%99%A8.html","excerpt":"结论: 推荐调用timeBeginPeriod后使用Sleep(1)精度在2ms以内","text":"结论: 推荐调用timeBeginPeriod后使用Sleep(1)精度在2ms以内 DateTime.Now 该属性发解析取决于系统计时器, 后者取决于基础操作系统, 精度一般介于0.5~15ms之间 该属性通常用于度量性能, 由于分辨路较低不适合用于测试工具, 推荐使用Stopwatch类 Stopwatch Stopwatch内部使用系统API QueryPerformanceCounter / QueryPerformanceFrequency来进行高精度计时, 精度依赖于硬件通常高达几十纳秒(ns) 测试一 1234567891011121314Stopwatch sw = new Stopwatch();sw.Start();Thread.Sleep(1);sw.Stop();TimeSpan timeSpan = sw.Elapsed;double ms = timeSpan.TotalMilliseconds;//实际定时时间大约15.6ms/*该测试取决于系统时钟, Windows默认时钟频率为每秒64次即15.625ms小于16ms的Sleep不会生效可以调用timeBeginPeriod更改时钟频率*/ 测试二 123456789101112[DllImport(&quot;winmm.dll&quot;, EntryPoint = &quot;timeBeginPeriod&quot;)]public static extern uint BeginPeriod(uint ms);BeginPeriod(1);Stopwatch sw = new Stopwatch();sw.Start();Thread.Sleep(1);sw.Stop();TimeSpan timeSpan = sw.Elapsed;double ms = timeSpan.TotalMilliseconds;//实际定时时间大约1.8ms 测试三 12345678910111213141516171819202122232425[DllImport(&quot;kernel32.dll&quot;)]public static extern short QueryPerformanceCounter(ref long x);[DllImport(&quot;kernel32.dll&quot;)]public static extern short QueryPerformanceFrequency(ref long x);public void delay(long delayTime)&#123; long stopValue = 0, startValue = 0, freq = 0, n = 0; QueryPerformanceFrequency(ref freq); long count = delayTime * freq / 1000000;//1000us = 1ms QueryPerformanceCounter(ref startValue); while(n &lt; count) &#123; QueryPerformanceCounter(ref stopValue); n = stopValue - startValue; &#125;&#125;Stopwatch sw = new Stopwatch();sw.Start();delay(1000);sw.Stop();TimeSpan timeSpan = sw.Elapsed;double ms = timeSpan.TotalMilliseconds;//实际定时时间大约1.3ms","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"C#范围运算符","slug":"C-范围运算符","date":"2024-05-21T02:27:25.000Z","updated":"2025-03-24T11:44:29.747Z","comments":true,"path":"C-范围运算符.html","link":"","permalink":"https://silencejql.github.io/C-%E8%8C%83%E5%9B%B4%E8%BF%90%E7%AE%97%E7%AC%A6.html","excerpt":"用于快速截取序列, C#8.0","text":"用于快速截取序列, C#8.0 主要用于操作数组, 字符串和Span类型数据序列 start…end, 表示从start索引(包含start)处开始, 截取到end索引(不包含end)处 start…, 表示从start索引(包含start)处开始, 截取到序列结尾 范围运算符也可也用负数表示倒数截取 ^为末尾运算符 arr[^1]等于arr[arr.Length - 1]为最后一个元素 arr[^0]等于arr[arr.Length]","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"C#集合表达式","slug":"C-集合表达式","date":"2024-05-21T02:16:56.000Z","updated":"2025-03-24T11:44:32.399Z","comments":true,"path":"C-集合表达式.html","link":"","permalink":"https://silencejql.github.io/C-%E9%9B%86%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","excerpt":"集合表达式是一种简洁的语法, 可用于创建常见的集合值, 在[]之间包含元素的序列. C# 12","text":"集合表达式是一种简洁的语法, 可用于创建常见的集合值, 在[]之间包含元素的序列. C# 12 12List&lt;String&gt; list = [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;]; 分布元素 使用..在集合表达式中使用内联集合值 123string[] num1 = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;];string[] num2 = [&quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;];string[] num = [.. num1, .. num2, &quot;0&quot;];","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"ToString","slug":"ToString","date":"2024-04-24T08:23:45.000Z","updated":"2024-05-18T05:22:28.304Z","comments":true,"path":"ToString.html","link":"","permalink":"https://silencejql.github.io/ToString.html","excerpt":"C# ToString数字格式","text":"C# ToString数字格式 .ToString 常用格式 格式符 说明 示例 输出 D 十进制数 10.ToString(“D1”) 10 D 十进制数 10.ToString(“D2”) 10 D 十进制数 10.ToString(“D3”) 010 D 十进制数 10.ToString(“D5”) 00010 F 浮点数 10.ToString(“F1”) 10.0 F 浮点数 10.ToString(“F2”) 10.00 X 十六进制数 10.ToString(“X”) A X 十六进制数 10.ToString(“X1”) 0A X 十六进制数 10.ToString(“X2”) 00A","categories":[],"tags":[]},{"title":"Web入门","slug":"Web入门","date":"2024-04-23T08:59:39.000Z","updated":"2025-03-24T11:43:32.659Z","comments":true,"path":"Web入门.html","link":"","permalink":"https://silencejql.github.io/Web%E5%85%A5%E9%97%A8.html","excerpt":"Web入门笔记","text":"Web入门笔记 HTML HTML: Hyper Text Markup Language-超文本标记语言 HTML元素 1&lt;p class=&quot;editor-note&quot;&gt;Hello HTML&lt;/p&gt; 元素由 开始标签, 内容, 结束标签 组成 元素可以有属性, 属性包含了元素的额外信息且不显示在内容中. 常见元素 图像 &lt;img src=&quot;images/img.png&quot; alt=&quot;Image&quot; /&gt; 段落 &lt;p&gt;这是一个段落&lt;/p&gt; 列表 列表分为有序列表(Ordered List)&lt;ol&gt; 无序列表(Unordered List)&lt;ul&gt; 列表中项目(List Item)&lt;li&gt; 链接 链接用&lt;a&gt;(Anchor)表示 &lt;a href=&quot;https://www.xxx.com&quot;&gt;xxx官网&lt;/a&gt; CSS CSS: Cascading Style Sheets-层叠样式表 CSS用于给HTML元素添加样式 在HTML中用link元素引入 &lt;link href=&quot;styles/style.css&quot; rel=&quot;stylesheet&quot; /&gt; 规则集 123456li,h1,p&#123; color: red; width: 500px;&#125; 选择器(Selector) HTML元素的名称位于规则集的开始 声明(Declaration) 一个单独的规则, 如color: red 属性(Properties) 改变样式的方法, 如color 属性值(Properties Value) 指定声明中属性的值 div CSS布局主要是基于Div padding 内边距: div盒子中内容到border的空间 border 边框: div盒子中有效区域边框线条 margin 外边距: div盒子中border到最外围的空间 JavaScript 为网站添加交互功能 在HTML中用script引入 &lt;script src=&quot;scripts/main.js&quot; defer&gt;&lt;/script&gt; 12let myHeading = document.querySelector(&quot;h1&quot;);myHeading.textContent = &quot;Hello world!&quot;;","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://silencejql.github.io/tags/Web/"}]},{"title":"UDS DTC格式解析","slug":"UDS-DTC格式解析","date":"2024-04-22T08:23:50.000Z","updated":"2024-04-23T06:29:54.107Z","comments":true,"path":"UDS-DTC格式解析.html","link":"","permalink":"https://silencejql.github.io/UDS-DTC%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90.html","excerpt":"UDS DTC故障码解析说明","text":"UDS DTC故障码解析说明 格式结构 ISO 14229-1的故障诊断码格式规定, 故障码信息由四个字节组成: DTCHightByte,DTCMiddleByte,DTCLowByte,StatusofDTC DTCHightByte,DTCMiddleByte两个字节表示故障内码, StatusofDTC表示故障码状态 DTCHightByte> DTCMiddleByte> Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0 Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0 第一位 第二位 第三位 第四五位 故障内码 故障内码由DTCHightByte,DTCMiddleByte两个字节解析出的5位字符组成 第一位 由DTCHightByte高两位(Bit8Bit7)解析而来 Bit7Bit6 标准故障码字符 所属系统 00 P Powertrain动力系统故障 01 C Chassis底盘故障 10 B Body车身故障 11 U Network and vehicle integration网络和车辆集成 第二位 第二位数字为0,1,2或3表示故障类型,由DTCHightByte的Bit6Bit5解析而来 Bit5Bit4 标准故障码字符 故障类型 00 0 ISO/SAE标准定义的故障码 01 1 制造商自定义故障码 10 2 ISO/SAE标准定义的故障码 11 3 ISO/SAE保留 第三位 第三位字符表示故障所属子系统,由DTCHightByte的低四位解析而来 第四五位 最后两位表示具体故障对象和类型(hex) DTCLowByte DTCLowByte描述故障种类和子类型(hex), 遵循ISO15031-6, 不需要该字节的DTC填充为0x00 StatusofDTC 故障码状态位: Bit 描述 英文描述 0 当前故障 testFailed 1 当前测试循环故障 testFailedThisOperationCycle 2 待确定DTC pendingDTC 3 确认的DTC(历史故障) confirmedDTC 4 故障清除后测试没有完成 testNotCompletedSinceLastClear 5 故障清除后测试失败 testFailedSinceLastClear 6 当前操作循环没有完成 testNotCompletedThisOperationCycle 7 故障指示请求 warningIndicatorRequested","categories":[],"tags":[]},{"title":"小米DSA状态字节定义","slug":"小米DSA状态字节定义","date":"2024-04-17T01:23:25.000Z","updated":"2025-03-07T12:17:07.599Z","comments":true,"path":"小米DSA状态字节定义.html","link":"","permalink":"https://silencejql.github.io/%E5%B0%8F%E7%B1%B3DSA%E7%8A%B6%E6%80%81%E5%AD%97%E8%8A%82%E5%AE%9A%E4%B9%89.html","excerpt":"小米DSA通讯部分说明","text":"小米DSA通讯部分说明 四轮 车型信息 ServiceID StartByte Length UserDefine 04 23 17 VIN 04 12 3 ZTS 设备状态 Byte bit UserDefine 5 1 PLCFault(Communication_NCA_IN_System_Fault)或非自动模式(Communication_NCA_IN_System_AutoMode)或放弃测试按钮(Communication_NCA_IN_CycleAbort) 7 0 四轮对中完成(Communication_NCA_IN_Centered) 7 1 四轮测试完成标志位(System_BEP_NewData) 7 2 轮眉测试完成标志位 7 3 空悬标定完成滚筒启动后置位 7 4 近光测试完成(Communication_NCA_IN_HLA*LowDone) 7 5 远光测试完成(Communication_NCA_IN_HLA*HighDone) 7 6 ADB测试完成(Communication_NCA_IN_HLA*ADBDone) 7 7 四轮调整完成按钮信号(Communication_NCA_IN_CycleComplete) ADAS 接收DSA信息 ServiceID StartByte Length UserDefine 04 8 17 VIN 04 25 1 ZTS 0A 8 2 CarParam_ACC_TargetX 0A 10 2 CarParam_ACC_TargetY 0A 12 2 CarParam_ACC_TargetZ 0D 8 2 CarParam_HUD_TargetX 0D 10 2 CarParam_HUD_TargetY 0D 12 2 CarParam_HUD_TargetZ 0D 14 2 CarParam_HUD_TargetRX 0D 16 2 CarParam_HUD_TargetRY 0D 18 2 CarParam_HUD_TargetRZ 设备状态 Byte bit UserDefine 5 0 Communication_FAS_IN_System_EStop 5 1 Communication_FAS_IN_System_Fault 5 4 Communication_FAS_IN_System_AutoMode 5 5 !Communication_FAS_IN_System_AutoMode 5 7 上述信号正常 部分代码 四轮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493public override void IDT_SERVICE_02_STOP()&#123; ExecuteProAndCheckReturn(&quot;MainThread_Monitor_CancelTest&quot;);&#125;private void IDT_SERVICE_03_DeviceInit()//设备回初始状态&#123; ExecuteProAndCheckReturn(&quot;MainThread_Monitor_CancelTest&quot;);&#125;private void IDT_SERVICE_04_VehicleInformation()&#123; string sZTS = RecvData[12].ToString() + RecvData[13].ToString() + RecvData[14].ToString(); //GetString(12, 3); Pt[&quot;CarParam_VIN&quot;] = GetString(23, 17); Pt[&quot;CarParam_ZTS&quot;] = sZTS; //CkProj(&quot;MainThread_Vehicle_SendToNCA&quot;);//IDT_SERVICE4 ExecutePlatTeam(&quot;MainThread_Vehicle_SendToNCA&quot;);&#125;private void IDT_SERVICE_05_TOE_F_Pre_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Toe_LFPreset&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Toe_LFPreset_Result&quot;].Value);//确认是否有调整前判定 SetValue(15, XmlFO.PubObjects[&quot;@NCA.Toe_LFPresetMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Toe_LFPresetMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Toe_RFPreset&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Toe_RFPreset_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Toe_RFPresetMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Toe_RFPresetMin&quot;].Value, 600); //SetValue(26, XmlFO.PubObjects[&quot;@NCA.Toe_FTotalPreset&quot;].Value); //SetResult(28, XmlFO.PubObjects[&quot;@NCA.Toe_FTotalPreset_Result&quot;].Value); //SetValue(29, XmlFO.PubObjects[&quot;@NCA.Toe_FTotalPresetMax&quot;].Value); //SetValue(31, XmlFO.PubObjects[&quot;@NCA.Toe_FTotalPresetMin&quot;].Value);&#125;private void IDT_SERVICE_06_TOE_R_Pre_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Toe_LRPreset&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Toe_LRPreset_Result&quot;].Value);//确认是否有调整前判定 SetValue(15, XmlFO.PubObjects[&quot;@NCA.Toe_LRPresetMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Toe_LRPresetMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Toe_RRPreset&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Toe_RRPreset_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Toe_RRPresetMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Toe_RRPresetMin&quot;].Value, 600); //SetValue(26, XmlFO.PubObjects[&quot;@NCA.Toe_RTotalPreset&quot;].Value); //SetResult(28, XmlFO.PubObjects[&quot;@NCA.Toe_RTotalPreset_Result&quot;].Value); //SetValue(29, XmlFO.PubObjects[&quot;@NCA.Toe_RTotalPresetMax&quot;].Value); //SetValue(31, XmlFO.PubObjects[&quot;@NCA.Toe_RTotalPresetMin&quot;].Value);&#125;private void IDT_SERVICE_07_TOE_F_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Toe_LF&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Toe_LF_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Toe_LFMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Toe_LFMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Toe_RF&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Toe_RF_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Toe_RFMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Toe_RFMin&quot;].Value, 600); SetValue(26, XmlFO.PubObjects[&quot;@NCA.Toe_FTotal&quot;].Value, 600); SetResult(28, XmlFO.PubObjects[&quot;@NCA.Toe_FTotal_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@NCA.Toe_FTotalMax&quot;].Value, 600); SetValue(31, XmlFO.PubObjects[&quot;@NCA.Toe_FTotalMin&quot;].Value, 600);&#125;private void IDT_SERVICE_08_TOE_R_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Toe_LR&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Toe_LR_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Toe_LRMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Toe_LRMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Toe_RR&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Toe_RR_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Toe_RRMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Toe_RRMin&quot;].Value, 600); SetValue(26, XmlFO.PubObjects[&quot;@NCA.Toe_RTotal&quot;].Value, 600); SetResult(28, XmlFO.PubObjects[&quot;@NCA.Toe_RTotal_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@NCA.Toe_RTotalMax&quot;].Value, 600); SetValue(31, XmlFO.PubObjects[&quot;@NCA.Toe_RTotalMin&quot;].Value, 600);&#125;private void IDT_SERVICE_09_CAMBER_F_Pre_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Camber_LFPreset&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Camber_LFPreset_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Camber_LFPresetMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Camber_LFPresetMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Camber_RFPreset&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Camber_RFPreset_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Camber_RFPresetMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Camber_RFPresetMin&quot;].Value, 600); //SetValue(26, XmlFO.PubObjects[&quot;@NCA.Camber_FCrossPreset&quot;].Value); //SetResult(28, XmlFO.PubObjects[&quot;@NCA.Camber_FCross_Result&quot;].Value); //SetValue(29, XmlFO.PubObjects[&quot;@NCA.Camber_FCrossPresetMax&quot;].Value); //SetValue(31, XmlFO.PubObjects[&quot;@NCA.Camber_FCrossPresetMin&quot;].Value);&#125;private void IDT_SERVICE_0A_CAMBER_R_Pre_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Camber_LRPreset&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Camber_LRPreset_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Camber_LRPresetMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Camber_LRPresetMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Camber_RRPreset&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Camber_RRPreset_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Camber_RRPresetMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Camber_RRPresetMin&quot;].Value, 600); //SetValue(26, XmlFO.PubObjects[&quot;@NCA.Camber_RCrossPreset&quot;].Value); //SetResult(28, XmlFO.PubObjects[&quot;@NCA.Camber_RCross_Result&quot;].Value); //SetValue(29, XmlFO.PubObjects[&quot;@NCA.Camber_RCrossPresetMax&quot;].Value); //SetValue(31, XmlFO.PubObjects[&quot;@NCA.Camber_RCrossPresetMin&quot;].Value);&#125;private void IDT_SERVICE_0B_CAMBER_F_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Camber_LF&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Camber_LF_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Camber_LFMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Camber_LFMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Camber_RF&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Camber_RF_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Camber_RFMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Camber_RFMin&quot;].Value, 600); SetValue(26, XmlFO.PubObjects[&quot;@NCA.Camber_FCross&quot;].Value, 600); SetResult(28, XmlFO.PubObjects[&quot;@NCA.Camber_FCross_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@NCA.Camber_FCrossMax&quot;].Value, 600); SetValue(31, XmlFO.PubObjects[&quot;@NCA.Camber_FCrossMin&quot;].Value, 600);&#125;private void IDT_SERVICE_0C_CAMBER_R_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Camber_LR&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Camber_LR_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Camber_LRMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Camber_LRMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Camber_RR&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Camber_RR_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Camber_RRMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Camber_RRMin&quot;].Value, 600); SetValue(26, XmlFO.PubObjects[&quot;@NCA.Camber_RCross&quot;].Value, 600); SetResult(28, XmlFO.PubObjects[&quot;@NCA.Camber_RCross_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@NCA.Camber_RCrossMax&quot;].Value, 600); SetValue(31, XmlFO.PubObjects[&quot;@NCA.Camber_RCrossMin&quot;].Value, 600);&#125;private void IDT_SERVICE_0D_ThrustSWA_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Thrust_R&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Thrust_R_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Thrust_RMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Thrust_RMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.SWA&quot;].Value, 100); SetResult(21, XmlFO.PubObjects[&quot;@NCA.SWA_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.SWAMax&quot;].Value, 100); SetValue(24, XmlFO.PubObjects[&quot;@NCA.SWAMin&quot;].Value, 100);&#125;private void IDT_SERVICE_0E_Light_L_Low_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@HLA.Low_L_Hor&quot;].Value, 10); SetResult(14, XmlFO.PubObjects[&quot;@HLA.Low_L_Hor_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@HLA.Low_L_HorMax&quot;].Value, 10); SetValue(17, XmlFO.PubObjects[&quot;@HLA.Low_L_HorMin&quot;].Value, 10); SetValue(19, XmlFO.PubObjects[&quot;@HLA.Low_L_Ver&quot;].Value, 10); SetResult(21, XmlFO.PubObjects[&quot;@HLA.Low_L_Ver_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@HLA.Low_L_VerMax&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@HLA.Low_L_VerMin&quot;].Value, 10);&#125;private void IDT_SERVICE_0F_Light_R_Low_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@HLA.Low_R_Hor&quot;].Value, 10); SetResult(14, XmlFO.PubObjects[&quot;@HLA.Low_R_Hor_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@HLA.Low_R_HorMax&quot;].Value, 10); SetValue(17, XmlFO.PubObjects[&quot;@HLA.Low_R_HorMin&quot;].Value, 10); SetValue(19, XmlFO.PubObjects[&quot;@HLA.Low_R_Ver&quot;].Value, 10); SetResult(21, XmlFO.PubObjects[&quot;@HLA.Low_R_Ver_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@HLA.Low_R_VerMax&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@HLA.Low_R_VerMin&quot;].Value, 10);&#125;private void IDT_SERVICE_10_Light_L_High_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@HLA.High_L_Hor&quot;].Value, 10); SetResult(14, XmlFO.PubObjects[&quot;@HLA.High_L_Hor_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@HLA.High_L_HorMax&quot;].Value, 10); SetValue(17, XmlFO.PubObjects[&quot;@HLA.High_L_HorMin&quot;].Value, 10); SetValue(19, XmlFO.PubObjects[&quot;@HLA.High_L_Ver&quot;].Value, 10); SetResult(21, XmlFO.PubObjects[&quot;@HLA.High_L_Ver_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@HLA.High_L_VerMax&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@HLA.High_L_VerMin&quot;].Value, 10); SetValue(26, XmlFO.PubObjects[&quot;@HLA.High_L_Int&quot;].Value, 0.1); SetResult(28, XmlFO.PubObjects[&quot;@HLA.High_L_Int_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@HLA.High_L_IntMax&quot;].Value, 0.1); SetValue(31, XmlFO.PubObjects[&quot;@HLA.High_L_IntMin&quot;].Value, 0.1);&#125;private void IDT_SERVICE_11_Light_R_High_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@HLA.High_R_Hor&quot;].Value, 10); SetResult(14, XmlFO.PubObjects[&quot;@HLA.High_R_Hor_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@HLA.High_R_HorMax&quot;].Value, 10); SetValue(17, XmlFO.PubObjects[&quot;@HLA.High_R_HorMin&quot;].Value, 10); SetValue(19, XmlFO.PubObjects[&quot;@HLA.High_R_Ver&quot;].Value, 10); SetResult(21, XmlFO.PubObjects[&quot;@HLA.High_R_Ver_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@HLA.High_R_VerMax&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@HLA.High_R_VerMin&quot;].Value, 10); SetValue(26, XmlFO.PubObjects[&quot;@HLA.High_R_Int&quot;].Value, 0.1); SetResult(28, XmlFO.PubObjects[&quot;@HLA.High_R_Int_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@HLA.High_R_IntMax&quot;].Value, 0.1); SetValue(31, XmlFO.PubObjects[&quot;@HLA.High_R_IntMin&quot;].Value, 0.1);&#125;private void IDT_SERVICE_12_WBH_F_Result()&#123; SetValue(12, XmlFO.ListObject[&quot;Device_WBH_FL&quot;].xValue, 10); SetResult(14, &quot;Y&quot;); SetValue(15, 0); SetValue(17, 0); SetValue(19, XmlFO.ListObject[&quot;Device_WBH_FR&quot;].xValue, 10); SetResult(21, &quot;Y&quot;); SetValue(22, 0); SetValue(24, 0);&#125;private void IDT_SERVICE_13_WBH_R_Result()&#123; SetValue(12, XmlFO.ListObject[&quot;Device_WBH_RL&quot;].xValue, 10); SetResult(14, &quot;Y&quot;); SetValue(15, 0); SetValue(17, 0); SetValue(19, XmlFO.ListObject[&quot;Device_WBH_RR&quot;].xValue, 10); SetResult(21, &quot;Y&quot;); SetValue(22, 0); SetValue(24, 0);&#125;private void IDT_SERVICE_14_Weight_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@Weight.LF&quot;].Value, 10); SetValue(14, XmlFO.PubObjects[&quot;@Weight.RF&quot;].Value, 10); SetValue(16, XmlFO.PubObjects[&quot;@Weight.Front&quot;].Value, 10); SetValue(18, XmlFO.PubObjects[&quot;@Weight.LR&quot;].Value, 10); SetValue(20, XmlFO.PubObjects[&quot;@Weight.RR&quot;].Value, 10); SetValue(22, XmlFO.PubObjects[&quot;@Weight.Rear&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@Weight.Vehicle&quot;].Value, 10);&#125;private void IDT_SERVICE_15_Caster_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Caster_LF&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Caster_LF_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Caster_LFMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Caster_LFMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Caster_RF&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Caster_RF_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Caster_RFMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Caster_RFMin&quot;].Value, 600); SendData[26] = (byte)(XmlFO.ListObject[&quot;Communication_NCA_IN_CasterEnable&quot;].xValue.StartsWith(&quot;T&quot;) ? 1 : 0); //1表示抽检测试, 0表示不测试&#125;private void IDT_SERVICE_16_Sai_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.SAI_LF&quot;].Value, 300); SetResult(14, XmlFO.PubObjects[&quot;@NCA.SAI_LF_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.SAI_LFMax&quot;].Value, 300); SetValue(17, XmlFO.PubObjects[&quot;@NCA.SAI_LFMin&quot;].Value, 300); SetValue(19, XmlFO.PubObjects[&quot;@NCA.SAI_RF&quot;].Value, 300); SetResult(21, XmlFO.PubObjects[&quot;@NCA.SAI_RF_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.SAI_RFMax&quot;].Value, 300); SetValue(24, XmlFO.PubObjects[&quot;@NCA.SAI_RFMin&quot;].Value, 300); SendData[26] = (byte)(XmlFO.ListObject[&quot;Communication_NCA_IN_CasterEnable&quot;].xValue.StartsWith(&quot;T&quot;) ? 1 : 0); //1表示抽检测试, 0表示不测试&#125;private void IDT_SERVICE_17_LTL_In_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@LTL.LF_Turn_In&quot;].Value, 10); SetResult(14, XmlFO.PubObjects[&quot;@LTL.LF_Turn_In_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@LTL.LF_Turn_InMax&quot;].Value, 10); SetValue(17, XmlFO.PubObjects[&quot;@LTL.LF_Turn_InMin&quot;].Value, 10); SetValue(19, XmlFO.PubObjects[&quot;@LTL.RF_Turn_In&quot;].Value, 10); SetResult(21, XmlFO.PubObjects[&quot;@LTL.RF_Turn_In_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@LTL.RF_Turn_InMax&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@LTL.RF_Turn_InMin&quot;].Value, 10); //转角差--看四轮数据中是否存在,存在直接接收,否则计算 /*SetValue(26, XmlFO.PubObjects[&quot;@LTL.LF_Turn_In&quot;].Value); SetResult(28, XmlFO.PubObjects[&quot;@LTL.LF_Turn_In_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@LTL.LF_Turn_InMax&quot;].Value); SetValue(31, XmlFO.PubObjects[&quot;@LTL.LF_Turn_InMin&quot;].Value);*/ SendData[33] = (byte)(XmlFO.ListObject[&quot;Communication_NCA_IN_L2LEnable&quot;].xValue.StartsWith(&quot;T&quot;) ? 1 : 0); //1表示抽检测试, 0表示不测试&#125;private void IDT_SERVICE_18_LTL_Out_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@LTL.LF_Turn_Out&quot;].Value, 10); SetResult(14, XmlFO.PubObjects[&quot;@LTL.LF_Turn_Out_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@LTL.LF_Turn_OutMax&quot;].Value, 10); SetValue(17, XmlFO.PubObjects[&quot;@LTL.LF_Turn_OutMin&quot;].Value, 10); SetValue(19, XmlFO.PubObjects[&quot;@LTL.RF_Turn_Out&quot;].Value, 10); SetResult(21, XmlFO.PubObjects[&quot;@LTL.RF_Turn_Out_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@LTL.RF_Turn_OutMax&quot;].Value, 10); SetValue(24, XmlFO.PubObjects[&quot;@LTL.RF_Turn_OutMin&quot;].Value, 10); //转角差 /*SetValue(26, XmlFO.PubObjects[&quot;@LTL.LF_Turn_In&quot;].Value); SetResult(28, XmlFO.PubObjects[&quot;@LTL.LF_Turn_In_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@LTL.LF_Turn_InMax&quot;].Value); SetValue(31, XmlFO.PubObjects[&quot;@LTL.LF_Turn_InMin&quot;].Value);*/ SendData[33] = (byte)(XmlFO.ListObject[&quot;Communication_NCA_IN_L2LEnable&quot;].xValue.StartsWith(&quot;T&quot;) ? 1 : 0); //1表示抽检测试, 0表示不测试&#125;private void IDT_SERVICE_19_WBHTest()&#123; ((xDvBaseClient)XmlFO.ListObject[&quot;Communication_NCA_OUT_StopMotor&quot;]).SetTrue(&quot;&quot;); SendData[7] &amp;= 0xFB;//bit2置0 //启动轮眉测量 ExecutePlatTeam(&quot;Device_StepItem_WBH&quot;, () =&gt; &#123; SetState(IDTState.OK); SendData[7] |= 1 &lt;&lt; 2; //轮眉测试标志位,收到25号服务置0,轮眉测试完置1 &#125;);&#125;//空气悬架标定完成private void IDT_SERVICE_1A_ASUDone()&#123; ((xDvBaseClient)XmlFO.ListObject[&quot;Communication_NCA_OUT_StopMotor&quot;]).SetFalse(&quot;&quot;); SendData[7] |= 1 &lt;&lt; 3; //是否需要一直保持&#125;private void IDT_SERVICE_1B_HLA_LowBeamOn()&#123;&#125;private void IDT_SERVICE_1C_HLA_FullBeamOn()&#123;&#125;private void IDT_SERVICE_1D_ADB_On()&#123; //((xDvBaseClient)XmlFO.ListObject[&quot;Communication_NCA_OUT_ADBReady&quot;]).SetTrue(&quot;&quot;);&#125;private void IDT_SERVICE_1E_EPSTest()&#123; //将停止滚筒放在Always流程中调用 ExecutePlatTeam(&quot;Device_Public_DSA_StopRolls&quot;); ((xDvBaseClient)XmlFO.ListObject[&quot;Communication_NCA_OUT_StopMotor&quot;]).SetTrue(&quot;&quot;);&#125;private void IDT_SERVICE_1F_EPSTestDone()&#123; ((xDvBaseClient)XmlFO.ListObject[&quot;Communication_NCA_OUT_StopMotor&quot;]).SetFalse(&quot;&quot;);&#125;private void IDT_SERVICE_20_HEAD_ADB_Left_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@HLA.DASM_Hor&quot;].Value, 100);//LeftEmaxX SetValue(14, XmlFO.PubObjects[&quot;@HLA.DASM_Hor_SetPoint&quot;].Value, 100);//LeftEmaxY SetValue(16, XmlFO.PubObjects[&quot;@HLA.DASM_Hor_Max&quot;].Value, 100);//LeftP0X SetValue(18, XmlFO.PubObjects[&quot;@HLA.DASM_Hor_Min&quot;].Value, 100);//LeftP0Y SetValue(20, XmlFO.PubObjects[&quot;@HLA.DASM_Hor_Offset&quot;].Value, 100);//LeftP1X SetValue(22, XmlFO.PubObjects[&quot;@HLA.DASM_Hor_Module_Offset&quot;].Value, 100);//LeftP1Y&#125;private void IDT_SERVICE_21_HEAD_ADB_Right_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@HLA.DASM_Ver&quot;].Value, 100);//Right SetValue(14, XmlFO.PubObjects[&quot;@HLA.DASM_Ver_SetPoint&quot;].Value, 100); SetValue(16, XmlFO.PubObjects[&quot;@HLA.DASM_Ver_Max&quot;].Value, 100); SetValue(18, XmlFO.PubObjects[&quot;@HLA.DASM_Ver_Min&quot;].Value, 100); SetValue(20, XmlFO.PubObjects[&quot;@HLA.DASM_Ver_Offset&quot;].Value, 100); SetValue(22, XmlFO.PubObjects[&quot;@HLA.DASM_Ver_Module_Offset&quot;].Value, 100);&#125;private void IDT_SERVICE_22_TOECross_Result()&#123; SetValue(12, XmlFO.PubObjects[&quot;@NCA.Toe_FCross&quot;].Value, 600); SetResult(14, XmlFO.PubObjects[&quot;@NCA.Toe_FCross_Result&quot;].Value); SetValue(15, XmlFO.PubObjects[&quot;@NCA.Toe_FCrossMax&quot;].Value, 600); SetValue(17, XmlFO.PubObjects[&quot;@NCA.Toe_FCrossMin&quot;].Value, 600); SetValue(19, XmlFO.PubObjects[&quot;@NCA.Toe_RCross&quot;].Value, 600); SetResult(21, XmlFO.PubObjects[&quot;@NCA.Toe_RCross_Result&quot;].Value); SetValue(22, XmlFO.PubObjects[&quot;@NCA.Toe_RCrossMax&quot;].Value, 600); SetValue(24, XmlFO.PubObjects[&quot;@NCA.Toe_RCrossMin&quot;].Value, 600); SetValue(26, XmlFO.PubObjects[&quot;@NCA.Thrust_F&quot;].Value, 600); SetResult(28, XmlFO.PubObjects[&quot;@NCA.Thrust_F_Result&quot;].Value); SetValue(29, XmlFO.PubObjects[&quot;@NCA.Thrust_FMax&quot;].Value, 600); SetValue(31, XmlFO.PubObjects[&quot;@NCA.Thrust_FMin&quot;].Value, 600);&#125;public override void SendBeforeHandle()&#123; //Byte5 bit0:急停 bit1:fault bit4:Automode bit5:Manualmode bit6:calmode bit7:ready int byte5 = 0x00; //bool ems = Pt[&quot;Communication_NCA_IN_System_EStop&quot;].zString().StartsWith(&quot;T&quot;); bool fault = Pt[&quot;Communication_NCA_IN_System_Fault&quot;].zString().StartsWith(&quot;T&quot;); bool automode = Pt[&quot;Communication_NCA_IN_System_AutoMode&quot;].zString().StartsWith(&quot;T&quot;); bool centered = Pt[&quot;Communication_NCA_IN_Centered&quot;].zString().StartsWith(&quot;T&quot;); bool abort = Pt[&quot;Communication_NCA_IN_CycleAbort&quot;].zString().StartsWith(&quot;T&quot;); //byte5 = ems ? (byte5 | (1 &lt;&lt; 0)) : byte5; byte5 = fault || !automode || abort ? (byte5 | (1 &lt;&lt; 1)) : byte5; SendData[5] = (byte)byte5; int byte7 = 0x00; bool bepNewData = Pt[&quot;System_BEP_NewData&quot;].zString().StartsWith(&quot;Y&quot;); byte7 = centered ? (byte7 | (1 &lt;&lt; 0)) : byte7; //四轮对中完成 byte7 = bepNewData ? (byte7 | (1 &lt;&lt; 1)) : byte7; //四轮调整完成标志位 SendData[7] |= (byte)byte7; #region ADB bool hlaLeftLow = XmlFO.ListObject[&quot;Communication_NCA_IN_HLALeftLowDone&quot;].xValue.StartsWith(&quot;T&quot;); bool hlaRightLow = XmlFO.ListObject[&quot;Communication_NCA_IN_HLARightLowDone&quot;].xValue.StartsWith(&quot;T&quot;); bool hlaLeftHigh = XmlFO.ListObject[&quot;Communication_NCA_IN_HLALeftHighDone&quot;].xValue.StartsWith(&quot;T&quot;); bool hlaRightHigh = XmlFO.ListObject[&quot;Communication_NCA_IN_HLARightHighDone&quot;].xValue.StartsWith(&quot;T&quot;); bool hlaLeftADB = XmlFO.ListObject[&quot;Communication_NCA_IN_HLALeftADBDone&quot;].xValue.StartsWith(&quot;T&quot;); bool hlaRightADB = XmlFO.ListObject[&quot;Communication_NCA_IN_HLARightADBDone&quot;].xValue.StartsWith(&quot;T&quot;); SendData[7] |= (byte)(!(hlaLeftLow || hlaRightLow) ? 0x01 &lt;&lt; 4 : 0x00);//近光测试完成 SendData[7] |= (byte)(!(hlaLeftHigh || hlaRightHigh) ? 0x01 &lt;&lt; 5 : 0x00);//远光测试完成 SendData[7] |= (byte)(!(hlaLeftADB || hlaRightADB) ? 0x01 &lt;&lt; 6 : 0x00);//ADB测试完成 SendData[7] |= (byte)(XmlFO.ListObject[&quot;Communication_NCA_IN_CycleComplete&quot;].xValue.StartsWith(&quot;T&quot;) ? 0x01 &lt;&lt; 7 : 0x00); #endregion byte xor = 0x00; for (int i = 0; i &lt; (SendData.Length - 2); i++) xor ^= SendData[i]; SendData[SendData.Length - 2] = xor;&#125;public override void SetResult(int index, object value)&#123; string sval = Convert.ToString(value).ToUpper(); switch(sval) &#123; case &quot;Y&quot;: SendData[index] = 0x01; break; case &quot;T&quot;: SendData[index] = 0x01; break; case &quot;P&quot;: SendData[index] = 0x01; break; case &quot;N&quot;: SendData[index] = 0x00; break; case &quot;F&quot;: SendData[index] = 0x00; break; default: SendData[index] = 0x01; break; &#125;&#125; ADAS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433private void IDT_SERVICE_0E_VehicleInformation()&#123; try &#123; string sZTS = RecvData[25].ToString(); string sVIN = GetString(8, 17); Pt[&quot;CarParam_VIN&quot;] = sVIN; Pt[&quot;CarParam_ZTS&quot;] = sZTS; &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_07_DeviceReturnHome()&#123; try &#123; ExecutePlatTeam(&quot;MainThread_Monitor_CancelTest&quot;, &quot;Communication_IDT_PlatReturnHomeStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_0A_ACCBoardMove()&#123; try &#123; Pt[&quot;CarParam_ACC_TargetX&quot;] = GetValue(8); Pt[&quot;CarParam_ACC_TargetY&quot;] = GetValue(10); Pt[&quot;CarParam_ACC_TargetZ&quot;] = GetValue(12); ExecutePlatTeam(&quot;Device_FAS_ACC_设备就位&quot;, &quot;Communication_IDT_PlatACCMoveStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_0B_ACCBoardReturnHome()&#123; try &#123; ExecutePlatTeam(&quot;Device_FAS_ACC_设备回位&quot;, &quot;Communication_IDT_PlatACCReturnHomeStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_0C_Center()//协议中未定义&#123; try &#123; //if (RecvData[12] == 0x01 &amp;&amp; RecvData[13] == 0x01) //CkProj(&quot;Device_FAS_摆正器_设备就位&quot;); //if (RecvData[12] == 0x00 &amp;&amp; RecvData[13] == 0x00) //CkProj(&quot;Device_FAS_摆正器_设备回位&quot;); ExecutePlatTeam(&quot;Device_FAS_摆正器_设备就位&quot;, &quot;Communication_IDT_PlatCenterStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_0D_RobotMove()&#123; try &#123; Pt[&quot;CarParam_HUD_Route&quot;] = &quot;1&quot;; Pt[&quot;CarParam_HUD_TargetX&quot;] = GetValue(8, 0.1); Pt[&quot;CarParam_HUD_TargetY&quot;] = GetValue(10, 0.1); Pt[&quot;CarParam_HUD_TargetZ&quot;] = GetValue(12, 0.1); Pt[&quot;CarParam_HUD_TargetRX&quot;] = GetValue(14, 0.001); Pt[&quot;CarParam_HUD_TargetRY&quot;] = GetValue(16, 0.001); Pt[&quot;CarParam_HUD_TargetRZ&quot;] = GetValue(18, 0.001); ExecutePlatTeam(&quot;Device_FAS_HUD_设备就位&quot;, &quot;Communication_IDT_PlatRobotMoveStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_0F_WBH_Result()&#123; ExecutePlatTeam(&quot;Device_StepItem_WBH&quot;, &quot;Communication_IDT_PlatWBHStatus&quot;, () =&gt; &#123; SetState(IDTState.OK); SetValue(12, XmlFO.PubObjects[&quot;@WBHTest.WBH_FL&quot;].Value, 10); SetResult(20, &quot;Y&quot;); SetValue(14, XmlFO.PubObjects[&quot;@WBHTest.WBH_FR&quot;].Value, 10); SetResult(21, &quot;Y&quot;); SetValue(16, XmlFO.PubObjects[&quot;@WBHTest.WBH_RL&quot;].Value, 10); SetResult(22, &quot;Y&quot;); SetValue(18, XmlFO.PubObjects[&quot;@WBHTest.WBH_RR&quot;].Value, 10); SetResult(23, &quot;Y&quot;); &#125;);&#125;//Byte 07//BIT0: 改位置 1 表示 BBK LDA 测量结束//BIT1: 改位置 1 表示 BBK 畸变测量结束//BIT2: 改位置 1 表示 BBK FOV 测量结束//BIT3: 改位置 1 表示 BBK 重影测量结束//BIT4: 改位置 1 表示 BBK VID 测量结束//BIT5: 改位置 1 表示 BBK LOA 测量结束private void IDT_SERVICE_10_LDA()&#123; try &#123; HUDTestServiceHandle(0, &quot;Device_FAS_HUD_LDA&quot;, &quot;Communication_IDT_PlatLDAStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_11_LDAResult()&#123; try &#123; SetResult(10, zjHUD.ValueLDA.bResult); SetResult(11, zjHUD.ValueLDACalibrable.bResult); SetValue(12, zjHUD.ValueLDAOffset.Value); SetValue(14, zjHUD.ValueLDA.Value.Value, 100); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;//Byte 07 BIT1: 改位置 1 表示 BBK 畸变 测量结束private void IDT_SERVICE_12_Distortion()&#123; try &#123; //zjHUD.eyeBoxPos = &quot;M&quot;; HUDTestServiceHandle(1, &quot;Device_FAS_HUD_Distortion&quot;, &quot;Communication_IDT_PlatDistortionStatus&quot;); //HUDTestServiceHandle(1, &quot;Device_FAS_HUD_RotateAngle&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_13_DistortionResult()&#123; try &#123; SetResult(10, zjHUD.ValueDistortion.bResult &amp;&amp; zjHUD.ValueDistortionMaxH.bResult &amp;&amp; zjHUD.ValueDistortionMaxV.bResult &amp;&amp; zjHUD.ValueDistortionRotation.bResult); SetResult(11, zjHUD.ValueDistortionHCalibrable.bResult &amp;&amp; zjHUD.ValueDistortionVCalibrable.bResult &amp;&amp; zjHUD.ValueDistortionRCalibrable.bResult); SetValue(12, zjHUD.ValueDistortionMaxH.Value.Value, 100); SetValue(14, zjHUD.ValueDistortionMaxV.Value.Value, 100); SetValue(16, zjHUD.ValueDistortionRotation.Value.Value, 100); SetValue(18, zjHUD.ValueDistortion.Value.Value, 100); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;#region 畸变刷写private void IDT_SERVICE_14_DistortionParam1()&#123; try &#123; Array.Copy(zjHUD.warpParamMsg, 0, SendData, 12, 25); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_15_DistortionParam2()&#123; try &#123; Array.Copy(zjHUD.warpParamMsg, 25, SendData, 12, 25); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_16_DistortionParam3()&#123; try &#123; Array.Copy(zjHUD.warpParamMsg, 50, SendData, 12, 25); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_17_DistortionParam4()&#123; try &#123; Array.Copy(zjHUD.warpParamMsg, 75, SendData, 12, 25); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_18_DistortionParam5()&#123; try &#123; Array.Copy(zjHUD.warpParamMsg, 100, SendData, 12, 24); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;#endregionprivate void IDT_SERVICE_19_FOVTest()&#123; try &#123; //zjHUD.eyeBoxPos = &quot;M&quot;; HUDTestServiceHandle(2, &quot;Device_FAS_HUD_FOV&quot;, &quot;Communication_IDT_PlatFOVStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_1A_FOVResult()&#123; try &#123; SetResult(10, zjHUD.ValueHorFOVDistance.bResult &amp;&amp; zjHUD.ValueVerFOVDistance.bResult); SetValue(12, zjHUD.ValueHorFOVDistance.Value.Value, 10); SetValue(14, zjHUD.ValueVerFOVDistance.Value.Value, 10); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_1B_GhostTest()&#123; try &#123; if (RecvData[8] == 0x00) zjHUD.EyeBoxPos.Value = &quot;Top&quot;; if (RecvData[8] == 0x01) zjHUD.EyeBoxPos.Value = &quot;Mid&quot;; if (RecvData[8] == 0x02) zjHUD.EyeBoxPos.Value = &quot;Bot&quot;; HUDTestServiceHandle(3, &quot;Device_FAS_HUD_Ghost&quot;, &quot;Communication_IDT_PlatGhostStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_1C_GhostResult()&#123; try &#123; SetResult(10, zjHUD.ValueGhost.bResult); SetValue(12, zjHUD.ValueGhost.Value.Value, 10); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_1D_VIDTest()&#123; try &#123; HUDTestServiceHandle(4, &quot;Device_FAS_HUD_Distance&quot;, &quot;Communication_IDT_PlatDistanceStatus&quot;); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_1E_VIDResult()&#123; try &#123; SetResult(10, zjHUD.ValueDistance.bResult); SetValue(12, zjHUD.ValueDistance.Value.Value, 10); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_1F_LOATest()&#123; try &#123; //TestServiceHandle(4, &quot;Device_FAS_HUD_Distance&quot;);//FOV中测试完成 &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void IDT_SERVICE_20_LOAResult()&#123; try &#123; SetResult(10, zjHUD.ValueLLA.Result.Value); SetValue(12, zjHUD.ValueLLA.Value.Value, 10); &#125; catch (System.Exception ex) &#123; Log(ex.ToString()); SetState(IDTState.NOK); &#125;&#125;private void HUDTestServiceHandle(int bits, string proName, string checkObject)&#123; byte shift = 0x01; SendData[7] &amp;= (byte)~(shift &lt;&lt; bits); ExecutePlatTeam(proName, checkObject, () =&gt; &#123; SetState(IDTState.OK); SendData[7] |= (byte)(shift &lt;&lt; bits); &#125;, () =&gt; &#123; SetState(IDTState.NOK); SendData[7] |= (byte)(shift &lt;&lt; bits); &#125;);&#125;public override void SendBeforeHandle()&#123; //Byte5 bit0:急停 bit1:fault bit4:Automode bit5:Manualmode bit6:calmode bit7:ready int byte5 = 0x00; bool ems = Pt[&quot;Communication_FAS_IN_System_EStop&quot;].zString().StartsWith(&quot;T&quot;); bool fault = Pt[&quot;Communication_FAS_IN_System_Fault&quot;].zString().StartsWith(&quot;T&quot;); bool autoMode = Pt[&quot;Communication_FAS_IN_System_AutoMode&quot;].zString().StartsWith(&quot;T&quot;); bool ready = !ems &amp;&amp; !fault &amp;&amp; autoMode; byte5 = ems ? (byte5 | (1 &lt;&lt; 0)) : byte5; byte5 = fault ? (byte5 | (1 &lt;&lt; 1)) : byte5; byte5 = autoMode ? (byte5 | (1 &lt;&lt; 4)) : byte5; byte5 = !autoMode ? (byte5 | (1 &lt;&lt; 5)) : byte5; byte5 = ready ? (byte5 | (1 &lt;&lt; 7)) : byte5; SendData[5] = (byte)byte5; //8-11 车型信息--未知 //12-13 前后对中状态 //RecvData[12] = RecvData[13] = (byte)(Pt[&quot;Communication_FAS_IN_Center_TestPos&quot;].zString().StartsWith(&quot;T&quot;) ? 0x01 : 0x00); //17-18 PLC心跳 //21-24 坐标信息 //SetValue(20, Pt[&quot;Communication_FAS_IN_ACC_XDirection_CurrentValue&quot;]); //SetValue(21, Pt[&quot;Communication_FAS_IN_ACC_Hori_CurrentValue&quot;]); //SetValue(22, Pt[&quot;Communication_FAS_IN_ACC_Vertical_CurrentValue&quot;]); byte xor = 0x00; for (int i = 0; i &lt; (SendData.Length - 2); i++) xor ^= SendData[i]; SendData[SendData.Length - 2] = xor;&#125;public override void SetResult(int index, object value)&#123; string sval = Convert.ToString(value).ToUpper(); if (sval.StartsWith(&quot;Y&quot;)) SendData[index] = 0x01; if (sval.StartsWith(&quot;T&quot;)) SendData[index] = 0x01; if (sval.StartsWith(&quot;N&quot;)) SendData[index] = 0x00; if (sval.StartsWith(&quot;F&quot;)) SendData[index] = 0x00;&#125;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"分布式系统","slug":"分布式系统","date":"2024-04-16T02:38:09.000Z","updated":"2024-05-17T08:58:24.478Z","comments":true,"path":"分布式系统.html","link":"","permalink":"https://silencejql.github.io/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html","excerpt":"","text":"概念 分布式系统是其组件分布在连网的计算机上, 组件之间通过传递消息进行通讯和动作协调的系统 具有组件的并发性.缺乏全局时钟.组件故障独立性的特征","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://silencejql.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"分布式系统","slug":"分布式系统","permalink":"https://silencejql.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}]},{"title":"软件架构","slug":"软件架构","date":"2024-04-16T01:13:34.000Z","updated":"2024-05-18T05:22:51.345Z","comments":true,"path":"软件架构.html","link":"","permalink":"https://silencejql.github.io/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.html","excerpt":"软件架构入门笔记","text":"软件架构入门笔记 分层架构 常见: 展示层-&gt;业务层-&gt;数据层 事件驱动架构 事件驱动架构模式是⼀一种主流的异步分发事件架构模式，常⽤用于设计⾼高度可拓展的应⽤ 中介拓扑模式, 代理拓扑模式 微内核架构 插件化应用架构 核心系统, 插件模块 微服务架构 是一种分布式架构 常见的有: 基于REST API的拓扑结构, 基于REST的应用拓扑结构, 集中式消息拓扑结构 基于空间的架构 云架构模型","categories":[],"tags":[]},{"title":"Git 添加gitignore后不起作用","slug":"Git-添加gitignore后不起作用","date":"2024-04-07T12:03:35.000Z","updated":"2025-03-24T11:43:13.596Z","comments":true,"path":"Git-添加gitignore后不起作用.html","link":"","permalink":"https://silencejql.github.io/Git-%E6%B7%BB%E5%8A%A0gitignore%E5%90%8E%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8.html","excerpt":"gitignore - Specifies intentionally untracked files to ignore","text":"gitignore - Specifies intentionally untracked files to ignore .gitignore官方文档 A gitignore file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected To stop tracking a file that is currently tracked, use git rm --cached to remove the file from the index. The filename can then be added to the .gitignore file to stop the file from being reintroduced in later commits. 原因 .gitignore文件只会作用于未跟踪(untracked)的文件，如果需要作用于已经跟踪(tracked)的文件，加入ignore文件时需要先停止跟踪(stop tracking)从暂存中删除才会生效 解决方法 123git rm -r --cached .git add .git commit -m &quot;update .gitignore&quot;","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"MagicInfo三星多显示器配置","slug":"MagicInfo三星多显示器配置","date":"2024-04-03T01:59:44.000Z","updated":"2025-03-07T12:17:38.614Z","comments":true,"path":"MagicInfo三星多显示器配置.html","link":"","permalink":"https://silencejql.github.io/MagicInfo%E4%B8%89%E6%98%9F%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%E9%85%8D%E7%BD%AE.html","excerpt":"三星MagicInfo显示器配置简单说明 重点在多图像切换的配置","text":"三星MagicInfo显示器配置简单说明 重点在多图像切换的配置 添加显示器设备 配置好各显示器IP等准备工作后, 进入网页配置界面添加显示器 添加设备前先创建设备组, 每个显示器都要添加相应的组 命名中最好标识出显示器ID及当前显示器要显示的图像, 方便后续内容的添加 添加完设备组后, 逐一批准设备到相应组内 添加内容 上传要显示的图片 若每个显示器只需要显示一张图下一章节不需要看,跳到 添加日程表 创建WebAuthor内容 如果显示器需要根据不同需求显示不同图片, 则需要上位机触发图片切换 需要在WebAuthor中为每个显示器创建包含多张图片的内容, 并设置触发图片切换的条件 点击WebAuthor进入WebAuthor主界面, 如下图配置, 点击创建 进入WebAuthor主界面 进入内容界面, 改变内容查看方式, 点击下方 … 显示Page页 将某个显示器需要显示的图片拉到右侧(若左侧没有图片, 需要先完成上一节的内容上传) 点击图片下方添加页面的按钮添加Page页并拖入需要显示的图片, Page页为显示器显示的内容, 下方时间为当前图片显示的时间, 若用上位机控制图片切换则将时间设置成23小时59分59秒, 即不自动切换. 点击新增全局页, 用于创建图片切换触发事件 配置好当前显示器需要显示的图片后, 双击全局页后点击编辑事件进入事件编辑页面 添加事件触发器, 选择网络端口后添加触发配置 触发器: 接收到相应内容后执行后续操作, 如通过网络通讯接收到1后自动切换到Page1设置的图片, 收到2后自动切换到Page2设置的图片 改页面没有找到保存按钮, 完成上述配置后可点击右上角新建内容, 提示保存, 保存时命名推荐同上 添加日程表 添加日程表前先添加日程表组, 命名同上 点击新时间表添加, 其中内容部分选择WebAuthor中创建的内容 事件触发器验证 MagicInfo会创建监听5000端口的UDP Server 通过Socket助手创建UDP Client, IP配置需要测试的显示器IP或者设置成广播同时配置所有显示器, 端口设置5000 发送触发器创建时的内容进行图片切换","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"HUD机器人标定及验证","slug":"HUD机器人角度验证算法","date":"2024-03-23T10:46:11.000Z","updated":"2025-03-07T12:17:59.936Z","comments":true,"path":"HUD机器人角度验证算法.html","link":"","permalink":"https://silencejql.github.io/HUD%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A7%92%E5%BA%A6%E9%AA%8C%E8%AF%81%E7%AE%97%E6%B3%95.html","excerpt":"HUD相机标定完成后辅助调节机器人角度时角度的计算方法","text":"HUD相机标定完成后辅助调节机器人角度时角度的计算方法 坐标系说明 车辆坐标系 标定说明 根据标靶四孔的三坐标计算出标靶中心坐标OOO 相机走到与OOO点相同的YZYZYZ坐标处, 保证相机中心与OOO点在同一轴线上 将标靶左上角圆孔中心坐标填入标定点.Point3DXYZ中 测量相机感光芯片到标靶的距离填入特征点.DotDistance中 调整相机角度使得图像中心十字位于标靶中心OOO处, 且目测图像角度偏差不大 拍照识别四个圆孔 标定内外参 将ROI框住某个圆孔点击标定验证, 查看输出角度进行微调后重复567步, 直到输出满足要求 若角度偏差大但图像很正, 可能是坐标参数的输入有问题 若某个点的偏移量大, 可适当调整曝光使识别更准确后再验证 图像说明 左上角为P1,右上角为P3 左下角为P7,右下角为P9 代码 12345678910111213141516171819202122PointF3D Point3d = CameraAgorithm.Pixel2World(p, Camera, Camera.Extrinsics_Tz_mm - Camera.Point3DZ);PointF3D P1 = CameraAgorithm.Pixel2World(_calibrationAgorithm.DotLeftTop, Camera, Camera.Extrinsics_Tz_mm - Camera.Point3DZ);PointF3D P3 = CameraAgorithm.Pixel2World(_calibrationAgorithm.DotRightTop, Camera, Camera.Extrinsics_Tz_mm - Camera.Point3DZ);PointF3D P7 = CameraAgorithm.Pixel2World(_calibrationAgorithm.DotLeftBottom, Camera, Camera.Extrinsics_Tz_mm - Camera.Point3DZ);PointF3D P9 = CameraAgorithm.Pixel2World(_calibrationAgorithm.DotRightBottom, Camera, Camera.Extrinsics_Tz_mm - Camera.Point3DZ);//PCenter为图像中心点坐标在世界坐标系中的点//PCenter.P_X=&gt;车辆坐标系的Y//PCenter.P_Y=&gt;车辆坐标系的Z//PCenter.P_Z=&gt;车辆坐标系的X//Camera.Point3DX=&gt;车辆坐标系的Y//Camera.Point3DY=&gt;车辆坐标系的Z//Camera.Point3DZ=&gt;车辆坐标系的XPointF3D PCenter = CameraAgorithm.Pixel2World(new PointF(Camera.PixelWidth/2,Camera.PixelHeight/2), Camera, Camera.Extrinsics_Tz_mm - Camera.Point3DZ);//上面两点的倾斜度double RX = Math.Atan((P3.P_Y - P1.P_Y) / (P3.P_X - P1.P_X)) * 180 / Math.PI;//图像中心相对相机中心(机器人坐标)水平方向偏移double RY = Math.Atan(((PCenter.P_X - m_Motion.Data_YPos.xValue.zFloat())) / (Camera.Extrinsics_Tz_mm - Camera.Point3DZ)) * 180 / Math.PI;//图像中心相对相机中心(机器人坐标)竖直方向偏移double RZ = Math.Atan(((PCenter.P_Y - m_Motion.Data_ZPos.xValue.zFloat())) / (Camera.Extrinsics_Tz_mm - Camera.Point3DZ)) * 180 / Math.PI;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Git拆分仓库","slug":"Git拆分仓库","date":"2024-03-04T02:54:39.000Z","updated":"2025-03-25T03:17:52.509Z","comments":true,"path":"Git拆分仓库.html","link":"","permalink":"https://silencejql.github.io/Git%E6%8B%86%E5%88%86%E4%BB%93%E5%BA%93.html","excerpt":"将功能复杂的版本库拆分为功能单一的版本库并保存所有相关提交信息","text":"将功能复杂的版本库拆分为功能单一的版本库并保存所有相关提交信息 示例 比如, Project版本库中存在Pro1和Pro2两个项目文件, 现在我们要将Pro1项目拆分到单独的版本库中进行维护, 并且要保留原有提交信息 文件路径如下 12345678D:.├─Project│ └─Pro1│ └─File1│ └─File2│ └─Pro2│ └─File1│ └─File2 1.分离相关提交到新建分支 12345# 在Project中执行# &lt;name-of-folder&gt; : 要拆分出来的文件夹# &lt;name-of-new-branch&gt; : 分离提交到新建分支git subtree split -P &lt;name-of-folder&gt; -b &lt;name-of-new-branch&gt;git subtree split -P Pro1 -b Project1 2.提取分离后的分支 2.1在新路径保存分支 在合适位置新建文件夹后初始化Git, 然后拉取刚才新建的Project1分支即可 查看git log 123456# &lt;path-of-Project&gt; : 步骤1中创建分支所在的路径, 即Project# &lt;name-of-new-branch&gt; : 分离后新建分支名git pull &lt;path-of-Project&gt; &lt;name-of-new-branch&gt;git pull &lt;path-of-Project&gt; Project1git log 2.2在Pro1中初始化Git, 不更改原文件夹结构 1234567# 在Pro1中执行git initgit add .git commit -m &quot;提交信息&quot;git pull .. Project1git log","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"扩展方法","slug":"扩展方法","date":"2023-12-20T08:46:40.000Z","updated":"2025-03-24T11:42:55.470Z","comments":true,"path":"扩展方法.html","link":"","permalink":"https://silencejql.github.io/%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95.html","excerpt":"C# 扩展方法, 通过.的方式执行","text":"C# 扩展方法, 通过.的方式执行 示例 1234567891011121314151617namespace ExtensionMethods&#123; public static class MyExtensions &#123; // int 为返回类型, 参数this string str为 要扩展的类型 public static int WordCount(this string str) &#123; return str.Split(new char[]&#123;&#x27; &#x27;, &#x27;.&#x27;, &#x27;?&#x27;&#125;, StringSplitOptions.RemoveEmptyEntires).Length; &#125; &#125;&#125;using ExtensionMethods;string s = &quot;Hello Extension Methods&quot;;int length = s.WordCount();","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"GUID/UUID","slug":"GUID-UUID","date":"2023-11-14T07:23:02.000Z","updated":"2025-03-24T11:42:50.300Z","comments":true,"path":"GUID-UUID.html","link":"","permalink":"https://silencejql.github.io/GUID-UUID.html","excerpt":"","text":"示例 12string uuid = Guid.NewGuid().ToString();//带-uuid = Guid.NewGuid().ToString(&quot;N&quot;);//纯数字","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"UML-PlantUML","slug":"UML-PlantUML","date":"2023-09-07T06:40:11.000Z","updated":"2025-03-24T11:41:46.416Z","comments":true,"path":"UML-PlantUML.html","link":"","permalink":"https://silencejql.github.io/UML-PlantUML.html","excerpt":"","text":"类图 1234class Studentabstract class Studentinterface Personenum Gender &#123; MALE, FEMALE &#125; 12345678910//方法属性//+:public//-:private//#:protectedclass ClassName &#123; + attribute1 : Type1 # attribute2 : Type2 - method1() : ReturnType1 + method2(param1:Type1, param2:Type2) : ReturnType2&#125; 类之间关系 泛化关系 继承非抽象类 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示 12345678//B继承自Aclass A &#123; + method() : ReturnType&#125;class B &#123; + method() : ReturnType&#125;A &lt;|-- B 实现关系 实现关系表现为继承抽象类 12345678//B继承自Ainterface A &#123; + method() : ReturnType&#125;class B &#123; + method() : ReturnType&#125;A &lt;|.. B 聚合关系 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在 12345678//B聚合到A上，或者说A由B组成class A &#123; + method() : ReturnType&#125;class B &#123; + method() : ReturnType&#125;A o-- B 组合关系 12345678//说A由B组成class A &#123; + method() : ReturnType&#125;class B &#123; + method() : ReturnType&#125;A *-- B 关联关系 描述不同类的对象之间的结构关系 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示B知道A，但 A不知道B 1234567class A &#123; + method() : ReturnType&#125;class B &#123; + method() : ReturnType&#125;A &lt;-- B 依赖关系 一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化 一个对象在运行期间会用到另一个对象的关系 应该保持单向依赖，杜绝双向依赖的产生 1234567class A &#123; + method() : ReturnType&#125;class B &#123; + method() : ReturnType&#125;A &lt;.. B","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"设计模式-MVC模式","slug":"设计模式-MVC模式","date":"2023-09-06T08:50:50.000Z","updated":"2025-03-24T11:48:28.895Z","comments":true,"path":"设计模式-MVC模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVC%E6%A8%A1%E5%BC%8F.html","excerpt":"Model（模型） - 模型代表一个存取数据的对象 View（视图） - 视图代表模型包含的数据的可视化 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开","text":"Model（模型） - 模型代表一个存取数据的对象 View（视图） - 视图代表模型包含的数据的可视化 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。//Modelpublic class Student&#123; private string rollNo; private string name; public string RollNo() &#123; get&#123;return rollNo;&#125; set&#123;this.rollNo = value;&#125; &#125; public string Name &#123; get&#123;return name;&#125; set&#123;this.name = value;&#125; &#125;&#125;//Viewpublic class StudentView&#123; public void PrintStudentDetails(string name, string rollNo) &#123; Console.WriteLine(&quot;Student Name: &#123;0&#125;, Roll No: &#123;1&#125;&quot;, name, rollNo); &#125;&#125;//Controllerpublic class StudentController&#123; private Strudent model; private StudentView view; public StudentController(Student model, StudentView view) &#123; this.model = model; this.view = view; &#125; public void SetStudentName(string name) &#123; model.Name = name; &#125; public void SetStudentRollNo(string rollNo) &#123; model.rollNo = rollNo; &#125; public void GetStudentName() &#123; return model.Name; &#125; public void GetStudentRollNo() &#123; return model.rollNo; &#125; public void UpdateView() &#123; view.PrintStudentDetails(model.Name, model.RollNo); &#125;&#125;//ClientStudent model = new Student();StudentView view = new StudentView();StudentController controller = new StudengController(model, view);controller.SetStudentName(&quot;Xiaoming&quot;);controller.SetStudentRollNo(&quot;10&quot;);controller.UpdateView();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-总结","slug":"设计模式-总结","date":"2023-09-06T08:48:59.000Z","updated":"2025-03-24T11:48:09.530Z","comments":true,"path":"设计模式-总结.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E7%BB%93.html","excerpt":"设计模式是众多软件开发人员经过相当长的一段时间的试验和错误的总结 目的是使程序 可维护, 可扩展, 可复用, 灵活性好","text":"设计模式是众多软件开发人员经过相当长的一段时间的试验和错误的总结 目的是使程序 可维护, 可扩展, 可复用, 灵活性好 六大原则 开闭原则（Open Close Principle） 对扩展开放，对修改关闭。 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 简言之，是为了使程序的扩展性好，易于维护和升级。使用接口和抽象类 里式替换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。 里氏代换原则是对开闭原则的补充。 实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范 依赖倒置原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度 迪特米法则（Demeter Principle） 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立 合成复用原则（Composite Reuse Principle） 尽量使用合成/聚合的方式，而不是使用继承 常用23种设计模式 创建型 用于创建对象 工厂模式（Factory Pattern） 工厂方法适用于创建单个产品 工厂负责创建接口使用者需要的对象，但是接口使用者不需要关心具体的对象类型，只需要关心已知的返回对象类型和接口即可 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 允许我们在不改变现有代码基础上添加新的产品类型，并且可以将具体产品的实现与调用方分离开来 优点: 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖 简单工厂模式和普通工厂模式的差别比较小，可以合在一起讲，它们的区别是简单工厂模式里，工厂直接负责产品的生产，而到普通工厂模式里，工厂是个抽象类，具体的生产行为交给了具体的工厂。到了抽象工厂模式里，工厂生产的对象不止一个，而是多个 抽象工厂模式（Abstract Factory Pattern） 抽象工厂适用于创建多个产品 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 抽象工厂可以理解为是一系列工厂方法的集合。抽象工厂的子类，实现每一个工厂方法 使用工厂方法模式时，往往仅需选用所需的工厂方法即可，而使用抽象工厂模式时，则需要创建所有抽象产品对象 单例模式（Singleton Pattern） 确保一个类只有一个实例，并提供了一个全局访问点来访问该实例 建造者模式（Builder Pattern） 组合的变化由不同基础部件组合导致 使用多个简单的对象一步一步构建成一个复杂的对象 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 建造者模式更加关注与零件装配的顺序 原型模式（Prototype Pattern） 用于创建重复的对象，同时又能保证性能 实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式 注意深拷贝和浅拷贝 结构性 适配器模式（Adapter Pattern） 使原有接口适配新接口 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 适配器继承或依赖已有的对象，实现想要的目标接口 适配器模式：客户需要使用现有的类，而此类的接口不符合客户的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类；通过接口转换，将一个类插入另一个类系中 桥接模式（Bridge Pattern） 将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来 适用于一个类存在两个独立变化的维度，且这两个维度都需要进行扩展 个人理解: 一个抽象类中调用另一个抽象类, 实现解耦 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次 将对象组合成树形结构以表示&quot;部分-整体&quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性 树枝和叶子实现统一接口，树枝内部组合该接口 树枝内部组合该接口，并且含有内部属性 List，里面放 Component 装饰器模式（Decorator Pattern） 允许向一个现有的对象添加新的功能，同时又不改变其结构 在保持类方法签名完整性的前提下，提供了额外的功能 外观模式（Facade Pattern） 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口 创建一个新类, 为客户端提供具体的部件组合后的接口 两个类的关系是单项的, 一方通过外观与另一方发生关系, 而另一方则不能 享元模式（Flyweight Pattern） 已创建的对象直接返回 用于减少创建对象的数量，以减少内存占用和提高性能 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建 用 HashMap(Hashtable) 存储这些对象 代理模式（Proxy Pattern） 一个类代表另一个类的功能, 为其他对象提供一种代理以控制对这个对象的访问, 继承同一接口, 对客户端来说并无区别 代理模式：当无法或不想直接访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 行为型 责任链模式（Chain of Responsibility Pattern） 为请求创建了一个接收者对象的链 通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了 命令模式（Command Pattern） 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令 解开了请求调用者和请求接收者之间的耦合关系 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化 比如需要对行为进行记录、撤销或重做、事务等处理时使用 当需要先将一个函数登记上，然后再以后调用此函数时，就需要使用命令模式，其实这就是回调函数 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-访问者模式","slug":"设计模式-访问者模式","date":"2023-09-06T06:27:27.000Z","updated":"2025-03-24T11:47:46.183Z","comments":true,"path":"设计模式-访问者模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html","excerpt":"将数据结构与数据操作分离, 用于稳定的数据结构和易变的操作耦合问题","text":"将数据结构与数据操作分离, 用于稳定的数据结构和易变的操作耦合问题 访问者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465abstract class Visitor&#123; public abstract void VisitorConcreateElementA(ConcreateElementA concreateElementA); public abstract void VisitorConcreateElementB(ConcreateElementB concreateElementB);&#125;class ConcreateVisitor1 : Visitor&#123; public override void VisitorConcreateElementA(ConcreateElementA concreateElementA) &#123; Console.WriteLine(&quot;&#123;0&#125;被&#123;1&#125;访问&quot;, ConcreateElementA.GetType().Name, this.GetType().Name); &#125; public override void VisitorConcreateElementB(ConcreateElementB concreateElementB) &#123; Console.WriteLine(&quot;&#123;0&#125;被&#123;1&#125;访问&quot;, ConcreateElementB.GetType().Name, this.GetType().Name); &#125;&#125;class ConcreateVisitor2 : Visitor&#123;&#125;abstract class Element&#123; public abstract void Accept(Visitor visitor);&#125;class ConcreateElementA : Element&#123; public override void Accept(Visitor visitor) &#123; visitor.VisitConcreateElementA(this); &#125; public void OperationA() &#123;&#125;&#125;class ConcreateElementB : Element&#123; public override void Accept(Visitor visitor) &#123; visitor.VisitConcreateElementB(this); &#125; public void OperationB() &#123;&#125;&#125;class ObjectStructure&#123; private IList&lt;Element&gt; elements = new List&lt;Element&gt;(); public void Attach(Element element) &#123; elements.Add(element); &#125; public void Detach(Element element) &#123; elements.Remove(element); &#125; public void Accept(Visitor visitor) &#123; elements.Foreach(e =&gt; e.Accept(visitor)); &#125;&#125;//ClientObjectStructure o = new ObjectStructure();o.Attach(new ConcreateElementA);o.Attach(new ConcreateElementB);ConcreateVisitor1 v1 = new ConcreateVisitor1();ConcreateVisitor1 v2 = new ConcreateVisitor2();o.Accept(v1);o.Accept(v2);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-解释器模式","slug":"设计模式-解释器模式","date":"2023-09-06T06:07:09.000Z","updated":"2025-03-24T11:47:50.255Z","comments":true,"path":"设计模式-解释器模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html","excerpt":"给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子","text":"给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 解释器模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//抽象表达式abstract class AbstractExpression&#123; public abstract void Interpret(Context context);&#125;//终结符表达式class TerminalExpression : AbstractExpression&#123; public override void Interpret(Context context) &#123; Console.WriteLine(&quot;终端解释器&quot;); &#125;&#125;class NonterminalExpression : AbstractExpression&#123; public override void Interpret(Context context) &#123; Console.WriteLine(&quot;非终端解释器&quot;) &#125;&#125;class Context&#123; private string input; public string Input &#123; get &#123; return input; &#125; set &#123; input = value; &#125; &#125; private string output; public string Output &#123; get &#123; return output; &#125; set &#123; output = value; &#125; &#125;&#125;//ClientContext context = new Context()IList&lt;AbstractExpression&gt; list = new List&lt;AbstractExpression&gt;();list.Add(new TerminalExpression());list.Add(new NonterminalExpression());list.Add(new TerminalExpression());list.Add(new TerminalExpression());foreach(AbstractExpression exp in list)&#123; exp.Interpret();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-享元模式","slug":"设计模式-享元模式","date":"2023-09-06T05:16:54.000Z","updated":"2025-03-24T11:48:21.700Z","comments":true,"path":"设计模式-享元模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html","excerpt":"用于减少创建对象的数量，以减少内存占用和提高性能 运用共享技术有效地支持大量细粒度的对象 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建 用 HashMap(Hashtable) 存储这些对象 string 运用了Flyweight模式","text":"用于减少创建对象的数量，以减少内存占用和提高性能 运用共享技术有效地支持大量细粒度的对象 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建 用 HashMap(Hashtable) 存储这些对象 string 运用了Flyweight模式 享元模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Flyweight 享元接口abstract class Flyweight&#123; public abstract void Operation(int extrinsicstate);&#125;//共享的Flyweight子类class ConcreateFlyweight : Flyweight&#123; public override void Operation(int extrinsicstate) &#123; Console.WriteLine(&quot;具体Flayweight: &quot; + extrinsicstate); &#125;&#125;//不需要共享的Flyweight子类class UnsharedConcreateFlyweight : Flyweight&#123; public override void Operation(int extrinsicstate) &#123; Console.WriteLine(&quot;不共享的具体Flayweight: &quot; + extrinsicstate); &#125;&#125;//享元工厂class FlyweightFactory&#123; private Hashtable flyweights = new Hashtable(); public FlyweightFactory() &#123; flyweights.Add(&quot;X&quot;, new ConcreateFlyweight()); flyweights.Add(&quot;Y&quot;, new ConcreateFlyweight()); flyweights.Add(&quot;X&quot;, new ConcreateFlyweight()); &#125; public Flyweight GetFlyweight(string key) &#123; if(!flyweights.ContainKey(key)) flyweights.Add(key, new ConcreateFlyweight()); return(Flyweight)flyweight[key]; &#125;&#125;//Clientint extrinsicstate = 22;FlyweightFactory f = new FlyweightFactory();Flyweight fx = f.GetFlyweight(&quot;X&quot;);fx.Operation(--extrinsicstate);Flyweight fy = f.GetFlyweight(&quot;Y&quot;);fy.Operation(--extrinsicstate);Flyweight fz = f.GetFlyweight(&quot;Z&quot;);fz.Operation(--extrinsicstate);Flyweight uf = new UnsharedConcreateFlyweight();uf.Operation(--extrinsicstate);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-中介者模式","slug":"设计模式-中介者模式","date":"2023-09-06T03:39:02.000Z","updated":"2025-03-24T11:48:24.990Z","comments":true,"path":"设计模式-中介者模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html","excerpt":"用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理","text":"用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理 中介者模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Mediator 抽象中介者abstract class Mediator&#123; public abstract void Send(string message, Colleague colleague);&#125;//Colleague 抽象同事类abstract class Colleague&#123; protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125;class ConcreateMediator : Mediator&#123; private ConcreateColleague1 colleague1; private ConcreateColleague2 colleague2; public ConcreateColleague1 Colleague1 &#123; set&#123;colleague1 = value;&#125; &#125; public ConcreateColleague2 Colleague2 &#123; set&#123;colleague2 = value;&#125; &#125; public override void Send(string message, Colleague colleague) &#123; if(colleague == colleague1) colleague2.Notify(message) else colleague1.Notify(message); &#125;&#125;class ConcreateColleague1 : Colleague&#123; public ConcreateColleague1(Mediator mediator) : base(mediator) &#123;&#125; public void Send(string message) &#123; mediator.Send(message, this); &#125; public void Notify(string message) &#123; Console.WriteLine(&quot;Colleague 1 Recv &quot; + message); &#125;&#125;class ConcreateColleague2 : Colleague&#123; public ConcreateColleague2(Mediator mediator) : base(mediator) &#123;&#125; public void Send(string message) &#123; mediator.Send(message, this); &#125; public void Notify(string message) &#123; Console.WriteLine(&quot;Colleague 2 Recv &quot; + message); &#125;&#125;//ClientConcreateMediator m = new ConcreateMediator();//创建中介ConcreateColleague1 c1 = new ConcreateColleague1(m);//让同事都认识中介ConcreateColleague2 c2 = new ConcreateColleague2(m);m.colleague1 = c1;//让中介认识同事m.colleague2 = c2;c1.Send(&quot;你瞅啥&quot;);c2.Send(&quot;瞅你咋地&quot;);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-职责链模式","slug":"设计模式-职责链模式","date":"2023-09-06T03:12:51.000Z","updated":"2025-03-24T11:47:55.258Z","comments":true,"path":"设计模式-职责链模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html","excerpt":"避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了","text":"避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了 职责链模式 1234567891011121314151617181920212223242526272829303132333435363738394041//Handlerabstract class Handler&#123; protect Handler successor;//职责链中的下一级, 当前对象无法处理时交由此对象处理 public void SetSuccessor(Handler successor) &#123; this.successor = successor; &#125; public abstract void HandleRequest(int request);&#125;//具体处理者class ConcreateHandler1 : Handler&#123; public override void HandleRequest(int request) &#123; if(request &gt;=0 &amp;&amp; request &lt; 10)//当前处理者可处理 Console.WriteLine(&quot;0-10&quot;); else if(successor != null) successor.HandleRequest(request);//处理不了交给上级 &#125;&#125;class ConcreateHandler2 : Handler&#123; public override void HandleRequest(int request) &#123; if(request &gt;=10 &amp;&amp; request &lt; 20)//当前处理者可处理 Console.WriteLine(&quot;0-10&quot;); else if(successor != null) successor.HandleRequest(request);//处理不了交给上级 &#125;&#125;//ClientHandler h1 = new ConcreateHandler1();Handler h2 = new ConcreateHandler2();h1.SetSuccessor(h2);int[] requests = &#123;0, 12, 8, 18, 2, 9, 11&#125;;foreach(int re in requests)&#123; h1.HandleRequest(re);&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-命令模式","slug":"设计模式-命令模式","date":"2023-09-04T09:23:08.000Z","updated":"2025-03-24T11:48:17.984Z","comments":true,"path":"设计模式-命令模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html","excerpt":"请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令","text":"请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令 命令模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接受者class Receiver&#123; public void Action() &#123; Console.WriteLine(&quot;执行请求&quot;); &#125;&#125;//Command 执行操作的接口abstract class Command&#123; protected Receiver receiver; public Command(Receiver receiver) &#123; this.receiver = receiver; &#125; public abstract void Execute();&#125;//ConcreateCommand 将一个接受者对象绑定于一个动作，调用接受者相应的操作，以实现Executeclass ConcreateCommand : Command&#123; public ConcreateCommand(Receiver receiver) : base(receiver) &#123;&#125; public override void Execute() &#123; receiver.Action(); &#125;&#125;//Invoker 要求命令执行请求class Invoker&#123; private Command command; public void SetCommand(Command command) &#123; this.command = command; &#125; public void ExecuteCommand() &#123; command.Execute(); &#125;&#125;//ClientReceiver rec = new Receiver();Command co = new ConcreateCommand(rec);Invoker i = new Invoker();i.SetCommand(co);i.ExecuteCommand(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//命令接口public interface Order &#123; void execute();&#125;//请求类public class Stock &#123; private String name = &quot;ABC&quot;; private int quantity = 10; public void buy()&#123; System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, Quantity: &quot; + quantity +&quot; ] bought&quot;); &#125; public void sell()&#123; System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, Quantity: &quot; + quantity +&quot; ] sold&quot;); &#125;&#125;//实现命令接口public class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125;public class SellStock implements Order &#123; private Stock abcStock; public SellStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.sell(); &#125;&#125;//命令调用类import java.util.ArrayList;import java.util.List; public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125;//Clientpublic class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); &#125;&#125;/*Stock [ Name: ABC, Quantity: 10 ] boughtStock [ Name: ABC, Quantity: 10 ] sold*/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-桥接模式","slug":"设计模式-桥接模式","date":"2023-09-04T08:40:51.000Z","updated":"2025-03-24T11:48:06.034Z","comments":true,"path":"设计模式-桥接模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html","excerpt":"将抽象部分与实现部分分离，使它们都可以独立的变化 需要多角度去分类实现对象， 而只用继承会造成大量的类增加， 不能满足开放-封闭原则时， 就应该要考虑用桥接模式 适用于一个类存在两个独立变化的维度, 且每个维度都需要进行扩展","text":"将抽象部分与实现部分分离，使它们都可以独立的变化 需要多角度去分类实现对象， 而只用继承会造成大量的类增加， 不能满足开放-封闭原则时， 就应该要考虑用桥接模式 适用于一个类存在两个独立变化的维度, 且每个维度都需要进行扩展 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//不知不同颜色的不同形状//将颜色和形状分开interface IColor&#123; void Paint();&#125;public class RedColor : IColor&#123; public void Paint() &#123; Console.WriteLine(&quot;RedColor&quot;); &#125;&#125;public class BlueColor : IColor&#123; public void Paint() &#123; Console.WriteLine(&quot;BlueColor&quot;); &#125;&#125;public abstract class Shape&#123; protected IColor color; public void SetColor(IColor color) &#123; this.color = color; &#125; public abstract void Draw();&#125;public class Circle : Shape&#123; public override void Draw() &#123; Console.WriteLine(&quot;Circle&quot;); color.Paint() &#125;&#125;public class Rectangle : Shape&#123; public override void Draw() &#123; Console.WriteLine(&quot;Rectangle&quot;); color.Paint() &#125;&#125;//ClientShape shape = new Circle();shape.SetColor(new BlueColor());shape.Draw();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-迭代器模式","slug":"设计模式-迭代器模式","date":"2023-09-04T07:21:07.000Z","updated":"2025-03-24T11:47:41.294Z","comments":true,"path":"设计模式-迭代器模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html","excerpt":"学习其实现方式","text":"学习其实现方式 迭代器模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Iterator迭代器抽象类abstract class Iterator&#123; public abstract object First(); public abstract object Next(); public abstract bool IsDone(); public abstract object CurrentItem();&#125;//具体迭代器类class ConcreateIterator : Iterator&#123; private ConcreateAggregate aggregate; private int current = 0; public ConcreateIterator(ConcreateAggregate aggregate) &#123; this.aggregate = aggregate; &#125; public override object First() &#123; return this.aggregate[0]; &#125; public override object Next() &#123; object ret = null; current++; if(current &lt; aggregate.Count) &#123; ret = aggregate[current]; &#125; return ret; &#125; public override bool IsDone() &#123; return current &gt;= aggregate.Count; &#125; public override object CurrentItem() &#123; return aggrate[current]; &#125;&#125;//抽象聚集类abstract class Aggregate&#123; public abstract Iterator CreateIterator();//创建迭代器&#125;//具体聚集类class ConcreateAggregate : Aggregate&#123; private IList&lt;object&gt; items new List&lt;object&gt;(); public override Iterator CreateIterator() &#123; return new ConcreateIterator(this); &#125; public int Count &#123;get &#123; return items.Count;&#125;&#125; public object this[int index] &#123; get&#123;return items[index];&#125; set&#123;items.Insert(index, value);&#125; &#125;&#125;//ClientConcreateAggregate ca = new ConcreateAggregate();ca[0] = &quot;0&quot;;ca[1] = &quot;1&quot;;ca[2] = &quot;2&quot;;Iterator i = new ConcreateIterator(ca);object item = i.First();while(!i.IsDone)&#123; Console.WriteLine(i.CurrentItem()); i.Next();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-组合模式","slug":"设计模式-组合模式","date":"2023-09-04T06:35:35.000Z","updated":"2025-03-24T11:47:57.893Z","comments":true,"path":"设计模式-组合模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html","excerpt":"用于把一组相似的对象当作一个单一的对象","text":"用于把一组相似的对象当作一个单一的对象 组合模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//Componentabstract class Component&#123; protected string name; public Component(string name) &#123; this.name = name; &#125; public abstract void Add(Component c); public abstract void Remove(Component c); public abstract void Display(int depth);&#125;//Leaf 叶节点class Leaf : Component&#123; public Leaf(string name) : base(name) &#123;&#125; public override void Add(Component c) &#123; Console.WriteLine(&quot;Can not add to a leaf&quot;); &#125; public override void Remove(Component c) &#123; Console.WriteLine(&quot;Can not remove from a leaf&quot;); &#125; public override void Display(int depth) &#123; Console.WriteLine(new String(&#x27;-&#x27;, depth) + &quot;name&quot;); &#125;&#125;//Composite 枝节点 用于存储子部件class Composite : Component&#123; private List&lt;Component&gt; children = new List&lt;Component&gt;(); public Composite(string name) : base(name) &#123;&#125; public override void Add(Component c) &#123; children.Add(c); &#125; public override void Remove(Component c) &#123; children.Remove(c); &#125; public override void Display(int depth) &#123; Console.WriteLine(new String(&#x27;-&#x27;, depth) + &quot;name&quot;); children.Foreach(c.Display(depth + 2);) &#125;&#125;//ClientComposite root = new Composite(&quot;root&quot;);root.Add(new Leaf(&quot;Leaf A&quot;));root.Add(new Leaf(&quot;Leaf B&quot;));Composite comp = new Composite(&quot;Composite X&quot;);comp.Add(new Leaf(&quot;Leaf XA&quot;));comp.Add(new Leaf(&quot;Leaf XB&quot;));root.Add(comp);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-备忘录模式","slug":"设计模式-备忘录模式","date":"2023-09-04T05:24:18.000Z","updated":"2025-03-24T11:48:15.974Z","comments":true,"path":"设计模式-备忘录模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html","excerpt":"在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态","text":"在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态 备忘录模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//发起人Originatorclass Originator&#123; private string state; public string State&#123;get;set;&#125; //创建备忘录保存 public Memento CreateMemento() &#123; return new Memento(state); &#125; //恢复数据 public void SetMemento(Memento memento) &#123; state = memento.State; &#125; public void Show() &#123; Console.WriteLine(&quot;State = &quot; + state); &#125;&#125;//备忘录Memento//封装保存细节class Memento&#123; private string state; public string State&#123;get;&#125; public Memento(string state) &#123; this.state = state; &#125;&#125;//管理者Caretakerclass Caretaker&#123; private Memento memento; public Memento Memento&#123;get; set;&#125;&#125;//ClientOriginator o = new Originator();o.State = &quot;On&quot;;o.Show();Caretaker c = new Caretaker();c.Memento = o.CreateMemento();o.State = &quot;Off&quot;;o.Show();o.SetMemento(c.Memento);o.Show();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-适配器模式","slug":"设计模式-适配器模式","date":"2023-09-04T03:45:01.000Z","updated":"2025-03-24T11:47:36.769Z","comments":true,"path":"设计模式-适配器模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html","excerpt":"将一个类的接口转换成客户希望的另外一个接口 主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中 DataAdapter","text":"将一个类的接口转换成客户希望的另外一个接口 主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中 DataAdapter 适配器模式 1234567891011121314151617181920212223242526272829//目标接口class Target&#123; public virtual void Request() &#123; Console.WriteLine(&quot;普通请求&quot;); &#125;&#125;//需要适配的类class Adaptee&#123; public void SpecificRequest() &#123; Console.WriteLine(&quot;特殊请求&quot;); &#125;&#125;//适配器类class Adapter : Target&#123; private Adaptee adaptee = new Adaptee(); public override void Request() &#123; adaptee.SpecificRequest(); &#125;&#125;//ClientTarget target = new Adapter();target.Request();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-状态模式","slug":"设计模式-状态模式","date":"2023-09-04T02:56:16.000Z","updated":"2025-03-24T11:48:02.195Z","comments":true,"path":"设计模式-状态模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html","excerpt":"当一个控制对象状态转换的条件表达式过于复杂时, 将状态的判断逻辑转移到表示不同状态的一系列类中 当代码中包含大量与对象状态有关的条件语句时, 使用状态模式","text":"当一个控制对象状态转换的条件表达式过于复杂时, 将状态的判断逻辑转移到表示不同状态的一系列类中 当代码中包含大量与对象状态有关的条件语句时, 使用状态模式 状态模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//抽象状态类abstract class State&#123; public abstract void Handle(Context context);&#125;//具体状态类class ConcreateStateA : State&#123; public override void Handle(Context context) &#123; context.State = new ConcreateStateB(); &#125;&#125;class ConcreateStateB : State&#123; public override void Handle(Context context) &#123; context.State = new ConcreateStateA(); &#125;&#125;class Context&#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State State &#123; get&#123; return state;&#125; set &#123; state = value; Console.WriteLine(&quot;Current state: &quot; + state.GetType().Name); &#125; &#125; public void Request() &#123; state.Handle(this); &#125;&#125;//ClientContext c = new Context(new ConcreateStateA());c.Request();//每次请求实现状态切换c.Request();c.Request();c.Request(); 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//不同时间点的工作状态示例//抽象状态public abstract class State&#123; public abstract void WriteProgram(Work w);&#125;//上午工作状态类public class ShangWuState : State&#123; public override void WriteProgram(Work w) &#123; if(w.Hour &lt; 12) Console.WriteLine(&quot;上午工作状态&quot;); else &#123; w.SetState(new ZhongWUState()) w.WriteProgram(); &#125; &#125;&#125;public class ZhongWUState : State&#123; public override void WriteProgram(Work w) &#123; if(w.Hour &lt; 13) Console.WriteLine(&quot;中午工作状态&quot;); else &#123; w.SetState(new XiaWUState()) w.WriteProgram(); &#125; &#125;&#125;public class XiaWUState : State&#123; public override void WriteProgram(Work w) &#123; if(w.Hour &lt; 17) Console.WriteLine(&quot;下午工作状态&quot;); else &#123; w.SetState(new WanShangState()) w.WriteProgram(); &#125; &#125;&#125;public class WanShangState : State&#123; public override void WriteProgram(Work w) &#123; if(w.TaskFinished) &#123; w.SetState(new RestState()); w.WriteProgram(); &#125; else &#123; if(w.Hour &lt; 21) Console.WriteLine(&quot;晚上工作状态&quot;); else &#123; w.SetState(new SleepState()) w.WriteProgram(); &#125; &#125; &#125;&#125;public class SleepState : State&#123; public override void WriteProgram(Work w) &#123; Console.WriteLine(&quot;睡觉&quot;); &#125;&#125;public class RestState : State&#123; public override void WriteProgram(Work w) &#123; Console.WriteLine(&quot;下班休息&quot;); &#125;&#125;public class Work&#123; private State current; public Work() &#123; current = new ShangWuState();//初始化为上午状态 &#125; private double hour; public double Hour &#123; get &#123; return hour;&#125; set &#123; hour = value;&#125; &#125; private bool finish = false; public bool TaskFinish &#123; get &#123; return finish;&#125; set &#123; finish = value;&#125; &#125; public void SetState(State s) &#123; current = s; &#125; public void WriteProgram() &#123; current.WriteProgram(this); &#125;&#125;//ClientWork work = new Work();work.Hour = 9;work.WriteProgram();work.Hour = 12;work.WriteProgram();work.Hour = 16;work.WriteProgram();work.Hour = 20;work.WriteProgram();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-观察者模式","slug":"设计模式-观察者模式","date":"2023-08-30T06:37:10.000Z","updated":"2025-03-24T11:48:41.595Z","comments":true,"path":"设计模式-观察者模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html","excerpt":"定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。","text":"定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//抽象通知者abstract class Subject&#123; private IList&lt;Observer&gt; observers = new List&lt;Observer&gt;(); //增加观察者 public void Attach(Observer observer) &#123; observers.Add(observer); &#125; //移除观察者 public void Detach(Observer observer) &#123; observers.Remove(observer); &#125; //通知 public void Notify() &#123; observers.Foreach(o =&gt; o.Update()) &#125;&#125;//抽象观察者interface class IObserver&#123; void Update();&#125;//具体通知者class ConcreateSubject : Subject&#123; private string subjectState; //具体被观察者的状态 public string SubjectState &#123; get&#123;return subjectState;&#125; set&#123;subjectState = value&#125; &#125;&#125;//具体观察者class ConcreatObserver : IObserver&#123; private string name; private string observerState; private ConcreateSubject subject; public ConcreatObserver(ConcreateSubject subject, string name) &#123; this.subject = subject; this.name = name; &#125; public void Update() &#123; observerState = subject.SubjectState; Console.WriteLine(&quot;观察者&#123;0&#125;的新状态是&#123;1&#125;&quot;, name, observerState); &#125; public ConcreateSubject Subject &#123; get&#123;return subject;&#125; set&#123;subject = value;&#125; &#125;&#125;//ClientConcreateSubject subject = new ConcreateSubject();lsubject.Attach(new ConcreatObserver(subject, &quot;X&quot;));subject.Attach(new ConcreatObserver(subject, &quot;Y&quot;));subject.Attach(new ConcreatObserver(subject, &quot;Z&quot;));subject.SubjectState = &quot;ABC&quot;;subject.Notify(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//使用事件//通知者接口interface Subject&#123; void Noticy(); string SubjectState &#123; get; set; &#125;&#125;//具体通知者class ConcreateSubject : Subject&#123; public event EventHandler Update; private string action; public void Notify() &#123; Update(); &#125; public string SubjectState &#123; get&#123;return action;&#125; set&#123;action = value;&#125; &#125;&#125;//具体观察者class ConcreatObserver1&#123; private string name; private Subject subject; public ConcreatObserver1(Subject subject, string name) &#123; this.subject = subject; this.name = name; &#125; public void Update1() &#123; observerState = subject.SubjectState; Console.WriteLine(&quot;观察者&#123;0&#125;的新状态是&#123;1&#125;&quot;, name, observerState); &#125;&#125;class ConcreatObserver2&#123; private string name; private Subject subject; public ConcreatObserver2(Subject subject, string name) &#123; this.subject = subject; this.name = name; &#125; public void Update2() &#123; observerState = subject.SubjectState; Console.WriteLine(&quot;观察者&#123;0&#125;的新状态是&#123;1&#125;&quot;, name, observerState); &#125;&#125;//ClientConcreateSubject subject = new ConcreateSubject();subject.Update += new EventHandler(new ConcreatObserver1(subject, &quot;X&quot;).Update1());subject.Update += new EventHandler(new ConcreatObserver2(subject, &quot;Y&quot;).Update2());subject.SubjectState = &quot;ABC&quot;;subject.Notify();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-建造者模式","slug":"设计模式-建造者模式","date":"2023-08-30T05:39:55.000Z","updated":"2025-03-24T11:49:04.083Z","comments":true,"path":"设计模式-建造者模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html","excerpt":"使用多个简单的对象一步一步构建成一个复杂的对象 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示","text":"使用多个简单的对象一步一步构建成一个复杂的对象 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//产品class Product&#123; IList&lt;string&gt; parts = new List&lt;string&gt;(); public void Add(string part) &#123; parts.Add(part); &#125; public void Show() &#123; Console.WriteLine(&quot;产品创建--&quot;); parts.Foreach(p =&gt; Console.WriteLine(p)); &#125;&#125;//建造者--抽象abstract class Builder&#123; public abstract void BuildPartA(); public abstract void BuildPartB(); public abstract Product GetResult();&#125;//建造者--具体class ConcreateBuilder1 : Builder&#123; private Product product = new Product(); public override void BuildPartA() &#123; product.Add(&quot;Part A&quot;); &#125; public override void BuildPartB() &#123; product.Add(&quot;Part B&quot;); &#125; public override void GetResult() &#123; return product; &#125;&#125;class ConcreateBuilder2 : Builder&#123; private Product product = new Product(); public override void BuildPartA() &#123; product.Add(&quot;Part X&quot;); &#125; public override void BuildPartB() &#123; product.Add(&quot;Part Y&quot;); &#125; public override void GetResult() &#123; return product; &#125;&#125;//指挥者class Director&#123; public void Construct(Builder builder) &#123; builder.BuildPartA(); builder.BuildPartB(); &#125;&#125;//ClientDirector director = new Director();Builder b1 = new ConcreateBuilder1();Builder b2 = new ConcreateBuilder2();director.Construct(b1);Product p1 = b1.GetResult();p1.Show();director.Construct(b2);Product p2 = b2.GetResult();p2.Show(); 建造者与外观模式对比 建造者的目的是希望用同样的生产过程，根据不同的生产者得到不同的产品。需要重写 外观模式则是将多个对象组合起来，它不需要生产者，也不需要得到不同的结果。不需要重写","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-外观模式","slug":"设计模式-外观模式","date":"2023-08-30T05:14:58.000Z","updated":"2025-03-24T11:49:13.356Z","comments":true,"path":"设计模式-外观模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html","excerpt":"隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。","text":"隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//子系统class SubSystemOne&#123; public void MethodOne() &#123; Console.WriteLine(&quot;子系统一&quot;) &#125;&#125;class SubSystemTwo&#123; public void MethodTwo() &#123; Console.WriteLine(&quot;子系统二&quot;) &#125;&#125;class SubSystemThree&#123; public void MethodThree() &#123; Console.WriteLine(&quot;子系统三&quot;) &#125;&#125;//外观类class Facade&#123; SubSystemOne one; SubSystemOne two; SubSystemOne three; public Facade() &#123; one = new SubSystemOne(); two = new SubSystemTwo(); three = new SubSystemThree(); &#125; public void MethodA() &#123; one.MethodOne(); two.MethodTwo(); three.MethodThree(); &#125; public void MethodB() &#123; one.MethodOne(); three.MethodThree(); &#125;&#125;//ClientFacade facade = new Facade();facade.MethodA();facade.MethodB();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-模板方法模式","slug":"设计模式-模板方法模式","date":"2023-08-30T03:11:14.000Z","updated":"2025-03-24T11:48:56.921Z","comments":true,"path":"设计模式-模板方法模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html","excerpt":"一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中 把不变的部分移至父类, 去除子类重复代码","text":"一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中 把不变的部分移至父类, 去除子类重复代码 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class Game &#123; public abstract void initialize(); public abstract void startPlay(); public abstract void endPlay(); //模板 public void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125;public class Cricket : Game &#123; public override void endPlay() &#123; Console.WriteLine(&quot;Cricket Game Finished!&quot;); &#125; public override void initialize() &#123; Console.WriteLine(&quot;Cricket Game Initialized! Start playing.&quot;); &#125; public override void startPlay() &#123; Console.WriteLine(&quot;Cricket Game Started. Enjoy the game!&quot;); &#125;&#125;public class Football : Game &#123; public override void endPlay() &#123; Console.WriteLine(&quot;Football Game Finished!&quot;); &#125; public override void initialize() &#123; Console.WriteLine(&quot;Football Game Initialized! Start playing.&quot;); &#125; public override void startPlay() &#123; Console.WriteLine(&quot;Football Game Started. Enjoy the game!&quot;); &#125;&#125;Game game = new Cricket();game.play();System.out.println();game = new Football();game.play();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-原型模式","slug":"设计模式-原型模式","date":"2023-08-30T01:29:52.000Z","updated":"2025-03-24T11:49:17.065Z","comments":true,"path":"设计模式-原型模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html","excerpt":"原型模式是用于创建重复的对象，同时又能保证性能, 当直接创建对象的代价比较大时例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。","text":"原型模式是用于创建重复的对象，同时又能保证性能, 当直接创建对象的代价比较大时例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 示例 123456789101112131415161718192021222324252627282930313233343536373839//普通实现class Resume&#123; private string name; private string sex; private string age; private string timeArea; private string compart; public Resume(string name) &#123; this.name = name; &#125; public void SetPersonalInfo(string sex, string age) &#123; this.sex = sex; this.age = age; &#125; public void SetWorkExperience(string timeArea, string company) &#123; this.timeArea = timeArea; this.company = company; &#125; public void Display() &#123; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, name, sex, age); Console.WriteLine(&quot;工作经历: &#123;0&#125; &#123;1&#125;&quot;, timeArea, company); &#125;&#125;//Client---需要多次创建对象Resume a = new Resume(&quot;小a&quot;);a.SetPersonalInfo(&quot;男&quot;, &quot;21&quot;);a.SetWorkExperience(&quot;2021-2022&quot;, &quot;a公司&quot;);Resume b = new Resume(&quot;小a&quot;);b.SetPersonalInfo(&quot;男&quot;, &quot;21&quot;);b.SetWorkExperience(&quot;2022-2023&quot;, &quot;b公司&quot;);a.Display();b.Display(); 12345678910111213141516171819202122232425262728293031323334353637383940414243//原型模式class Resume : ICloneable&#123; private string name; private string sex; private string age; private string timeArea; private string compart; public Resume(string name) &#123; this.name = name; &#125; public void SetPersonalInfo(string sex, string age) &#123; this.sex = sex; this.age = age; &#125; public void SetWorkExperience(string timeArea, string company) &#123; this.timeArea = timeArea; this.company = company; &#125; public void Display() &#123; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, name, sex, age); Console.WriteLine(&quot;工作经历: &#123;0&#125; &#123;1&#125;&quot;, timeArea, company); &#125; public Object Clone() &#123; //浅拷贝--值类型:逐位复制, 引用类型只复制引用(指向同一对象) return (Object)this.MemberwiseClone(); &#125;&#125;//ClientResume a = new Resume(&quot;小a&quot;);a.SetPersonalInfo(&quot;男&quot;, &quot;21&quot;);a.SetWorkExperience(&quot;2021-2022&quot;, &quot;a公司&quot;);Resume b = (Resume)a.Clone();b.SetWorkExperience(&quot;2022-2023&quot;, &quot;b公司&quot;);a.Display();b.Display(); 浅拷贝存在的问题: 对于引用类型只是拷贝其引用, 创建多个对象后引用类型都指向同一对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class WorkExperence&#123; private string workDate; public string WorkDate &#123; get&#123;return workDate;&#125; set&#123;workDate = value;&#125; &#125; public string company;&#125;class Resume : ICloneable&#123; private string name; private string sex; private string age; private WorkExperence work; public Resume(string name) &#123; this.name = name; work = new WorkExperence(); &#125; public void SetPersonalInfo(string sex, string age) &#123; this.sex = sex; this.age = age; &#125; public void SetWorkExperience(string timeArea, string company) &#123; work.WorkDate = timeArea; work.Company = company; &#125; public void Display() &#123; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, name, sex, age); Console.WriteLine(&quot;工作经历: &#123;0&#125; &#123;1&#125;&quot;, timeArea, company); &#125; public Object Clone() &#123; //浅拷贝--值类型:逐位复制, 引用类型只复制引用(指向同一对象) return (Object)this.MemberwiseClone(); &#125;&#125;//ClientResume a = new Resume(&quot;小a&quot;);a.SetPersonalInfo(&quot;男&quot;, &quot;21&quot;);a.SetWorkExperience(&quot;2021-2022&quot;, &quot;a公司&quot;);Resume b = (Resume)a.Clone();b.SetWorkExperience(&quot;2022-2023&quot;, &quot;b公司&quot;);//---引用类型重新赋值会覆盖原有值a.Display();b.Display(); 深拷贝需要考虑要深入到多少层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//深拷贝class WorkExperence : ICloneable&#123; private string workDate; public string WorkDate &#123; get&#123;return workDate;&#125; set&#123;workDate = value;&#125; &#125; public string company; public Object Clone() &#123; //浅拷贝--值类型:逐位复制, 引用类型只复制引用(指向同一对象) return (Object)this.MemberwiseClone(); &#125;&#125;class Resume : ICloneable&#123; private string name; private string sex; private string age; private WorkExperence work; public Resume(string name) &#123; this.name = name; work = new WorkExperence(); &#125; public Resume(WorkExperence work) &#123; this.work = (WorkExperence)work.Clone(); &#125; public void SetPersonalInfo(string sex, string age) &#123; this.sex = sex; this.age = age; &#125; public void SetWorkExperience(string timeArea, string company) &#123; work.WorkDate = timeArea; work.Company = company; &#125; public void Display() &#123; Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, name, sex, age); Console.WriteLine(&quot;工作经历: &#123;0&#125; &#123;1&#125;&quot;, timeArea, company); &#125; public Object Clone() &#123; //深拷贝 Resume obj = new Resume(this.work); obj.name = this.name; obj.sex = this.sex; obj.age = this.age; return obj; &#125;&#125;//ClientResume a = new Resume(&quot;小a&quot;);a.SetPersonalInfo(&quot;男&quot;, &quot;21&quot;);a.SetWorkExperience(&quot;2021-2022&quot;, &quot;a公司&quot;);Resume b = (Resume)a.Clone();b.SetWorkExperience(&quot;2022-2023&quot;, &quot;b公司&quot;);a.Display();b.Display();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-代理模式","slug":"设计模式-代理模式","date":"2023-08-29T08:57:32.000Z","updated":"2025-03-24T11:49:19.332Z","comments":true,"path":"设计模式-代理模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html","excerpt":"创建具有现有对象的对象，以便向外界提供功能接口。用于解决直接访问对象时带来的问题","text":"创建具有现有对象的对象，以便向外界提供功能接口。用于解决直接访问对象时带来的问题 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344interface IImage&#123; void Display();&#125;public class RealImage : IImage&#123; private string fileName; public RealImage(string fileName) &#123; this.fileName = fileName; LoadFromDisk(fileName); &#125; public void Display() &#123; //display &#125; private void LoadFromDisk(string fileName) &#123; //Load Image From Disk &#125;&#125;public class ProxyImage : IImage&#123; private RealImage realImage; private string fileName; public ProxyImage(string fileName) &#123; this.fileName = fileName; &#125; public void Display() &#123; if(realImage == null) realImage = new RealImage(fileName); realImage.Diaplay(); &#125;&#125;IImage image = new ProxyImage(&quot;test.jpg&quot;);// 图像将从磁盘加载image.display(); // 图像不需要从磁盘加载image.display();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略模式","slug":"设计模式-策略模式","date":"2023-08-29T08:12:13.000Z","updated":"2025-03-24T11:48:52.487Z","comments":true,"path":"设计模式-策略模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html","excerpt":"定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 策略模式相对简单工厂耦合度更低, 只需要开放一个类给客户端 无论是简单工厂还是策略模式都没有消除switch, 若想消除可用反射, 参考抽象工厂模式","text":"定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 策略模式相对简单工厂耦合度更低, 只需要开放一个类给客户端 无论是简单工厂还是策略模式都没有消除switch, 若想消除可用反射, 参考抽象工厂模式 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970interface IStrategy&#123; int DoOprea(int a, int b);&#125;public class OperaAdd : IStrategy&#123; public int DoOpera(int a, int b) &#123; return a + b; &#125;&#125;public class OperaSub : IStrategy&#123; public int DoOpera(int a, int b) &#123; return a - b; &#125;&#125;public class OperaMult : IStrategy&#123; public int DoOpera(int a, int b) &#123; return a * b; &#125;&#125;/************************策略模式*************************/public class Context&#123; private IStrategy strategy; public Context(IStrategy strategy) &#123; this.strategy = strategy; &#125; public int ExecuteStrategy(int a, int b) &#123; return strategy.DoOpera(a, b); &#125;&#125;Context context = new Context(new OperaAdd())context.ExecuteStrategy(1, 1);Context context = new Context(new OperaMult())context.ExecuteStrategy(1, 1);/********************************************************//************************简单工厂*************************/class OperaFactory&#123; public static IStrategy GetOpera(string type)&#123; IStrategy opera = null; if(type.EqualsIgnoreCase(&quot;+&quot;))&#123; opera = new OperaAdd(); &#125; else if(type.EqualsIgnoreCase(&quot;-&quot;))&#123; opera = new OperaSub(); &#125; else if(type.EqualsIgnoreCase(&quot;*&quot;))&#123; opera = new OperaMult(); &#125; return opera; &#125;&#125;IStrategy opera = ChartFactory.GetOpera(&quot;+&quot;);opera.DoOprea(1, 1);/********************************************************/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-装饰模式","slug":"设计模式-装饰模式","date":"2023-08-29T07:38:34.000Z","updated":"2025-03-24T11:48:46.488Z","comments":true,"path":"设计模式-装饰模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.html","excerpt":"装饰模式: 把所需的功能按正确的顺序串联起来 动态的给一个对象添加一些职责","text":"装饰模式: 把所需的功能按正确的顺序串联起来 动态的给一个对象添加一些职责 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Person&#123; public Person() &#123; &#125; private string name; public Person(string name) &#123; this.name = name; &#125; public virtual void Show() &#123; Console.Write(&quot;&#123;0&#125;穿着&quot;, name); &#125;&#125;class Finery : Person &#123; protected Person component; public void Decorate(Person component) &#123; this.component = component; &#125; public override void Show() &#123; component?.Show(); &#125;&#125;class TShirts : Finery&#123; public override void Show() &#123; base.Show(); Console.Write(&quot;T恤 &quot;); &#125;&#125;class BigTrouser : Finery&#123; public override void Show() &#123; base.Show(); Console.Write(&quot;垮裤 &quot;); &#125;&#125;class Silpper : Finery&#123; public override void Show() &#123; base.Show(); Console.Write(&quot;拖鞋 &quot;); &#125;&#125;//ClientPerson ps = new Person(&quot;小明&quot;);BigTrouser bt = new BigTrouser();TShirts ts = new TShirts();Silpper s = new Silpper();bt.Decorate(ps);ts.Decorate(bt);s.Decorate(ts);s.Show();/*小明穿着垮裤 T恤 拖鞋*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//java示例//接口public interface Shape &#123; void draw();&#125;//实现public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape: Rectangle&quot;); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape: Circle&quot;); &#125;&#125;//继承接口的抽象装饰类public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape)&#123; this.decoratedShape = decoratedShape; &#125; public void draw()&#123; decoratedShape.draw(); &#125; &#125;//继承抽象装饰的实现public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape);//扩展功能 &#125; private void setRedBorder(Shape decoratedShape)&#123; System.out.println(&quot;Border Color: Red&quot;); &#125;&#125;//Clientpublic class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(&quot;Circle with normal border&quot;); circle.draw(); System.out.println(&quot;\\nCircle of red border&quot;); redCircle.draw(); System.out.println(&quot;\\nRectangle of red border&quot;); redRectangle.draw(); &#125;&#125;/*Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red*/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Git设置git diff用Codecompare","slug":"Git设置git-diff用Codecompare","date":"2023-08-28T02:25:20.000Z","updated":"2025-03-24T11:40:47.257Z","comments":true,"path":"Git设置git-diff用Codecompare.html","link":"","permalink":"https://silencejql.github.io/Git%E8%AE%BE%E7%BD%AEgit-diff%E7%94%A8Codecompare.html","excerpt":"","text":"Git配置 打开.gitconfig 123456789101112131415[difftool &quot;codecompare&quot;]cmd = \\&quot;C:\\\\Program Files\\\\Devart\\\\Code Compare\\\\CodeCompare.exe\\&quot; -W \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot;renames = true[diff]tool = codecompareguitool = codecompare[mergetool &quot;codecompare&quot;]cmd = \\&quot;C:\\\\Program Files\\\\Devart\\\\Code Compare\\\\CodeMerge.exe\\&quot; -MF \\&quot;$LOCAL\\&quot; -TF \\&quot;$REMOTE\\&quot; -BF \\&quot;$BASE\\&quot; -RF \\&quot;$MERGED\\&quot;trustExitCode = true[mergetool]keepBackup = false[merge]tool = codecompareguitool = codecompare","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"设计模式-抽象工厂","slug":"设计模式-抽象工厂","date":"2023-08-17T03:47:03.000Z","updated":"2025-03-24T11:48:59.728Z","comments":true,"path":"设计模式-抽象工厂.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html","excerpt":"抽象工厂, 将工厂抽象出来 工厂方法模式和抽象工厂模式都是创建型设计模式，它们的主要区别在于所创建的对象范围不同。 工厂方法模式（Factory Method）通过让子类实现工厂接口，来决定具体应该创建哪一个产品类的实例对象。它允许我们在不改变现有代码基础上添加新的产品类型，并且可以将具体产品的实现与调用方分离开来。 抽象工厂模式（Abstract Factory）与工厂方法模式类似，也是用于创建一系列相关的对象。不同之处在于，抽象工厂是针对多个产品族而言的，即每个工厂可以创建多种不同类型的产品。这样的话，抽象工厂为创建一组相关或独立的对象提供了一种方式。 工厂方法模式通常只针对一个抽象产品类进行创建，而抽象工厂模式则需要针对多种抽象产品进行创建。","text":"抽象工厂, 将工厂抽象出来 工厂方法模式和抽象工厂模式都是创建型设计模式，它们的主要区别在于所创建的对象范围不同。 工厂方法模式（Factory Method）通过让子类实现工厂接口，来决定具体应该创建哪一个产品类的实例对象。它允许我们在不改变现有代码基础上添加新的产品类型，并且可以将具体产品的实现与调用方分离开来。 抽象工厂模式（Abstract Factory）与工厂方法模式类似，也是用于创建一系列相关的对象。不同之处在于，抽象工厂是针对多个产品族而言的，即每个工厂可以创建多种不同类型的产品。这样的话，抽象工厂为创建一组相关或独立的对象提供了一种方式。 工厂方法模式通常只针对一个抽象产品类进行创建，而抽象工厂模式则需要针对多种抽象产品进行创建。 示例为实现切换不同数据库 原程序 12345678910111213141516171819202122232425262728293031323334//User表class User&#123; private int id; public int ID &#123; get&#123;return id;&#125; set&#123;id = ID;&#125; &#125; private string name; public string Name &#123; get&#123;return name;&#125; set&#123;name = value;&#125; &#125;&#125;//SQLServer操作User表class SqlServerUser&#123; public void Insert(User user) &#123; Console.WriteLine(&quot;在SQLServer中增加一条记录&quot;); &#125; public User GerUser(int id) &#123; Console.WriteLine(&quot;在SQLServer中根据ID获取User表的一条记录&quot;) return null; &#125;&#125;//ClientUser user = new User();SqlServerUser su = new SqlServerUser();//--此处定义了必须是SQL无法直接替换其他类型数据库su.Insert(user);su.GetUser(1); 工厂方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface IUser&#123; void Insert(User user); User GetUser(int id);&#125;class SqlServerUser : IUser&#123; public void Insert(User user) &#123; Console.WriteLine(&quot;在SQLServer中增加一条记录&quot;); &#125; public User GerUser(int id) &#123; Console.WriteLine(&quot;在SQLServer中根据ID获取User表的一条记录&quot;) return null; &#125;&#125;class AccessUser : IUser&#123; public void Insert(User user) &#123; Console.WriteLine(&quot;在Access中增加一条记录&quot;); &#125; public User GerUser(int id) &#123; Console.WriteLine(&quot;在Access中根据ID获取User表的一条记录&quot;) return null; &#125;&#125;interface IFactory&#123; IUser CreateUser();&#125;class SqlserverFactory : IFactory&#123; public IUser CreateUser() &#123; return new SqlserverUser(); &#125;&#125;class AccessFactory : IFactory&#123; public IUser CreateUser() &#123; return new AccessUser(); &#125;&#125;//ClientUser user = new User();IFactory factory = new SqlserverFactory();IUser iu = factory.CreateUser();iu.Insert(user);iu.GetUser(1); 抽象工厂 工厂方法模式通常只针对一个抽象产品类进行创建，而抽象工厂模式则需要针对多种抽象产品进行创建。 随着表的增多(比如增加一个Department部门表), 需要增加很多类(IDepartment, SqlserverDepartment, AccessDepartment), 还要修改很多类(IFactory, SqlserverFactory, AccessFactory)增加接口函数 简单工厂优化抽象工厂 12345678910111213141516171819202122232425262728293031323334353637383940414243class DataAccess&#123; private static readonly string db = &quot;Sqlserver&quot;; public static IUser CreateUser() &#123; IUser user = null; switch(db) &#123; case &quot;Sqlserver&quot;: user = new SqlserverUser(); break; case &quot;Access&quot;: user = new AccessUser(); break; &#125; return user; &#125; public static IDepartment CreateDepartment() &#123; IDepartment deparement = null; switch(db) &#123; case &quot;Sqlserver&quot;: deparement = new SqlserverDeparement(); break; case &quot;Access&quot;: deparement = new AccessDeparement(); break; &#125; return deparement; &#125;&#125;//ClientUser user = new User();Department department = new Department();IUser iu = DataAccess.CreateUser();iu.Insert(user);iu.GetUser(1);IDepartment id = DataAccess.CreateDepartment();id.Insert(department);id.GetDepartment(1); 简单工厂去除了工厂类, 比如但若是增加Oracle数据库的访问, 抽象工厂只需要增加OracleFactory, 简单工厂却需要更改DataAccess类中的case 反射+抽象工厂 12345678910111213141516171819202122232425262728using System.Reflection;class DataAccess&#123; private static readonly string assemblyName = &quot;抽象工厂模式&quot;;//程序集名 private static readonly string db = &quot;Sqlserver&quot;;//--可放在配置文件中实现真正的开闭原则 public static IUser CreateUser() &#123; string className = assemblyName + &quot;.&quot; + db + &quot;User&quot;; return (IUser)Assembly.Load(assemblyName).CreateInstance(className); &#125; public static IDepartment CreateDepartment() &#123; string className = assemblyName + &quot;.&quot; + db + &quot;Department&quot;; return (IDepartment)Assembly.Load(assemblyName).CreateInstance(className); &#125;&#125;//ClientUser user = new User();Department department = new Department();IUser iu = DataAccess.CreateUser();iu.Insert(user);iu.GetUser(1);IDepartment id = DataAccess.CreateDepartment();id.Insert(department);id.GetDepartment(1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170//java抽象工厂示例//为形状创建一个接口public interface Shape &#123; void draw();&#125;//创建实现接口的实体类public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125;//为颜色创建一个接口public interface Color &#123; void fill();&#125;//创建实现接口的实体类public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125;public class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125;public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125;//为 Color 和 Shape 对象创建抽象类来获取工厂public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape);&#125;//创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125;public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125;//创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125;//Clientpublic class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;GREEN&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125;/*Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method.*/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-工厂方法","slug":"设计模式-工厂方法","date":"2023-08-17T03:20:44.000Z","updated":"2025-03-24T11:49:07.238Z","comments":true,"path":"设计模式-工厂方法.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.html","excerpt":"一个工厂类只创建一个产品 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 将所要创建的具体对象放在子类, 实现扩展(非更改)","text":"一个工厂类只创建一个产品 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 将所要创建的具体对象放在子类, 实现扩展(非更改) 简单工厂实现 123456789101112131415161718192021222324252627282930313233interface ILogger&#123; public void WriteLog();&#125;class DatabaseLogger : ILogger&#123; public void WriteLog()&#123; &#125;&#125;class FileLogger : ILogger&#123; public void WriteLog()&#123; &#125;&#125;class LoggerFactory&#123; public static Logger CreateLogger(string args)&#123; if(args.EqualsIgnoreCase(&quot;db&quot;))&#123; //连接数据库 //创建对象 ILogger logger = new DatabaseLogger(); //初始化数据库 return logger; &#125; else if(args.EqualsIgnoreCase(&quot;file&quot;))&#123; //创建日志文件 //创建对象 ILogger logger = new FileLogger(); //初始化日志文件 return logger; &#125; else return null; &#125;&#125; 缺点 新增产品必须修改工厂类, 违反开闭原则; 所有产品都由同一工厂创建,职责重,逻辑复杂,耦合度高 工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行 工厂方法 定义一个用于创建对象的接口, 让子类决定实例化哪个类 12345678910111213141516171819202122232425262728293031323334353637383940414243interface ILogger&#123; public void WriteLog();&#125;class DatabaseLogger : ILogger&#123; public void WriteLog()&#123; //数据库记录日志 &#125;&#125;class FileLogger : ILogger&#123; public void WriteLog()&#123; //文件记录日志 &#125;&#125;interface ILoggerFactory&#123; public ILogger CreateLogger();&#125;class DatabaseLoggerFactory : ILoggerFactory&#123; public ILogger CreateLogger()&#123; //连接数据库 //创建对象 Logger logger = new DatabaseLogger(); //初始化数据库 return logger; &#125;&#125;class FileLoggerFactory : ILoggerFactory&#123; public ILogger CreateLogger()&#123; //连接数据库 //创建对象 Logger logger = new FileLogger(); //初始化数据库 return logger; &#125;&#125;class Client&#123; ILoggerFactory factory; ILogger logger; factory = new FileLoggerFactory(); logger = factory.CreateLogger(); logger.WriteLog();&#125; 123456789101112131415161718192021222324252627interface ILogger&#123; public void WriteLog();&#125;class DatabaseLogger : ILogger&#123; public void WriteLog()&#123; &#125;&#125;class FileLogger : ILogger&#123; public void WriteLog()&#123; &#125;&#125;class Logger(ILogger logger)&#123; private logger; public Logger(ILogger logger)&#123; this.logger = logger; &#125; public void WriteLog()&#123; logger.WriteLog(); &#125;&#125;class Client&#123; var logger = Logger(new DatabaseLogger()); logger.WriteLog();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-简单工厂","slug":"设计模式-简单工厂","date":"2023-08-17T03:01:23.000Z","updated":"2025-03-24T11:48:49.123Z","comments":true,"path":"设计模式-简单工厂.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.html","excerpt":"一个工厂类创建所有产品","text":"一个工厂类创建所有产品 初始方案 1234567891011121314151617181920212223242526272829class Chart&#123; private string type; public Chart(object[][] data, string type)&#123; this.type = type; if(type.EqualsIgnoreCase(&quot;histogram&quot;))&#123; //柱状图 &#125; else if(type.EqualsIgnoreCase(&quot;pie&quot;))&#123; //饼图 &#125; else if(type.EqualsIgnoreCase(&quot;line&quot;))&#123; //折线图 &#125; &#125; public Display()&#123; if(type.EqualsIgnoreCase(&quot;histogram&quot;))&#123; //显示柱状图 &#125; else if(type.EqualsIgnoreCase(&quot;pie&quot;))&#123; //显示饼图 &#125; else if(type.EqualsIgnoreCase(&quot;line&quot;))&#123; //显示折线图 &#125; &#125;&#125; 简单工厂 定义一个类, 可根据不同参数返回不同类的实例 12345678910111213141516171819202122232425262728293031323334353637383940interface IChart&#123; public void Display();&#125;class HistogramChart : IChart&#123; public HistogramChart()&#123; //创建柱状图 &#125; public void Display()&#123; //显示柱状图 &#125;&#125;class PieChart : IChart&#123; public PieChart()&#123; //创建饼图 &#125; public void Display()&#123; //显示饼图 &#125;&#125;class ChartFactory&#123; public static IChart GetChart(string type)&#123; IChart chart = null; if(type.EqualsIgnoreCase(&quot;histogram&quot;))&#123; chart = new HistogramChart(); &#125; else if(type.EqualsIgnoreCase(&quot;pie&quot;))&#123; chart = new PieChart(); &#125; return chart; &#125;&#125;class Client&#123; Chart chart = ChartFactory.GetChart(&quot;pie&quot;); chart.Display();&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2023-08-07T11:33:57.000Z","updated":"2025-03-24T11:40:39.237Z","comments":true,"path":"Git常用命令.html","link":"","permalink":"https://silencejql.github.io/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","excerpt":"基础命令 123456789101112131415161718git commit --amend #合并并修改上次提交git tag v1.0.0git tag -a v1.0.0 -m &quot;Release version 1.0.0&quot; HEADgit push origin &#123;标签名&#125;git push origin --tagsgit branch -D master #删除master分支git branch -m master #重新命名当前独立分支为 mastergit log --oneline --graph --all -5 #查看所有分支的图形记录的前5条git merge branchName #合并branchName分支到当前分支git merge branchName -Xignore-space-change whitespace #合并branchName分支到当前分支并忽略空白符git fetch origin master:temp #从远程的origin仓库的master分支下载到本地并新建一个分支tempgit diff temp #比较master分支和temp分支的不同","text":"基础命令 123456789101112131415161718git commit --amend #合并并修改上次提交git tag v1.0.0git tag -a v1.0.0 -m &quot;Release version 1.0.0&quot; HEADgit push origin &#123;标签名&#125;git push origin --tagsgit branch -D master #删除master分支git branch -m master #重新命名当前独立分支为 mastergit log --oneline --graph --all -5 #查看所有分支的图形记录的前5条git merge branchName #合并branchName分支到当前分支git merge branchName -Xignore-space-change whitespace #合并branchName分支到当前分支并忽略空白符git fetch origin master:temp #从远程的origin仓库的master分支下载到本地并新建一个分支tempgit diff temp #比较master分支和temp分支的不同 版本回退 123456789101112131415161718192021222324252627git reset --soft HEAD~3 #文件不会被修改，后三次提交被 git add 添加到暂存区，相当于只撤销了 git commitgit reset --mixed HEAD~3 #文件不会被修改，但后三次提交没有添加到暂存区, 回退到工作区git reset --hard HEAD~3 #文件会被回退到 HEAD~3 时的状态git revert #撤销一个提交的同时会创建一个新的提交git revert HEAD~2 #会创建一个新的提交来撤销前两个提交的更改，然后把新的提交加入提交历史#git revert 可以用在公共分支上，git reset 应该用在私有分支上。#也可以把 git revert 用作撤销已经 push 的更改#而 git reset 用来撤销已经 commit 但没有 push 的更改##或者 git reset HEAD 撤销没有 commit 的更改#将最近一次提交节点的提交记录回退到工作区#用于修改上次提交git reset --mixed HEAD~1 #回退到工作区#查看可引用的历史版本记录#用于恢复reset, 直接执行git reset commitId恢复到工作区git reflog #将最近一次提交节点的提交记录全部清除#用于删除上次提交git reset --hard HEAD^ #删除#rebase可精简commitgit rebase -i HEAD~n","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"CSharp bit循环移位","slug":"CSharp-bit循环移位","date":"2023-07-31T07:38:23.000Z","updated":"2025-03-24T11:40:16.378Z","comments":true,"path":"CSharp-bit循环移位.html","link":"","permalink":"https://silencejql.github.io/CSharp-bit%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D.html","excerpt":"","text":"示例 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 循环移位/// &lt;/summary&gt;/// &lt;param name=&quot;val&quot;&gt;输入的数字&lt;/param&gt;/// &lt;param name=&quot;iShiftBit&quot;&gt;要移几位&lt;/param&gt;/// &lt;param name=&quot;isLeft&quot;&gt;移位的方向&lt;/param&gt;/// &lt;returns&gt;移位后的数字&lt;/returns&gt;private static uint CycleShift(uint val, int iShiftBit, bool isLeft)&#123; uint temp = 0; uint result = 0; temp |= val; if (isLeft) &#123; val &lt;&lt;= iShiftBit; temp &gt;&gt;= (32 - iShiftBit); result = val | temp; &#125; else &#123; val &gt;&gt;= iShiftBit; temp &lt;&lt;= (32 - iShiftBit); result = val | temp; &#125; return result;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp复习-子线程更新MainForm","slug":"CSharp复习-子线程更新MainForm","date":"2023-07-17T03:44:41.000Z","updated":"2025-03-24T11:40:31.659Z","comments":true,"path":"CSharp复习-子线程更新MainForm.html","link":"","permalink":"https://silencejql.github.io/CSharp%E5%A4%8D%E4%B9%A0-%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0MainForm.html","excerpt":"","text":"示例 12345678910111213141516171819Thread update;public Form1()&#123; InitializeComponent(); update = new Thread(UpdateFunc);&#125;//子线程更新主界面Label值void UpdateFunc()&#123; while (true) &#123; Invoke(()=&gt; label1.Text = DateTime.Now.ToString(&quot;HH:mm:ss&quot;)); Invoke((string x)=&gt; label1.Text = x + DateTime.Now.ToString(&quot;HH:mm:ss&quot;),&quot;时间:&quot;); Thread.Sleep(500); &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp Semaphore 信号量","slug":"CSharp-Semaphore-信号量","date":"2023-07-14T07:46:15.000Z","updated":"2025-03-24T11:40:25.097Z","comments":true,"path":"CSharp-Semaphore-信号量.html","link":"","permalink":"https://silencejql.github.io/CSharp-Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F.html","excerpt":"限制可同时访问某一资源或资源池的线程数 Semaphore sema = new Semaphore(x,y) x: 线程池中空位数 y: 线程池的总数","text":"限制可同时访问某一资源或资源池的线程数 Semaphore sema = new Semaphore(x,y) x: 线程池中空位数 y: 线程池的总数 WaitOne 阻止当前线程，直到当前线程的WaitHandle 收到信号 Release 退出信号量并返回前一个计数 示例 排队 12345678910111213141516171819202122232425using System.Threading;public class Program&#123; static Semaphore sema = new Semaphore(5, 5);//线程池中无线程, 最多同时执行5个线程 const int cycleNum = 9; static void Main(string[] args) &#123; for(int i = 0; i &lt; cycleNum; i++) &#123; Thread td = new Thread(new ParameterizedThreadStart(testFun)); td.Name = string.Format(&quot;&#123;0&#125;&quot;,i.ToString()); td.Start(td.Name); &#125; Console.ReadKey(); &#125; public static void testFun(object obj) &#123; sema.WaitOne(); Console.WriteLine(obj.ToString() + &quot;进入：&quot; + DateTime.Now.ToString()); Thread.Sleep(2000); Console.WriteLine(obj.ToString() + &quot;离开：&quot; + DateTime.Now.ToString()); sema.Release(); &#125;&#125; Leetcode打印零与奇偶数 输入：n = 5 输出：“0102030405” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System.Threading;public class ZeroEvenOdd &#123; private int n; public Semaphore semaphore = new Semaphore(1, 1);//奇数偶数打印完解锁 public Semaphore semaphore2 = new Semaphore(0, 1);//0打印完解锁打印奇数 public Semaphore semaphore3 = new Semaphore(0, 1);//0打印完解锁打印偶数 public ZeroEvenOdd(int n) &#123; this.n = n; &#125; // printNumber(x) outputs &quot;x&quot;, where x is an integer. public void Zero(Action&lt;int&gt; printNumber) &#123; for(int i=0;i&lt;n;i++) &#123; semaphore.WaitOne(); printNumber(0); if(i%2 == 0) &#123; semaphore2.Release(); &#125; else &#123; semaphore3.Release(); &#125; &#125; &#125; public void Even(Action&lt;int&gt; printNumber) &#123; for(int i=2;i&lt;=n;i=i+2) &#123; semaphore3.WaitOne(); printNumber(i); semaphore.Release(); &#125; &#125; public void Odd(Action&lt;int&gt; printNumber) &#123; for(int i=1;i&lt;=n;i=i+2) &#123; semaphore2.WaitOne(); printNumber(i); semaphore.Release(); &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"VSCode CMake","slug":"VSCode-CMake","date":"2023-05-19T04:46:34.000Z","updated":"2023-05-19T04:46:34.206Z","comments":true,"path":"VSCode-CMake.html","link":"","permalink":"https://silencejql.github.io/VSCode-CMake.html","excerpt":"写在前面 前面啥也没有","text":"写在前面 前面啥也没有","categories":[],"tags":[]},{"title":"Winform动态更改Combox等宽度","slug":"Winform动态更改Combox等宽度","date":"2023-04-17T08:06:20.000Z","updated":"2025-03-24T11:40:04.850Z","comments":true,"path":"Winform动态更改Combox等宽度.html","link":"","permalink":"https://silencejql.github.io/Winform%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9Combox%E7%AD%89%E5%AE%BD%E5%BA%A6.html","excerpt":"前面啥也没有","text":"前面啥也没有 实现 加载界面时根据内容更改宽度 123456789101112131415161718int DropDownWidth(ComboBox myCombo)&#123; int maxWidth = 0, temp = 0; foreach (var obj in myCombo.Items) &#123; temp = TextRenderer.MeasureText(obj.ToString(), myCombo.Font).Width; if (temp &gt; maxWidth) &#123; maxWidth = temp; &#125; &#125; return maxWidth;&#125;//LinqcomboBox1.DropDownWidth = comboBox1.Items.Cast&lt;string&gt;().Max(x =&gt; TextRenderer.MeasureText(x, comboBox1.Font).Width); 扩展 Linq Cast Cast操作符 Cast操作符用于将一个类型为IEnumerable的集合对象转换为IEnumerable&lt;\\T&gt;类型的集合对象。也就是非泛型集合转成泛型集合，因为在Linq to OBJECT中，绝大部分操作符都是针对IEnumerable&lt;\\T&gt;类型进行的扩展方法。因此对非泛型集合并不适用。 123456789ArrayList al = new ArrayList();al.Add(1);al.Add(2);al.Add(3);IEnumerable&lt;int&gt; IEInt = al.Cast&lt;int&gt;(); //非泛型转泛型foreach (var i in IEInt)&#123; Console.WriteLine(i); &#125; OfType操作符 OfType操作符与Cast操作符类似，用于将类型为IEnumerable的集合对象转换为IEnumerable&lt;\\T&gt;类型的集合对象。不同的是，Cast操作符会视图将输入序列中的所有元素转换成类型为T的对象,如果有转换失败的元素存在Cast操作符将抛出一个异常；而OfType操作符仅会将能够成功转换的元素进行转换，并将这些结果添加到结果序列中去。与Cast操作符相比，OfType操作符更加安全。 1234567891011121314ArrayList al = new ArrayList();al.Add(1);al.Add(2);al.Add(&quot;a&quot;);//IEnumerable&lt;int&gt; IECast = al.Cast&lt;int&gt;(); //抛出异常//foreach (var i in IECast)//&#123;// Console.WriteLine(i);//&#125;IEnumerable&lt;int&gt; IEOfType = al.OfType&lt;int&gt;();foreach (int i in IEOfType)&#123; Console.WriteLine(i); //输出 1 2 其中转换不了的a则不转换 &#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"DoIP协议解读","slug":"DoIP协议解读","date":"2023-03-16T05:48:25.000Z","updated":"2025-03-07T12:19:51.475Z","comments":true,"path":"DoIP协议解读.html","link":"","permalink":"https://silencejql.github.io/DoIP%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB.html","excerpt":"ISO13400","text":"ISO13400 帧格式 ProtocolVersion InverseProtocolVersion PayloadType PayloadLength DoIPPayload 协议版本信息 协议版本信息按位取反 有效数据类型 有效数据长度 SA TA UserData 1Byte 1Byte 2Byte 4Byte 源地址(2Byte)目标地址(2Byte)UDS数据 0x01:DoIp13400-2010 ^ProtocolVersion 0x8001:DiagnosticMessage 0x02:DoIp13400-2012 ^ProtocolVersion 0x8002:DiagnosticMessagePositiveAcknowledgement 0x03~0xFE:DoIp13400-xxxx ^ProtocolVersion 0x8003:DiagnosticMessageNegativeAcknowledgement 0xFF ^ProtocolVersion 0x0005:RoutingActivationRequest 0x0006:RoutingActivationRespose 0x0007:AliveCheckRequest 0x0008:AliveCheckReponse 02 FD 8001 00000006 0E800304 1003 关于数据类型参考:https://blog.csdn.net/weixin_42967006/article/details/121638078 源地址 0x0E00-0x0E7F用于OBD诊断，0x0E80-0x0EFF用于增强型诊断 物理逻辑地址，在0x0001-0x0DFF或0x1000-0x7FFF范围内 功能寻址，是0xE000 示例 02 FD 0005 0000000B 0E80 000000000000000000 //请求路由激活 02 FD 0006 000000XX XXXX XXXX XXXX YY XX… //收到回复YY=0x10表示成功 02 FD 8001 00000006 0E800304 1003 //进入诊断模式 02 FD 8002 000000XX 03040E80 5003XXXX… //收到正反馈 参考","categories":[],"tags":[{"name":"DoIP","slug":"DoIP","permalink":"https://silencejql.github.io/tags/DoIP/"}]},{"title":"Ubuntu Docker 搭建Gitlab","slug":"Ubuntu-Docker-搭建Gitlab","date":"2023-03-16T02:56:30.000Z","updated":"2025-03-07T12:19:28.668Z","comments":true,"path":"Ubuntu-Docker-搭建Gitlab.html","link":"","permalink":"https://silencejql.github.io/Ubuntu-Docker-%E6%90%AD%E5%BB%BAGitlab.html","excerpt":"Ubuntu下基于Docker搭建Gitlab","text":"Ubuntu下基于Docker搭建Gitlab Docker 安装如下或自行搜索 12345678910111213141516171819202122//来添加新的 HTTPS 软件源sudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common//导入源仓库的 GPG keysudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;//安装 Docker 最新版本sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io//安装完成，Docker 服务将会自动启动, 如下为手动启动sudo systemctl enable dockersudo systemctl start docker//你可以输入下面的命令，验证sudo systemctl status docker输出如下:docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2020-05-21 14:47:34 UTC; 42s **ago**// 部署Gitlab 创建容器外挂目录 123sudo mkdir -p /gitlab/datasudo mkdir -p /gitlab/logssudo mkdir -p /gitlab/config 启动容器 123456789sudo docker run --detach \\ --publish 8443:433 --publish 8000:80 --publish 2222:22 \\ --name gitlab \\ --restart always \\ --volume /gitlab/config:/etc/gitlab \\ --volume /gitlab/logs:/var/log/gitlab \\ --volume /gitlab/data:/var/opt/gitlab \\ -log-driver=none \\ beginor/gitlab-ce 说明: –detach 设置容器后台运行 –publish 暴露 https、http和ssh端口,关于端口下文会细说 –name 容器名称 –restart always 每次启动容器就重启GitLab –volume 设置GitLab数据挂载点 查询Docker状态 12//status=starting表示正在启动, 启动成功转为healthsudo docker ps 配置Gitlab 配置文件位于/gitlab/config/gitlab.rb中 修改external_url, 外部访问地址 修改gitlab_shell_ssh_port --不修改每次访问都需要输入密码 修改nginx监听端口 Docker常用命令 123sudo docker startsudo docker restartsudo docker stop 登录gitlab gitlab启动后浏览器输入IP:8000后进入登录界面 用户名:root 获取默认密码: sudo docker exec -it gitlab grep 'Password:' /etc/'gitlab/initial_root_password 登录后点击右上角Edit profile更改密码 使用Gitlab 添加组Group和用户 新建项目Project 使用 123git remote add origin http://IP:8000/groupName/projectName.gitgit branch -M maingit push -uf origin main","categories":[],"tags":[{"name":"GitLab","slug":"GitLab","permalink":"https://silencejql.github.io/tags/GitLab/"}]},{"title":"Git复习","slug":"Git复习","date":"2023-03-14T03:21:36.000Z","updated":"2025-03-24T11:39:47.276Z","comments":true,"path":"Git复习.html","link":"","permalink":"https://silencejql.github.io/Git%E5%A4%8D%E4%B9%A0.html","excerpt":"日复一日,必有精进 官方手册https:#git-scm.com/docs","text":"日复一日,必有精进 官方手册https:#git-scm.com/docs 创建 12345git init #初始化git init gitDicName #指定初始化文件夹git clone https:#github.com/.git #从现有仓库中拷贝项目git clone https:#github.com/.git gitDicName 配置 12345678#提交时会记录信息git config --global user.name &quot;myUserName&quot; #设置用户名git config --global user.email &quot;myEmail@Email.com&quot; #设置邮箱#配置简写git config --global alias.logg &quot;log --oneline --graph&quot;git config -l #查看配置 基础使用 123456789101112131415161718192021222324252627282930313233343536git init #初始化仓库git add . #添加文件置暂存区git commit -m &quot;repoInit and add files&quot; #提交到本地仓库git commit --amend #合并两次提交为一次(第一次commit漏掉某个文件后add完执行amend进行合并提交)#Commit规范#&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;#如 feat(miniprogram): 增加了小程序模板消息相关功能#type#feat - 新功能 feature#fix - 修复 bug#docs - 文档注释#style - 代码格式(不影响代码运行的变动)#refactor - 重构、优化(既不增加新功能，也不是修复bug)#perf - 性能优化#test - 增加测试#chore - 构建过程或辅助工具的变动#revert - 回退#build - 打包git push #上传到远程仓库git status #参看仓库状态, 显示文件变更等信息git status -s #参看仓库状态, for shortgit diff #比较暂存区和工作区文件区别git diff branch1 branch2 --statgit log #查看记录git log --oneline #查看记录,简短git log --oneline --graph #线性记录简短git log --oneline --graph --all -5 #查看所有分支的图形记录的前5条git blame README #查看文件修改记录git rm #从工作区和暂存区中删除文件ls #列出文件 分支 1234567891011121314151617181920212223242526git branch branchName #创建分支branchNamegit checkout branchName #切换当亲分支到branchName分支git checkout -b branchName #创建并切换到branchName分支git branch #查看本地分支git branch -r #查看远程分支git branch -a #查看本地和远程分支git checkout mastergit merge branchName #合并branchName分支到master分支git branch -d branchName #删除branchName分支git branch -d -r branchName #删除远程branchName分支git tag #查看taggit tag v1.0.0 #创建taggit tag -a v1.0.0 -m &quot;Release version 1.0.0&quot; HEAD#tag标签需要主动推送git push origin &#123;标签名&#125;git push origin --tags #推送所有taggit tag -d &#123;标签名&#125; #删除taggit push origin :refs/tags/&#123;标签名&#125; #删除远程tag Remote 1234567891011121314151617181920212223242526git remote add origin git@gitee.com:silencejql/git-practice-repo.git #添加远程仓库并起名为origingit push 远程主机名 远程分支名:本地分支名 #如果本地分支名与远程分支名相同，则可以省略冒号git push --force origin master #如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数git push -u origin master #提交到远程仓库origin的master分支git remote #查看远程仓库git remote -v #查看远程仓库细节git fatch #从远程仓库下载到本地(并不合并至本地仓库)git merge #从远程仓库提取并合并到当前分支git pull = git fetch + git mergegit pull 远程主机名 远程分支名:本地分支名 #如果本地分支名与远程分支名相同，则可以省略冒号git fetch origin git fetch origin master #从远程的origin仓库的master分支下载代码到本地的origin/master Repository中(不可修改)git chechout -b tmp origion/master #新建分支指向拉取的master分支git merge origin/master #把远程下载下来的代码合并到本地仓库，远程的和本地的合并git merge -Xignore-space-change whitespace #忽略空白符git merge --abort #退出合并模式(进入git merge后必须解决冲突后才可执行其他操作)git fetch origin master:temp #从远程的origin仓库的master分支下载到本地并新建一个分支tempgit diff temp #比较master分支和temp分支的不同 git branch -d temp #删除temp 版本回退 123456789101112131415161718192021222324252627282930313233343536#git stash 若不保存就不可以执行切换分支等操作 #stash执行后下次切换到当前分支后不包含所保存的修改#stash pop后才会恢复修改后的内容git stash #对没有提交到版本库的，位于工作区或暂存区中游离的修改进行保存，在需要时可进行恢复git stash list #查看该分支上被stash保存的修改git stash pop #恢复并删除stash中存储的最新修改git stash apply #恢复但不删除stash中存储的最新修改git stash apply stash@&#123;0&#125; #恢复但不删除stash中存储的特定提交git log #查看版本日志(版本号)git reset --soft HEAD^：将最近一次提交节点的提交记录回退到暂存区git reset --mixed HEAD^：将最近一次提交节点的提交记录回退到工作区git reset --hard HEAD^：将最近一次提交节点的提交记录全部清除git reset --hard HEAD #当前版本git reset --hard HEAD^ #上一个版本git reset --hard HEAD^^ #上上个版本--以此类推^^^git reset --hard HEAD~1 #上一个版本git git reset --hard HEAD~n #上n个版本git reset --hard 8b416 #退回git log中指定的版本号(前几位即可)git revert 8b416 #版本回滚创建新的提交来舍弃不要的提交--会保留所有记录--用法同resetgit rebase -i HEAD~n #rebase可精简commitgit rebase -i starthash endhash #合并后生成一个临时分支git checkout -b tmp #生成分支后续rebase或者直接用临时分支hashcodegit checkout mastergit rebase tmp #重新rebasegit push -f #合并后强制推送到Remote 清空Commit 1234567git checkout --orphan new_branch #基于当前分支创建一个独立的分支new_branchgit add -Agit commit -am &quot;commit message&quot;git branch -D master #删除master分支git branch -m master #重新命名当前独立分支为 mastergit push -f origin master #推送到远端分支,强制覆盖","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"CSharp执行外部exe","slug":"CSharp执行外部exe","date":"2023-03-02T05:15:03.000Z","updated":"2025-03-24T11:39:38.093Z","comments":true,"path":"CSharp执行外部exe.html","link":"","permalink":"https://silencejql.github.io/CSharp%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8exe.html","excerpt":"前面啥也没有","text":"前面啥也没有 示例 123456789101112131415161718192021222324252627282930313233public void ExecuteWithOutput(string path, string exeName)//执行外部exe文件；&#123; try &#123; if (!System.IO.File.Exists(path + exeName + &quot;\\\\&quot; + exeName + &quot;.exe&quot;)) &#123; xErrorOutException(new Exception(&quot;请确认&quot; + exeName + &quot;文件路径配置是否正确&quot;)); return; &#125; //Process ps = Process.Start(cmdExe); //ps.WaitForExit(); using (System.Diagnostics.Process cmdProcess = new System.Diagnostics.Process()) &#123; System.Diagnostics.ProcessStartInfo psi = new System.Diagnostics.ProcessStartInfo(); psi.UseShellExecute = false; psi.RedirectStandardInput = true; psi.RedirectStandardOutput = true; psi.RedirectStandardError = true; psi.CreateNoWindow = true; psi.FileName = path + exeName + &quot;\\\\&quot; + exeName + &quot;.exe&quot;; psi.WorkingDirectory = path + exeName + &quot;\\\\&quot;; cmdProcess.StartInfo = psi; cmdProcess.Start(); //string output = cmdProcess.StandardOutput.ReadToEnd(); cmdProcess.WaitForExit(); cmdProcess.Dispose(); &#125; &#125; catch(Exception ex) &#123; xErrorOutException(ex); &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp删除文件或文件夹","slug":"CSharp删除文件或文件夹","date":"2023-03-02T05:01:58.000Z","updated":"2025-03-24T11:39:33.673Z","comments":true,"path":"CSharp删除文件或文件夹.html","link":"","permalink":"https://silencejql.github.io/CSharp%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9.html","excerpt":"前面啥也没有","text":"前面啥也没有 删除文件 12345678910111213141516171819202122232425public void DeleteFiles(string path)&#123; try &#123; string[] files = Directory.GetFiles(path); List&lt;string&gt; picFiles = new List&lt;string&gt;(); foreach (string f in files) &#123; string fileName = Path.GetFileName(f); if (fileName.ToUpper().Contains(&quot;LW&quot;)) picFiles.Add(f); &#125; picFiles.ForEach((f) =&gt; &#123; FileInfo fi = new FileInfo(f); DateTime dtWrite = fi.LastWriteTime; if ((DateTime.Now - dtWrite).Days &gt; deleteDays) fi.Delete(); &#125;); &#125; catch (System.Exception ex) &#123; &#125;&#125; 删除文件夹 1234567string[] directories = Directory.GetDirectories(path);directories.ToList().ForEach((dir) =&gt;&#123; if ((DateTime.Now - Directory.GetLastWriteTime(dir)).Days &gt; deleteDays) Directory.Delete(dir, true);&#125;);","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2023-02-23T06:48:59.000Z","updated":"2025-03-24T11:58:58.188Z","comments":true,"path":"设计模式-单例模式.html","link":"","permalink":"https://silencejql.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html","excerpt":"单例模式,降低对象之间的耦合度","text":"单例模式,降低对象之间的耦合度 实现: 确保一个类只有一个实例,并提供一个访问它的全局访问点 示例 12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt;/// 单例模式的实现/// &lt;/summary&gt;public class Singleton&#123; // 定义一个静态变量来保存类的实例 private static Singleton uniqueInstance; // 定义一个标识确保线程同步 private static readonly object locker = new object(); // 定义私有构造函数，使外界不能创建该类实例 private Singleton() &#123; &#125; /// &lt;summary&gt; /// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Singleton GetInstance() &#123; // 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;， // 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁 // lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot; // 双重锁定只需要一句判断就可以了 if (uniqueInstance == null) &#123; lock (locker) &#123; // 如果类的实例不存在则创建，否则直接返回 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"CSharp","slug":"设计模式/CSharp","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"C++字符","slug":"C-字符","date":"2023-02-23T05:30:34.000Z","updated":"2025-03-07T12:20:21.215Z","comments":true,"path":"C-字符.html","link":"","permalink":"https://silencejql.github.io/C-%E5%AD%97%E7%AC%A6.html","excerpt":"C++中各类型字符区别","text":"C++中各类型字符区别 字符通常可用1个或两个字节表示; ANSI编码中一个字符使用一个字节表示; Unicode编码中一个字符使用两个字节表示 Visual C++编译器支持TCHAR、WCHAR、LPSTR、LPWSTR、LPCTSTR 的 ANSI 和 Unicode 字符。 char C语言标准数据类型，字符型 由几个字节组成通常由编译器决定，一般一个字节。 CHAR ANSI字符 英文用一个字节,中文用两个字节 WCHAR Unicode字符 每个字符有两个字节组成。 TCHAR 当前编译方式为ANSI（默认）方式，TCHAR等价于CHAR 如果为Unicode方式，TCHAR等价于WCHAR 12345#ifndef _UNICODEtypedef char TCHAR;#elsetypedef wchar_t TCHAR;#endif LPSTR LPSTR 是长指针字符串。它要么是char 要么是 wchar_t 取决于 uopn uncicod 是否定义。 其中 LP 代表长指针 STR 代表字符串 LPSTR 表示 CHAR 或长指针常量的常量以空结尾的字符串 LPWSTR LPWSTR 是一个指向 32 位 Unicode 字符字符串的 16 位指针 它是 WCHAR 类型的以 null 结尾的字符串或长指针 wchar 类型的字符串 LPCTSTR LPCSTR 是一个 32 位指针，指向以 8 位 Windows （ANSI） 字符的常量 null 结尾字符串","categories":[{"name":"C++","slug":"C","permalink":"https://silencejql.github.io/categories/C/"}],"tags":[]},{"title":"C# Minio存储文件","slug":"C-Minio存储文件","date":"2023-02-15T07:16:25.000Z","updated":"2025-03-24T11:39:03.681Z","comments":true,"path":"C-Minio存储文件.html","link":"","permalink":"https://silencejql.github.io/C-Minio%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6.html","excerpt":"MinIO Client SDK 为 MinIO 和 Amazon S3 兼容云存储服务提供更高级别的 API 支持.Net4.5及以上","text":"MinIO Client SDK 为 MinIO 和 Amazon S3 兼容云存储服务提供更高级别的 API 支持.Net4.5及以上 官方资料 源码: https://github.com/minio/minio-dotnet Server安装使用 下载Minio https://dl.minio.io/server/minio/release/windows-amd64/minio.exe 启动服务 启动服务需要用cmd命令行启动 minio.exe server D:\\MinIO 后面为minio.exe所在路径 启动成功后可以通过 127.0.0.1:9000 来访问,默认用户名和密码为 minioadmin/minioadmin 修改密码 找到 .minio.sys/config/config.json 文件，打开搜索 access_key access_key :value 用户名 secret_key :value 密码 保存重启即可 Client安装使用 安装MinIO.NET 在Nuget程序包管理器控制台中运行以下命令 PM&gt; Install-Package Minio 示例: https://github.com/minio/minio-dotnet/tree/master/Minio.Examples/Cases 文件上传 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using Minio;using Minio.Exceptions;using Minio.DataModel;public static void UploadFile()&#123; var endpoint = &quot;127.0.0.1:9000&quot;; var accessKey = &quot;minioadmin&quot;; var secretKey = &quot;minioadmin&quot;; var minio = new MinioClient() .WithEndpoint(endpoint) .WithCredentials(accessKey, secretKey) .Build(); Run(minio).Wait();&#125;private async static Task Run(MinioClient minio)&#123; var bucketName = &quot;firstbucket&quot;; var location = &quot;us-east-1&quot;; var objectName = &quot;1.bmp&quot;; var filePath = &quot;D:\\\\BBK\\\\1.bmp&quot;; var contentType = &quot;application/bmp&quot;; try &#123; // Make a bucket on the server, if not already present. var beArgs = new BucketExistsArgs() .WithBucket(bucketName); bool found = await minio.BucketExistsAsync(beArgs).ConfigureAwait(false); if (!found) &#123; var mbArgs = new MakeBucketArgs() .WithBucket(bucketName); await minio.MakeBucketAsync(mbArgs).ConfigureAwait(false); &#125; // Upload a file to bucket. var putObjectArgs = new PutObjectArgs() .WithBucket(bucketName) .WithObject(objectName) .WithFileName(filePath) .WithContentType(contentType); await minio.PutObjectAsync(putObjectArgs).ConfigureAwait(false); Console.WriteLine(&quot;Successfully uploaded &quot; + objectName); &#125; catch (MinioException e) &#123; Console.WriteLine(&quot;File Upload Error: &#123;0&#125;&quot;, e.Message); &#125;&#125; 文件下载 12345678910111213141516171819202122232425//未测试public static async Task Run(IMinioClient minio, string bucketName = &quot;my-bucket-name&quot;, string objectName = &quot;my-object-name&quot;, string fileName = &quot;local-filename&quot;, ServerSideEncryption sse = null)&#123; try &#123; Console.WriteLine(&quot;Running example for API: GetObjectAsync&quot;); File.Delete(fileName); var args = new GetObjectArgs() .WithBucket(bucketName) .WithObject(objectName) .WithFile(fileName) .WithServerSideEncryption(sse); await minio.GetObjectAsync(args).ConfigureAwait(false); Console.WriteLine($&quot;Downloaded the file &#123;fileName&#125; from bucket &#123;bucketName&#125;&quot;); Console.WriteLine(); &#125; catch (Exception e) &#123; Console.WriteLine($&quot;[Bucket] Exception: &#123;e&#125;&quot;); &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"MiniIO","slug":"MiniIO","permalink":"https://silencejql.github.io/tags/MiniIO/"}]},{"title":"BBK平台软件添加通讯点","slug":"BBK平台软件添加通讯点","date":"2023-02-03T01:28:06.000Z","updated":"2025-03-07T12:20:38.199Z","comments":true,"path":"BBK平台软件添加通讯点.html","link":"","permalink":"https://silencejql.github.io/BBK%E5%B9%B3%E5%8F%B0%E8%BD%AF%E4%BB%B6%E6%B7%BB%E5%8A%A0%E9%80%9A%E8%AE%AF%E7%82%B9.html","excerpt":"Always中添加并使用通讯点, 如ADAS,侧滑等或需要在平台实现动作控制的工位","text":"Always中添加并使用通讯点, 如ADAS,侧滑等或需要在平台实现动作控制的工位 示例 创建对象 初始化 使用 状态显示 在菜单中添加状态显示 点击菜单中的 查看-设备状态 说明 配置文件 按示例添加完成后打开程序会自动在Config文件夹中生成对应名称的xml文件 value需要手动配置绑定到对应IO点 WriteEnable输出点需配置为true Reversion用于输入点位取反 AutoReset用于输出点位自动复位,-1为禁用,500为500ms后复位 ShowName为设备状态界面显示分类及名称 常用类型说明 AdvOpera4.AdvConfigEx : 研华板卡 EIPNetOperaLib.EIPABConfig : AB PLC S7NetOperaLib.S7NetConfig : 西门子PLC EtherCATOperaLib.EtherCATConfig : 倍福模块 GeneralLib.xRemoterClientConfig : TCP设备间软件对象绑定:BBK检测线通讯相关介绍 OPCOpraLib.OPCConfigEx : OPC 通讯点使用说明 输入点 IsTrue IsFalse 输出点 SetTrue SetFalse SetTrueFalseTimer脉冲输出, 默认持续500ms, 可输入参数为脉冲时间(int)","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Markdown画图","slug":"Markdown画图","date":"2023-01-31T03:21:03.000Z","updated":"2025-03-24T11:38:36.154Z","comments":true,"path":"Markdown画图.html","link":"","permalink":"https://silencejql.github.io/Markdown%E7%94%BB%E5%9B%BE.html","excerpt":"利用Mermaid绘制图标 详见: https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md","text":"利用Mermaid绘制图标 详见: https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md 图类 饼状图：使用pie关键字 流程图：使用graph关键字 序列图：使用sequenceDiagram关键字 甘特图：使用gantt关键字 类图：使用classDiagram关键字 状态图：使用stateDiagram关键字 用户旅程图：使用journey关键字 饼状图 123456%%注释pie title 为什么总是宅在家里？ &quot;喜欢宅&quot; : 15 &quot;天气太热或太冷&quot; : 20 &quot;穷&quot; : 500 %%注释 pie title 为什么总是宅在家里？ \"喜欢宅\" : 15 \"天气太热或太冷\" : 20 \"穷\" : 500 流程图 1234567%%注释graph LR A[Start] --&gt; B&#123;Is it?&#125;; B -- Yes --&gt; C[OK]; C --&gt; D[Rethink]; D --&gt; B; B -- No ----&gt; E[End]; %%注释 graph LR A[Start] --> B{Is it?}; B -- Yes --> C[OK]; C --> D[Rethink]; D --> B; B -- No ----> E[End]; 方向 graph或graph TB或graph TD：从上往下 graph BT：从下往上 graph LR：从左往右 graph RL：从右往左 节点 无名字的结点：直接写内容，此时结点边框为方形；节点内容不支持空格 有名字的结点：节点名后书写内容，内容左右有特定符号，结点边框由符号决定；节点内容可以有空格 123456789%%注释graph 默认方形 id1[方形] id2(圆边矩形) id3([体育场形]) id4[[子程序形]] id5[(圆柱形)] id6((圆形)) %%注释 graph 默认方形 id1[方形] id2(圆边矩形) id3([体育场形]) id4[[子程序形]] id5[(圆柱形)] id6((圆形)) 12345678%%注释graph id1&#123;菱形&#125; id2&#123;&#123;六角形&#125;&#125; id3[/平行四边形/] id4[\\反向平行四边形\\] id5[/梯形\\] id6[\\反向梯形/] %%注释 graph id1{菱形} id2 id3[/平行四边形/] id4[\\反向平行四边形\\] id5[/梯形\\] id6[\\反向梯形/] 连线样式 12345%%注释graph LRa--&gt;b--实线--&gt;c--&gt;|实线|da==&gt;b==粗线==&gt;ca-.-&gt;b-.虚线.-&gt;c %%注释 graph LR a-->b--实线-->c-->|实线|d a==>b==粗线==>c a-.->b-.虚线.->c 12345678graph LRa---bb--无箭头!---cc---|无箭头|dd===ee==无箭头===ff-.-gg-.无箭头.-h graph LR a---b b--无箭头!---c c---|无箭头|d d===e e==无箭头===f f-.-g g-.无箭头.-h 1234flowchart LR A o--o B B &lt;--&gt; C C x--x D flowchart LR A o--o B B C C x--x D 12345678910%%多重连接graph a --&gt; b &amp; c--&gt; d A &amp; B--&gt; C &amp; D X --&gt; M X --&gt; N Y --&gt; M Y --&gt; N %%多重连接 graph a --> b & c--> d A & B--> C & D X --> M X --> N Y --> M Y --> N","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://silencejql.github.io/tags/Markdown/"}]},{"title":"EOLPrint参数配置说明","slug":"EOLPrint参数配置说明","date":"2023-01-30T07:57:54.000Z","updated":"2025-03-07T12:21:12.460Z","comments":true,"path":"EOLPrint参数配置说明.html","link":"","permalink":"https://silencejql.github.io/EOLPrint%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html","excerpt":"EOLPrint一般用于检测线打印工位","text":"EOLPrint一般用于检测线打印工位 EOLPrint 该打印软件以EOLPrint\\Report文件夹下的Excel为模板, 编辑中绑定单元格对应数据库字段 主界面 参数 用于编辑链接字符串 自动打印时需检查链接字符串的配置是否满足需求, 如下图只会打印&quot;报告打印&quot;字段为N且&quot;全部合格&quot;字段为Y的数据 编辑 用于绑定数据库中字段, 如需更改模板字体或格式, 需要直接更改Report文件夹中excel模板文件 管理模板 用于添加重载模板 请勿随便点击&quot;删除选中模板&quot; 点击 打开Excel文件 选中Report文件中的模板来更新或添加","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"ABS参数配置说明","slug":"ABS参数配置说明","date":"2023-01-30T07:41:46.000Z","updated":"2025-03-07T12:21:31.634Z","comments":true,"path":"ABS参数配置说明.html","link":"","permalink":"https://silencejql.github.io/ABS%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html","excerpt":"ABS增减压参数配置文件路径在Config\\ABSValveTestConfig中, 不同车型会自动生成相应配置文件","text":"ABS增减压参数配置文件路径在Config\\ABSValveTestConfig中, 不同车型会自动生成相应配置文件 ABS参数配置说明 增减压时间参数说明如下, 因各现场及车型不同, 参数意义可能不同 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;NewDataSet&gt; &lt;Table1&gt; &lt;!--0:增减压力值采集满设定时间后退出当前增减压步骤;1:增减压力值合格后立即退出当前增减压步骤--&gt; &lt;UseJump&gt;0&lt;/UseJump&gt; &lt;!--脉冲增压次数,用于ESC或ESP--&gt; &lt;IncPulseN&gt;5&lt;/IncPulseN&gt; &lt;!--增压力值采集时间,记录当前时间内的最大值--&gt; &lt;IncCollectT&gt;1000&lt;/IncCollectT&gt; &lt;!--减压力值采集时间,记录当前时间内的最小值--&gt; &lt;DecCollectT&gt;1000&lt;/DecCollectT&gt; &lt;!--左前增压输入时间参数--&gt; &lt;A1_IncT1&gt;250&lt;/A1_IncT1&gt; &lt;!--左前脉冲增压输入时间参数--&gt; &lt;A1_IncT2&gt;50&lt;/A1_IncT2&gt; &lt;!--左前减压输入时间参数--&gt; &lt;A1_DecT&gt;250&lt;/A1_DecT&gt; &lt;!--右前增压输入时间参数--&gt; &lt;A2_IncT1&gt;150&lt;/A2_IncT1&gt; &lt;!--右前脉冲增压输入时间参数--&gt; &lt;A2_IncT2&gt;50&lt;/A2_IncT2&gt; &lt;!--右前减压输入时间参数--&gt; &lt;A2_DecT&gt;250&lt;/A2_DecT&gt; &lt;!--预留--&gt; &lt;A3_IncT1&gt;150&lt;/A3_IncT1&gt; &lt;A3_IncT2&gt;50&lt;/A3_IncT2&gt; &lt;A3_DecT&gt;250&lt;/A3_DecT&gt; &lt;A4_IncT1&gt;150&lt;/A4_IncT1&gt; &lt;A4_IncT2&gt;50&lt;/A4_IncT2&gt; &lt;A4_DecT&gt;250&lt;/A4_DecT&gt; &lt;/Table1&gt;&lt;/NewDataSet&gt;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"OBDII参数配置说明","slug":"OBDII参数配置说明","date":"2023-01-30T07:20:46.000Z","updated":"2025-03-07T12:20:53.001Z","comments":true,"path":"OBDII参数配置说明.html","link":"","permalink":"https://silencejql.github.io/OBDII%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html","excerpt":"前面啥也没有","text":"前面啥也没有 参数配置 如下图: KeyName: 通讯标识,不存在时程序自动创建 ClassName: BBKCAN驱动标识, 一般使用VCanCmdForBBKDrive Time1: 单帧超时时间, 超过此时间报错Timeout Time2: 收到78等待时间 Param1: OBD串口号 Param2: 波特率 Param3: 当前KeyName通讯生成的log名称(可不填) Param4: 其他配置, 如250表示CAN通讯250K(默认500k); 250,1表示250k扩展帧; 500,1表示500k扩展帧;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"BBK启用CAN通讯超时时间配置","slug":"BBK启用CAN通讯超时时间配置","date":"2023-01-30T05:48:26.000Z","updated":"2025-03-07T12:21:24.241Z","comments":true,"path":"BBK启用CAN通讯超时时间配置.html","link":"","permalink":"https://silencejql.github.io/BBK%E5%90%AF%E7%94%A8CAN%E9%80%9A%E8%AE%AF%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE.html","excerpt":"像ABS测试默认通讯超时时间为100ms配置中的Time并未使用,可在代码中启用也可在Always中启用","text":"像ABS测试默认通讯超时时间为100ms配置中的Time并未使用,可在代码中启用也可在Always中启用 启用超时配置 找到Always文件中CAN通讯对象, ABS可在初始化通讯中看到 执行EnableUserTimeout方法","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"数据格式","slug":"数据格式","date":"2023-01-12T08:32:04.000Z","updated":"2023-04-18T02:46:49.667Z","comments":true,"path":"数据格式.html","link":"","permalink":"https://silencejql.github.io/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html","excerpt":"数据格式说明","text":"数据格式说明 Base64 基于64个可打印字符来表示二进制数据的方法 64个字符0~63分别对应A~Za~z0~9+/ Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3*8 = 4*6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。 编码规则 把3个字节变成4个字节。 每76个字符加一个换行符。 最后的结束符也要处理。 例如: 转换前: 10101101,10111010,01110110 转换后: 00101011, 00011011 ,00101001 ,00110110 十进制 43 27 41 54 对应码表中的值 r b p 2 所以上面的24位编码，编码后的Base64值为 rbp2 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的Bit用0补足。然后，每次取出6个bit，按照其值选择ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。 如果最后剩下两个输入数据，在编码结果后加1个“=”；如果最后剩下一个输入数据，编码结果后加2个“=”；如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。","categories":[],"tags":[]},{"title":"HttpWeb补充","slug":"HttpWeb补充","date":"2023-01-05T02:52:55.000Z","updated":"2025-03-24T11:38:02.116Z","comments":true,"path":"HttpWeb补充.html","link":"","permalink":"https://silencejql.github.io/HttpWeb%E8%A1%A5%E5%85%85.html","excerpt":"前面啥也没有","text":"前面啥也没有 HttpWeb说明 HttpWeb 补充 解决SSL/TLS证书验证报错 12345678910111213using System.Net.Security;using System.Security.Authentication;using System.Security.Cryptography.X509Certificates;//忽略SSL验证ServicePointManager.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) =&gt; true;//添加SSL证书ServicePointManager.ServerCertificateValidationCallback = new System.Net.Security.RemoteCertificateValidationCallback(CheckValidationResult);ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls | (SecurityProtocolType)0x300 |//Tls11 (SecurityProtocolType)0xC00;//Tls12 Client 1234567891011WebClient web = new WebClient();web.Headers.Add(HttpRequestHeader.ContentType, &quot;application/json&quot;);web.Encoding = Encoding.UTF8;//postrecv = web.UploadString(mesGetVInfoUrl, jsonGetCurVehicle.ToString());//requestrecv = web.DownloadString(url);var recvObject = JObject.Parse(recv)JsonRecv jrecv = JsonConvert.DeserializeObject&lt;JsonRecv&gt;(recv); Server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748HttpListener httpListenner;httpListenner = new HttpListener();httpListenner.AuthenticationSchemes = AuthenticationSchemes.Anonymous;httpListenner.Prefixes.Add(httpServerUrl);httpListenner.Start();new Thread(new ThreadStart(delegate&#123; loop(httpListenner);&#125;)).Start();private void loop(HttpListener httpListenner)&#123; while (true) &#123; HttpListenerContext context = httpListenner.GetContext(); HttpListenerRequest request = context.Request; HttpListenerResponse response = context.Response; if (request.HttpMethod == &quot;POST&quot;) &#123; HandlePost(request, response); &#125; else if (request.HttpMethod == &quot;GET&quot;) &#123; response.OutputStream.Write(Encoding.ASCII.GetBytes(&quot;NotSupport&quot;), 0, Encoding.ASCII.GetBytes(&quot;NotSupport&quot;).Length); &#125; response.Close(); &#125;&#125;public virtual void HandlePost(HttpListenerRequest request, HttpListenerResponse response)&#123; var stream = response.OutputStream; byte[] readBytes = new byte[1024]; request.InputStream.Read(readBytes, 0, 1024); string recv = Encoding.ASCII.GetString(readBytes); var jsonRecv = JObject.Parse(recv.Trim(&#x27;\\0&#x27;)); JObject jsonSend = new JObject(); if (jsonRecv[&quot;stationCode&quot;].ToString() == &quot;EV&quot;) &#123; jsonSend[&quot;factoryCode&quot;] = &quot;Changzhou&quot;; jsonSend[&quot;stationCode&quot;] = &quot;EV&quot;; jsonSend[&quot;vin&quot;] = &quot;12345678901234567&quot;; jsonSend[&quot;state&quot;] = &quot;Start&quot;; jsonSend[&quot;result&quot;] = &quot;OK&quot;; &#125; stream.Write(Encoding.ASCII.GetBytes(jsonSend.ToString()), 0, Encoding.ASCII.GetBytes(jsonSend.ToString()).Length);&#125;","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"Http","slug":"Http","permalink":"https://silencejql.github.io/tags/Http/"}]},{"title":"HUD标定","slug":"HUD标定","date":"2022-05-04T01:22:11.000Z","updated":"2025-03-07T12:40:57.279Z","comments":true,"path":"HUD标定.html","link":"","permalink":"https://silencejql.github.io/HUD%E6%A0%87%E5%AE%9A.html","excerpt":"主要包括HUD机器人角度标定方式","text":"主要包括HUD机器人角度标定方式 标定相机 添加标定界面 参考轮眉标定配置: 轮眉软件调试-棋盘格 选择标定类型 标定 说明 目前HUD测试中只用到了相机内参,所以标定板左上角十字坐标和棋盘格参数务必保持准确. 标定相机角度 当前版本机器人无法准确标定相机三个角度的零点, 且无法正确的通过上位机补偿角度. 可以采用上位机辅助机器人确定好角度零点后再进行机器人坐标系标定. 准备工作 添加角度识别 移动机器人 将相机移动至于标靶中心平行的位置 打开相机拍照 中心十字线为图像中心点,要求图像中心在标靶中心可保证Ry,Rz角度为零 旋转相机角度 调整Ry,Rz使标靶中心位于图像中心 调整红色ROI区域使四个角点位于四个孔的中心(据版本算法而定),点击识别点(角度) 左上角为Rx旋转角, 调节相机Rx使其接近0即可找到三个角度的零点位置 机器人标定 保持角度不变的情况下对机器人进行坐标系0点的标定.","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"EV设备调试","slug":"EV设备调试","date":"2022-04-28T03:20:32.000Z","updated":"2025-03-07T12:21:57.795Z","comments":true,"path":"EV设备调试.html","link":"","permalink":"https://silencejql.github.io/EV%E8%AE%BE%E5%A4%87%E8%B0%83%E8%AF%95.html","excerpt":"前面啥也没有","text":"前面啥也没有 通道盒GSB 串口助手设备115200波特率, 发送GSB5 ? 安规仪 串口助手设备115200波特率, 发送*IDN?或MEAS? 万用表 安装GDM834X USB Driver后设备管理器可查看串口号","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"启用Windows远程控制","slug":"启用Windows远程控制","date":"2022-04-23T04:49:14.000Z","updated":"2024-05-18T05:19:58.745Z","comments":true,"path":"启用Windows远程控制.html","link":"","permalink":"https://silencejql.github.io/%E5%90%AF%E7%94%A8Windows%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6.html","excerpt":"配置开启远程桌面","text":"配置开启远程桌面 开启远程桌面 我的电脑–属性—高级系统设置 按照下图进行勾选 允许空密码登录 不做此设置需要在被远程电脑上设置密码后才可进行远程控制 Win+R 输入Gpedit.msc 如下图, 选择&quot;已禁用&quot;后点击确定 CredSSP报错处理 Win+R 输入Gpedit.msc 路径为:计算机配置-管理模板-系统-凭据分配-加密数据库修正 如下图,选择&quot;已启用&quot;后保护级别选择&quot;易受攻击&quot;后点击确定 若找不到相应配置, 如Windows Server系统 解决方法为: 我的电脑-属性-远程设置 取消勾选下图中的进允许运行使用网络级别身份验证的远程桌面的计算机链接","categories":[],"tags":[]},{"title":"C-Sharp-补课笔记-反射","slug":"C-Sharp-补课笔记-反射","date":"2022-03-24T07:29:59.000Z","updated":"2025-03-24T11:37:30.297Z","comments":true,"path":"C-Sharp-补课笔记-反射.html","link":"","permalink":"https://silencejql.github.io/C-Sharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%8F%8D%E5%B0%84.html","excerpt":"前面啥也没有","text":"前面啥也没有 示例 Interface 12345public interface InterfaceBase&#123; public string Name &#123; get; set; &#125; public void DoSomething();&#125; Class1 12345678910111213141516171819202122232425public class Student : InterfaceBase&#123; string name; public string Name &#123; get &#123; return name; &#125; set =&gt; this.name = value; &#125; public void DoSomething() &#123; int i = 88; Console.WriteLine(&quot;Write homework.&quot;); &#125;&#125;class Worker : InterfaceBase&#123; public string Name &#123; get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); &#125; public void DoSomething() &#123; Console.WriteLine(&quot;Working.&quot;); &#125;&#125;class Cat&#123; string name;&#125; Class2 1234567891011public class Teacher : InterfaceBase&#123; string name; public string Name &#123; get &#123; return name; &#125; set =&gt; this.name = value; &#125; public void DoSomething() &#123; Console.WriteLine(&quot;Teaching Math.&quot;); &#125;&#125; TestClass 123456789101112131415161718192021222324string dllPath = System.Environment.CurrentDirectory;//加载路径下的文件string[] files = Directory.GetFiles(dllPath);foreach(string file in files)&#123; if (!file.Contains(&quot;.dll&quot;))//过滤 continue; Assembly ass = Assembly.LoadFile(file); Type[] types = ass.GetTypes(); object obj = null; foreach (Type t in types) &#123; // 判断类是否实现接口 if(typeof(InterfaceBase).IsAssignableFrom(t)) &#123; obj = ass.CreateInstance(t.FullName, true); &#125; if (obj is InterfaceBase)//判断的另一种形式 &#123; InterfaceBase ib = obj as InterfaceBase; ib.DoSomething(); &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"BBK-PostgreSQL添加字段","slug":"BBK-PostgreSQL添加字段","date":"2022-01-13T08:57:33.000Z","updated":"2025-03-24T11:36:33.058Z","comments":true,"path":"BBK-PostgreSQL添加字段.html","link":"","permalink":"https://silencejql.github.io/BBK-PostgreSQL%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5.html","excerpt":"本文以\"已打印\"字段为例","text":"本文以\"已打印\"字段为例 说明 已打印字段格式可参考已上传字段: 不为空, 默认为’N’ 在创建的脚本中更改字段名, 先屏蔽后面两条属性设置(若数据库中无历史数据可忽略),点击执行创建字段 由于数据库中存在历史数据, 新创建的字段默认为空, 因此后面设置不能为空会报错, 可先将数据库中的已打印字段赋值后再执行此查询设置属性. 如下图: 在表中创建Update脚本 将表中的已打印字段设置成’Y’,点击执行查询后判断下方结果无报错可退出不需保存 再返回到刚才创建的字段查询中进行后续操作即可","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://silencejql.github.io/tags/PostgreSQL/"}]},{"title":"BBK工位打印配置","slug":"BBK工位打印配置","date":"2022-01-13T07:10:12.000Z","updated":"2025-03-07T12:24:15.402Z","comments":true,"path":"BBK工位打印配置.html","link":"","permalink":"https://silencejql.github.io/BBK%E5%B7%A5%E4%BD%8D%E6%89%93%E5%8D%B0%E9%85%8D%E7%BD%AE.html","excerpt":"BBK检测线设备程序打印配置, 本文档只包含加载Excel模板进行打印的方式","text":"BBK检测线设备程序打印配置, 本文档只包含加载Excel模板进行打印的方式 添加打印功能 创建对象 编辑打开Always文件, 在对象列表中创建Print对象,如下图: 初始化 在程序初始化中增加Print的初始化, 如下图: 本文档选择PrintDbTable类, 意为从读取单个表中数据打印. 新增菜单配置选项 进入菜单编辑中新增打印配置选项, 如下图: 添加完成后保存退出编辑界面 配置 模板配置 软件打开后会在Config文件夹中生成ExcelReport和PrintConfig文件夹 可将已有模板和配置复制到相应文件夹中,或者新建excel后在软件中进行配置 双击打开Always程序, 在菜单中打开创建的打印配置选项 点击模板参数如下: 配置链接字符串 DbConnectString对应需要访问数据库的链接字符串 配置表名 设置读取表名 模板编辑 点击模板编辑进行字段绑定及格式配置 如下图: 在右侧模板中点击需要配置的单元格,勾选左侧启用后可以进行相应字段操作 查询 编辑完模板后可点击查询按钮进行数据查询, 若出现下图报错,说明数据表中没有已打印字段,需要在数据库中进行添加 数据库中添加字段可参考: BBK-PostgreSQL添加字段 添加完字段后便可进行查询打印 打印 手动打印 在打印配置中查询并打印 测试结束自动打印 在always中调用Print函数,参数为模板名 注意: 改函数调用后默认会打印数据库中最早的一条未打印数据, 若要打印最新数据需将之前的已打印字段设置成Y, 或者要下最新的dll更新 若不想自动打,只在需要时手动查询进行打印可在PrintConfig文件夹相应模板中将AutoPrint改为false,改为false后即使调用Print函数也不会打印","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"C-Sharp-补课笔记--托管代码","slug":"C-Sharp-补课笔记-托管代码","date":"2022-01-12T08:55:13.000Z","updated":"2025-03-24T11:37:17.029Z","comments":true,"path":"C-Sharp-补课笔记-托管代码.html","link":"","permalink":"https://silencejql.github.io/C-Sharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81.html","excerpt":"前面啥也没有","text":"前面啥也没有 托管代码 使用 .NET Framework 时，我们经常会遇到“托管代码”这个术语。 本文档解释这个术语的含义及其更多相关信息。 简而言之，托管代码就是执行过程交由运行时管理的代码。 在这种情况下，相关的运行时称为公共语言运行时 (CLR)，不管使用的是哪种实现（Mono、.NET Framework 或.NET Core）。 CLR 负责提取托管代码、将其编译成机器代 码，然后执行它。 除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。 相反，如果运行 C/C++ 程序，则运行的代码也称为“非托管代码”。 在非托管环境中，程序员需要亲自负责处理相当 多的事情。 实际的程序在本质上是操作系统 (OS) 载入内存，然后启动的二进制代码。 其他任何工作 - 从内存管理 到安全考虑因素 - 对于程序员来说是一个不小的负担。 托管代码是使用可在 .NET 上运行的一种高级语言（例如 C#、Visual Basic、F# 等）编写的。 使用相应的编译器编译以 这些语言编写的代码时，无法获得机器代码， 而是获得中间语言代码，然后运行时会对其进行编译并将其执行。 C++ 是这条规则的一个例外，因为它也能够生成可在 Windows 上运行的本机非托管二进制代码。 中间语言和执行 什么是“中间语言”（简称 IL）？ 中间语言是编译使用高级 .NET 语言编写的代码后获得的结果。 对使用其中一种语言 编写的代码进行编译后，即可获得 IL 所生成的二进制代码。 必须注意，IL 独立于在运行时顶层运行的任何特定语 言；行业甚至为它单独制定了规范，如果有需要，你可以阅读该规范。 从高级代码生成 IL 后，你很有可能想要运行它。 CLR 此时将接管工作，启动实时 (JIT) 编译过程，或者将代码从 IL 实时编译成可以真正在 CPU 上运行的机器代码。 这样，CLR 就能确切地知道代码的作用，并可以有效地 管理 代 码。 中间语言有时也称为公共中间语言 (CIL) 或 Microsoft 中间语言 (MSIL)。 托管代码互操作性 当然，CLR 允许越过托管与非托管环境之间的边界，同时，即使在基类库中，也有很多代码可以做到这一点。 这称 为互操作性，简称 interop。 例如，使用这些机制可以包装某个非托管库以及调用该库。 但是，请务必注意，如果采 取这种方法，当代码越过运行时的边界时，实际的执行管理将再次交接到托管代码，因而需要遵守相同的限制。 与此类似，C# 语言可让你利用所谓的不安全上下文（指定执行过程不由 CLR 管理的代码片段），在代码中直接使用 非托管构造，例如指针。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"C# RESTful","slug":"C-Sharp RESTful","date":"2022-01-08T09:12:00.000Z","updated":"2025-03-24T11:36:40.879Z","comments":true,"path":"C-Sharp RESTful.html","link":"","permalink":"https://silencejql.github.io/C-Sharp%20RESTful.html","excerpt":"Representational State Transfer","text":"Representational State Transfer 理解 表现层状态转化 如果一个架构符合REST原则，就称它为RESTful架构 REST的名称&quot;表现层状态转化&quot;中, “表现层&quot;指的是&quot;资源”（Resources）的&quot;表现层&quot;。 URI（统一资源标识符）指向资源，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 Representation 把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation） 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现 State Transfer 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot; 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static class RESTful&#123; public static bool CheckValidationResult(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors) &#123; return true; &#125; public static WebResponse Post(string Url, string data) &#123; //System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系 ServicePointManager.ServerCertificateValidationCallback = new System.Net.Security.RemoteCertificateValidationCallback(CheckValidationResult); //System.Net.WebException: 请求被中止: 未能创建 SSL/TLS 安全通道 ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls | (SecurityProtocolType)0x300 | (SecurityProtocolType)0xC00; string response; HttpWebRequest request = WebRequest.Create(Url) as HttpWebRequest; request.Method = &quot;POST&quot;; byte[] bytes = Encoding.UTF8.GetBytes(data); //request.ContentType = &quot;application/x-www-form-urlencoded&quot;; request.ContentType = &quot;application/json&quot;; request.ContentLength = bytes.Length; //request.Headers.Add(&quot;X-Access-Token&quot;, httpToken); using (Stream responseStream = request.GetRequestStream()) &#123; responseStream.Write(bytes, 0, bytes.Length); &#125; using (HttpWebResponse webResponse = request.GetResponse() as HttpWebResponse) &#123; StreamReader streamReader = new StreamReader(webResponse.GetResponseStream(), Encoding.UTF8); response = streamReader.ReadToEnd(); &#125; if (request != null) request.Abort(); WebResponse webRes = JsonConvert.DeserializeObject&lt;WebResponse&gt;(response); return webRes; &#125; public static string Get(string Url) &#123; string response; HttpWebRequest request = WebRequest.Create(Url) as HttpWebRequest; //request.Proxy = null; //request.KeepAlive = false; request.Method = &quot;GET&quot;; request.ContentType = &quot;application/json; charset=UTF-8&quot;; //request.AutomaticDecompression = DecompressionMethods.GZip; using (HttpWebResponse webResponse = request.GetResponse() as HttpWebResponse) &#123; StreamReader myStreamReader = new StreamReader(webResponse.GetResponseStream(), Encoding.UTF8); response = myStreamReader.ReadToEnd(); &#125; if (request != null) request.Abort(); return response; &#125; public class WebResponse &#123; public string status;//200 public string message; public string data; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"BBK无线OBD判断连接","slug":"BBK无线OBD判断连接","date":"2022-01-07T05:42:19.000Z","updated":"2025-03-07T12:24:04.811Z","comments":true,"path":"BBK无线OBD判断连接.html","link":"","permalink":"https://silencejql.github.io/BBK%E6%97%A0%E7%BA%BFOBD%E5%88%A4%E6%96%AD%E8%BF%9E%E6%8E%A5.html","excerpt":"无线或有线OBD通过软件方式判断OBD的插入与拔出","text":"无线或有线OBD通过软件方式判断OBD的插入与拔出 原理 BBK OBD需要从车端取电, 模块上电后才可进行数据交互, 判断是否插入时实时与模块进行通讯,当模块有反馈时表示已插好. 实现 初始化通讯 在需要判断的流程中增加判断步骤 Always 在程序初始化的地方创建通讯, 参数为CAN标识,运行程序会自动出现在系统配置的VehicleCmd中. 注意调用对象类型应为CanCmdOpraLib.VehicleCmdObject 可参考下图在合适位置调用判断函数, 已连接向下执行Y, 未连接执行N继续等待 配置 执行完","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"C Sharp 补课笔记 -- LINQ to XML","slug":"C-Sharp-补课笔记-LINQ-to-XML","date":"2022-01-06T05:28:06.000Z","updated":"2025-03-24T11:37:00.251Z","comments":true,"path":"C-Sharp-补课笔记-LINQ-to-XML.html","link":"","permalink":"https://silencejql.github.io/C-Sharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0-LINQ-to-XML.html","excerpt":"LINQ to XML 是一种启用了 LINQ 的内存 XML 编程接口，支持在 .NET Framework 编程语言中处理 XML","text":"LINQ to XML 是一种启用了 LINQ 的内存 XML 编程接口，支持在 .NET Framework 编程语言中处理 XML 简单示例 123456789// Load the XML file from our project directory containing the purchase ordersvar filename = &quot;PurchaseOrder.xml&quot;;var currentDirectory = Directory.GetCurrentDirectory();var purchaseOrderFilepath = Path.Combine(currentDirectory, filename);XElement purchaseOrder = XElement.Load(purchaseOrderFilepath);IEnumerable&lt;string&gt; partNos = from item in purchaseOrder.Descendants(&quot;Item&quot;)select (string) item.Attribute(&quot;PartNumber&quot;);IEnumerable&lt;string&gt; partNos = purchaseOrder.Descendants(&quot;Item&quot;).Select(x =&gt; (string)x.Attribute(&quot;PartNumber&quot;)); 创建XML 12345678910111213141516XElement contacts =new XElement(&quot;Contacts&quot;, new XElement(&quot;Contact&quot;, new XElement(&quot;Name&quot;, &quot;Patrick Hines&quot;), new XElement(&quot;Phone&quot;, &quot;206-555-0144&quot;, new XAttribute(&quot;Type&quot;, &quot;Home&quot;)), new XElement(&quot;phone&quot;, &quot;425-555-0145&quot;, new XAttribute(&quot;Type&quot;, &quot;Work&quot;)), new XElement(&quot;Address&quot;, new XElement(&quot;Street1&quot;, &quot;123 Main St&quot;), new XElement(&quot;City&quot;, &quot;Mercer Island&quot;), new XElement(&quot;State&quot;, &quot;WA&quot;), new XElement(&quot;Postal&quot;, &quot;68042&quot;) ) )); LINQ to XML 123456789101112131415XElement srcTree = new XElement(&quot;Root&quot;, new XElement(&quot;Element&quot;, 1), new XElement(&quot;Element&quot;, 2), new XElement(&quot;Element&quot;, 3), new XElement(&quot;Element&quot;, 4), new XElement(&quot;Element&quot;, 5));XElement xmlTree = new XElement(&quot;Root&quot;, new XElement(&quot;Child&quot;, 1), new XElement(&quot;Child&quot;, 2), from el in srcTree.Elements() where (int)el &gt; 2 select el);Console.WriteLine(xmlTree); XAttribute 创建包含属性的元素 12345XElement phone = new XElement(&quot;Phone&quot;, new XAttribute(&quot;Type&quot;, &quot;Home&quot;), &quot;555-555-5555&quot;);Console.WriteLine(phone);//&lt;Phone Type=&quot;Home&quot;&gt;555-555-5555&lt;/Phone&gt; XML示例 1234567891011121314151617181920212223242526272829303132333435XDocument d = new XDocument( new XComment(&quot;This is a comment.&quot;), new XProcessingInstruction(&quot;xml-stylesheet&quot;, &quot;href=&#x27;mystyle.css&#x27; title=&#x27;Compact&#x27; type=&#x27;text/css&#x27;&quot;), new XElement(&quot;Pubs&quot;, new XElement(&quot;Book&quot;, new XElement(&quot;Title&quot;, &quot;Artifacts of Roman Civilization&quot;), new XElement(&quot;Author&quot;, &quot;Moreno, Jordao&quot;) ), new XElement(&quot;Book&quot;, new XElement(&quot;Title&quot;, &quot;Midieval Tools and Implements&quot;), new XElement(&quot;Author&quot;, &quot;Gazit, Inbar&quot;) ) ), new XComment(&quot;This is another comment.&quot;));d.Declaration = new XDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, &quot;true&quot;);Console.WriteLine(d);d.Save(&quot;test.xml&quot;);/*&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--This is a comment.--&gt;&lt;?xml-stylesheet href=&#x27;mystyle.css&#x27; title=&#x27;Compact&#x27; type=&#x27;text/css&#x27;?&gt;&lt;Pubs&gt;&lt;Book&gt;&lt;Title&gt;Artifacts of Roman Civilization&lt;/Title&gt;&lt;Author&gt;Moreno, Jordao&lt;/Author&gt;&lt;/Book&gt;&lt;Book&gt;&lt;Title&gt;Midieval Tools and Implements&lt;/Title&gt;&lt;Author&gt;Gazit, Inbar&lt;/Author&gt;&lt;/Book&gt;&lt;/Pubs&gt;&lt;!--This is another comment.--&gt;*/","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"C Sharp 补课笔记 -- LINQ","slug":"C-Sharp-补课笔记-LINQ","date":"2022-01-06T02:41:54.000Z","updated":"2025-03-24T11:37:06.350Z","comments":true,"path":"C-Sharp-补课笔记-LINQ.html","link":"","permalink":"https://silencejql.github.io/C-Sharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0-LINQ.html","excerpt":"语言集成查询 LINQ 数据源是支持泛型 IEnumerable&lt;T&gt; 接口或从中继承的接口的任意对象","text":"语言集成查询 LINQ 数据源是支持泛型 IEnumerable&lt;T&gt; 接口或从中继承的接口的任意对象 简单示例 12345678910111213141516171819class LINQQueryExpressions&#123; static void Main() &#123; // Specify the data source. int[] scores = new int[] &#123; 97, 92, 81, 60 &#125;; // Define the query expression. IEnumerable&lt;int&gt; scoreQuery = from score in scores where score &gt; 80 select score;// 此时scoreQuery并无数据 // Execute the query.执行foreach后才有数 foreach (int i in scoreQuery) &#123; Console.Write(i + &quot; &quot;); &#125; &#125;&#125; // Output: 97 92 81 123456789101112var queryLondonCustomers3 =from cust in customerswhere cust.City == &quot;London&quot;orderby cust.Name ascending//descendingselect cust;var query = from cust in Customerwhere cust.City = &quot;BeiJing&quot;select new &#123;Name = cust.Name, City = cust.City&#125;;// 等价于var query = Customer.Where(c =&gt; c.City == &quot;BeiJing&quot;).Select(n =&gt; new &#123;Name = n.Name, City = n.Cith&#125;); 生成到xml 12345678910111213141516171819202122232425262728293031// Create the query.var studentsToXML = new XElement(&quot;Root&quot;, from student in students let scores = string.Join(&quot;,&quot;, student.Scores) select new XElement(&quot;student&quot;, new XElement(&quot;First&quot;, student.First), new XElement(&quot;Last&quot;, student.Last), new XElement(&quot;Scores&quot;, scores) ) // end &quot;student&quot; ); // end &quot;Root&quot;// Execute the query.Console.WriteLine(studentsToXML);/*&lt;Root&gt;&lt;student&gt;&lt;First&gt;Svetlana&lt;/First&gt;&lt;Last&gt;Omelchenko&lt;/Last&gt;&lt;Scores&gt;97,92,81,60&lt;/Scores&gt;&lt;/student&gt;&lt;student&gt;&lt;First&gt;Claire&lt;/First&gt;&lt;Last&gt;O&#x27;Donnell&lt;/Last&gt;&lt;Scores&gt;75,84,91,39&lt;/Scores&gt;&lt;/student&gt;&lt;student&gt;&lt;First&gt;Sven&lt;/First&gt;&lt;Last&gt;Mortensen&lt;/Last&gt;&lt;Scores&gt;88,94,65,91&lt;/Scores&gt;&lt;/student&gt;&lt;/Root&gt;*/ Let标识符 引入查询表达式中任何表达式结果的标识符 1234567891011121314151617181920212223242526var studentQuery5 =from student in studentslet totalScore = student.Scores[0] + student.Scores[1] +student.Scores[2] + student.Scores[3]where totalScore / 4 &lt; student.Scores[0]select student.Last + &quot; &quot; + student.First;//select totalScorevar studentQuery6 =from student in studentslet totalScore = student.Scores[0] + student.Scores[1] +student.Scores[2] + student.Scores[3]select totalScore;double averageScore = studentQuery6.Average();var studentQuery8 =from student in studentslet x = student.Scores[0] + student.Scores[1] +student.Scores[2] + student.Scores[3]where x &gt; averageScoreselect new &#123; id = student.ID, score = x &#125;;// Join products and categories based on CategoryIdvar query = from product in productsjoin category in categories on product.CategoryId equals category.Idselect new &#123; product.Name, category.CategoryName &#125;; 比较集运算 Distinct 返回的序列包含输入序列的唯一元素 12345678910string[] planets = &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Earth&quot; &#125;;IEnumerable&lt;string&gt; query = from planet in planets.Distinct()select planet;/* This code produces the following output:* *Mercury* Venus* Earth* Mars*/ Except 回的序列只包含位于第一个输入序列但不位于第二个输入序列的元素 123456string[] planets1 = &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Jupiter&quot; &#125;;string[] planets2 = &#123; &quot;Mercury&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot; &#125;;IEnumerable&lt;string&gt; query = from planet in planets1.Except(planets2)select planet;//Venus Intersect 返回的序列包含两个输入序列共有的元素 12345678910string[] planets1 = &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Jupiter&quot; &#125;;string[] planets2 = &#123; &quot;Mercury&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot; &#125;;IEnumerable&lt;string&gt; query = from planet in planets1.Intersect(planets2)select planet;/* This code produces the following output:* *Mercury* Earth* Jupiter*/ Union 返回的序列包含两个输入序列的唯一元素 123456789101112string[] planets1 = &#123; &quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Jupiter&quot; &#125;;string[] planets2 = &#123; &quot;Mercury&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot; &#125;;IEnumerable&lt;string&gt; query = from planet in planets1.Union(planets2)select planet;/* This code produces the following output:**Mercury* Venus* Earth* Jupiter* Mars*/","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"C Sharp 补课笔记 -- 迭代器","slug":"C-Sharp-补课笔记-迭代器","date":"2022-01-06T02:30:58.000Z","updated":"2025-03-24T11:37:22.538Z","comments":true,"path":"C-Sharp-补课笔记-迭代器.html","link":"","permalink":"https://silencejql.github.io/C-Sharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%99%A8.html","excerpt":"迭代器方法或 get 访问器可对集合执行自定义迭代。 迭代器方法使用 yield return 语句返回元素，每次返回一个。 到达 yield return 语句时，会记住当前在代码中的位置。 下次调用迭代器函数时，将从该位置重新开始执行。 可以使用 yield break 语句来终止迭代。","text":"迭代器方法或 get 访问器可对集合执行自定义迭代。 迭代器方法使用 yield return 语句返回元素，每次返回一个。 到达 yield return 语句时，会记住当前在代码中的位置。 下次调用迭代器函数时，将从该位置重新开始执行。 可以使用 yield break 语句来终止迭代。 简单示例 123456789101112131415static void Main()&#123; foreach (int number in SomeNumbers()) &#123; Console.Write(number.ToString() + &quot; &quot;); &#125; // Output: 3 5 8 Console.ReadKey();&#125; public static System.Collections.IEnumerable SomeNumbers()&#123; yield return 3; yield return 5; yield return 8;&#125; 迭代器方法或 get 访问器的返回类型可以是 IEnumerable、IEnumerable&lt;T&gt;、IEnumerator 或 IEnumerator&lt;T&gt;。 迭代器可用作一种方法，或一个 get 访问器。 不能在事件、实例构造函数、静&gt;态构造函数或静态终结器中使用迭代器。 必须存在从 yield return 语句中的表达式类型到迭代器返回的 &gt;IEnumerable&lt;T&gt; 类型参数的隐式转换。 在 C# 中，迭代器方法不能有任何 in 、 ref 或 out 参数。 在 C# 中， yield 不是保留字，只有在 return 或 break 关键字之前使用时才有特殊含义。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"C Sharp 补课笔记 -- 变体泛型","slug":"C-Sharp-补课笔记 -- 变体泛型","date":"2022-01-06T01:50:24.000Z","updated":"2025-03-24T11:36:55.079Z","comments":true,"path":"C-Sharp-补课笔记 -- 变体泛型.html","link":"","permalink":"https://silencejql.github.io/C-Sharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0%20--%20%E5%8F%98%E4%BD%93%E6%B3%9B%E5%9E%8B.html","excerpt":"基础知识普及 逆变与协变对应子类与父类之间的转换","text":"基础知识普及 逆变与协变对应子类与父类之间的转换 变体泛型接口 使用 out 关键字将泛型类型参数声明为协变 类型仅用作接口方法的返回类型，不用作方法参数的类型 123456interface ICovariant&lt;out R&gt;&#123; R GetSomething(); // The following statement generates a compiler error. // void SetSomething(R sampleArg);&#125; 此规则有一个例外。 如果具有用作方法参数的逆变泛型委托，则可将类型用作该委托的泛型类型参数 1234interface ICovariant&lt;out R&gt;&#123; void DoSomething(Action&lt;R&gt; callback);&#125; 类型不用作接口方法的泛型约束 1234567interface ICovariant&lt;out R&gt;&#123; // The following statement generates a compiler error // because you can use only contravariant or invariant types // in generic constraints. // void DoSomething&lt;T&gt;() where T : R;&#125; 使用 in 关键字将泛型类型参数声明为逆变 逆变类型只能用作方法参数的类型，不能用作接口方法的返回类型。 逆变类型还可用于泛型约束 1234567interface IContravariant&lt;in A&gt;&#123; void SetSomething(A sampleArg); void DoSomething&lt;T&gt;() where T : A; // The following statement generates a compiler error. // A GetSomething();&#125; 可以在同一接口中同时支持协变和逆变，但需应用于不同的类型参数 1234567interface IVariant&lt;out R, in A&gt;&#123; R GetSomething(); void SetSomething(A sampleArg); R GetSetSomethings(A sampleArg);&#125; 实现变体泛型 在类中实现变体泛型接口时，所用语法和用于固定接口的语法相同 123456789101112interface ICovariant&lt;out R&gt;&#123; R GetSomething();&#125; class SampleImplementation&lt;R&gt; : ICovariant&lt;R&gt;&#123; public R GetSomething() &#123; // Some code. return default(R); &#125;&#125; 实现变体接口的类是固定类 12345678// The interface is covariant.ICovariant&lt;Button&gt; ibutton = new SampleImplementation&lt;Button&gt;();ICovariant&lt;Object&gt; iobj = ibutton;// The class is invariant.SampleImplementation&lt;Button&gt; button = new SampleImplementation&lt;Button&gt;();// The following statement generates a compiler error// because classes are invariant.// SampleImplementation&lt;Object&gt; obj = button; 扩展变体泛型接口 扩展变体泛型接口时，必须使用 in 和 out 关键字来显式指定派生接口是否支持变体。 编译器不会根据正在扩展 的接口来推断变体 123interface ICovariant&lt;out T&gt; &#123; &#125;interface IInvariant&lt;T&gt; : ICovariant&lt;T&gt; &#123; &#125;interface IExtCovariant&lt;out T&gt; : ICovariant&lt;T&gt; &#123; &#125; 尽管 IInvariant&lt;T&gt; 接口和 T 接口扩展的是同一个接口，但泛型类型参数 IExtCovariant&lt;out T&gt; 在前者中为固定参数，在后者中为协变参数。 此规则也适用于逆变泛型类型参数。 无论泛型类型参数 T 在接口中是协变还是逆变，都可以创建一个接口来扩展这两类接口，只要在扩展接口中，该T 泛型类型参数为固定参数 123interface ICovariant&lt;out T&gt; &#123; &#125;interface IContravariant&lt;in T&gt; &#123; &#125;interface IInvariant&lt;T&gt; : ICovariant&lt;T&gt;, IContravariant&lt;T&gt; &#123; &#125; 如果泛型类型参数 T 在一个接口中声明为协变，则无法在扩展接口中将其声明为逆变，反之亦然 123interface ICovariant&lt;out T&gt; &#123; &#125;// The following statement generates a compiler error.// interface ICoContraVariant&lt;in T&gt; : ICovariant&lt;T&gt; &#123; &#125; 变体泛型委托 NET Framework 3.5 引入了变体支持，用于在 C# 中匹配所有委托的方法签名和委托类型。 这表明不仅可以将具有匹配签名的方法分配给委托，还可以将返回派生程度较大的派生类型的方法分配给委托（协变），或者如果方法所接受参数的派生类型所具有的派生程度小于委托类型指定的程度（逆变），也可将其分配给委托。 这包括泛型委托和非泛型委托。 在 .NET Framework 4 或更高版本中，可以启用委托之间的隐式转换，以便在具有泛型类型参数所指定的不同类型按变体的要求继承自对方时，可以将这些类型的泛型委托分配给对方。 若要启用隐式转换，必须使用 in 或 out 关键字将委托中的泛型参数显式声明为协变或逆变。 123456789// Type T is declared covariant by using the out keyword.public delegate T SampleGenericDelegate &lt;out T&gt;();public static void Test()&#123; SampleGenericDelegate &lt;String&gt; dString = () =&gt; &quot; &quot;; // You can assign delegates to each other, // because the type T is declared covariant. SampleGenericDelegate &lt;Object&gt; dObject = dString;&#125; 如果仅使用变体支持来匹配方法签名和委托类型，且不使用 in 和 out 关键字，则可能会发现有时可以使用相同的 lambda 表达式或方法实例化委托，但不能将一个委托分配给另一个委托 在以下代码示例中， SampleGenericDelegate&lt;String&gt; 不能显式转换为 SampleGenericDelegate&lt;Object&gt; ，尽管String 继承 Object 。 可以使用 T 关键字标记 泛型参数 out 解决此问题 12345678910111213public delegate T SampleGenericDelegate&lt;T&gt;();public static void Test()&#123; SampleGenericDelegate&lt;String&gt; dString = () =&gt; &quot; &quot;; // You can assign the dObject delegate // to the same lambda expression as dString delegate // because of the variance support for // matching method signatures with delegate types. SampleGenericDelegate&lt;Object&gt; dObject = () =&gt; &quot; &quot;; // The following statement generates a compiler error // because the generic type T is not marked as covariant. // SampleGenericDelegate &lt;Object&gt; dObject = dString;&#125; 可以使用 out 关键字声明泛型委托中的泛型类型参数协变。 协变类型只能用作方法返回类型，而不能用作方法参数的类型 public delegate R DCovariant&lt;out R&gt;(); 可以使用 in 关键字声明泛型委托中的泛型类型参数逆变。 逆变类型只能用作方法参数的类型，而不能用作方法返回类型 public delegate void DContravariant&lt;in A&gt;(A a);","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"}]},{"title":"Hex文件","slug":"Hex文件","date":"2021-12-19T03:08:17.000Z","updated":"2025-03-24T11:36:06.816Z","comments":true,"path":"Hex文件.html","link":"","permalink":"https://silencejql.github.io/Hex%E6%96%87%E4%BB%B6.html","excerpt":"前面啥也没有","text":"前面啥也没有 格式 Intel Hex文件是遵循Intel Hex文件格式的ASCII文本文件。 文件的每一行中都包含了一个由16进制数据组成hex记录。 标识符 数据长度(1Byte) 偏移地址(2Byte) 数据类型(1Byte) 数据(nByte) 校验码(1Byte) : 02 0000 04 0800 F2 说明 Intel Hex标识符以’:'开头 数据类型 00–数据记录 (8bit/ 16bit/ 32bit) :020000040800F2//（: 02 0000 04 0800 F2）基地址为0x08000000 :104800009004002055940008599200085B9200081B//(: 10 4800 00 09004002055940008599200085B920008 1B)数据存放地址为0x08000000+0x4800,数据长度为0x10,数据内容为：09004002055940008599200085B920008 01–文件结束记录 (8 bit/ 16 bit/ 32 bit) 02–扩展段地址记录 (16 bit/32 bit) 16位的扩展段地址记录用于SBA（segment Base Address）的4-19bit，也被当作USBA(Upper Segment Base Address)，其SBA的0-3bit为0,即该记录定义了数据存放的基地址（USBA &lt;&lt; 4）。 :020000040800F2//（: 02 0000 02 0800 F2）USBA为0800，即基地址为0x0800 &lt;&lt; 4,即等于0x8000。 03–开始段地址记录 (16 bit/ 32 bit) 04–扩展线性地址记录 (32 bit) 32位的扩展线性地址记录用在LBA(Linear Base Address)的16-31bit，也被当作ULBA(Upper Linear Base Address)，其LBA的0-15bit都是0，即该记录定义了数据存放的基地址（ULBA &lt;&lt; 16） :020000040800F2//（: 02 0000 04 0800 F2）ULBA为0800，即基地址为0x0800 &lt;&lt; 16,即等于0x08000000。 05–开始线性地址记录 (32 bit) :0400000508009465F6//(: 04 0000 05 08009465 F6)程序从0x08009465开始执行 校验和的计算是通过将记录当中所有十六进制编码数字对的值相加，以256为模进行补足 检验和 = 0x100 - 累加和 详细说明 数据记录”00” Intel HEX文件由任意数量以回车换行符结束的数据记录组成数据记录外观如下: :10246200464C5549442050524F46494C4500464C33 其中:10 是这个记录当中数据字节的数量.即0x10 ； 2462 是数据将被下载到存储器当中的地址.即0x2462 ； 00 是记录类型( 数 据 记录).即0x00 ； 464C…464C是 数据.分别代表0x46,0x4C… ； 33 是这个记录的校 验和即0x33；计算方法如下：256D-(10H+24H+62H+00H+46H+4CH+55H+49H+44H+20H+50H+52H+4FH+46H+49H+4CH+45H+00H+46H+4CH)/100H=33H； 文件结束(EOF)”01” Intel HEX文件必须以文件结束(EOF) 记录结束这个记录的记录类的值必须是01.EOF 记录 外 观总是如下: :00000001FF 其中:00 是记录当中数据字节的数量. 0000 是数据被下载到存储器当中的地址. 在文件结束记录当中地址是没有意义，被忽略的.0000h 是典型的地址； 01 是记录类型 01( 文件结束记录) FF 是这个记录的校验和, 计算方法如下: 256D-（00H+00H+00H+01H）=FFH； 扩展线性地址记录(HEX386) ”04” 由于每行标识数据地址的只有2Byte，所以最大只能到64K，为了可以保存高地址的数据，就有了Extended Linear AddressRecord。如果这行的数据类型是0x04，那么，这行的数据就是随后数据的基地址。 扩展线性地址记录也叫作32位地址记录或HEX386记录.这些记录含数据的高16位扩展线性地址记录总是有两个数据字节，外观如下： :02000004FFFFFC 其中:02 是这个记录当中 数 据字 节 的 数量. 0000 是地址域, 对于 扩 展 线 性地址 记录 , 这个 域 总是0000. 04 是记录类型 04( 扩 展 线 性地址 记录) FFFF 是地址的高16 位. FC 是这个记录的校 验 和, 计算如下: 256D-（02H+00H+00H+04H+FFH+FFH）/100H=FFH； 当一 个扩展 线 性地址记录被读 取, 存 储于数据域的扩展线性地址被保存，它被应于 从 Intel HEX 文件 读取 来 的 随 后的 记录 . 线 性地址保持有效, 到 它 被另外一 个扩址记录 所改 变。 通 过 把 记录当 中的地址域 与 被移位的 来 自 扩 展 线 性地址 记录 的地址 数 据相加 获 得 数 据 记录 的 绝对 存 储器地址。 以下的例子演示了这个过 程: :0200000480007A //数据记录的绝对存储器地址高16位为0x8000 :100000001D000A00000000000000000000000000C9 :100010000000000085F170706F0104005D00BD00FC 第一行，是Extended Linear Address Record，里面的数据，也就是基地址是0x8000，第二行是DataRecord，里面的地址值是0x0000。那么数据1D000A00000000000000000000000000（共16个字节）要写入FLASH中的地址为 (0x8000&lt;&lt; 16)| 0x0000，也就是写入FLASH的0x80000000这个地址；第三行的数据写入地址为0x80000010.当一个HEX文件的数据超过64k的时候，文件中就会出现多个Extended Linear Address Record。 扩展段地址记录(HEX86)“02“ 扩展段地址记录也叫HEX86 记录 , 它包括4-19 位数据地址段. 扩展段地址记总是有两 个数 据字节 , 外观如下: :020000021200EA 其中:02 是记录当中 数 据字 节 的 数量； 0000 是地址域. 对于 扩 展段地址 记录 , 这个 域 总是0000； 02 是记录类型 02( 扩 展段地址 记录)； 1200 是地址段； EA 是这个记录的校 验 和； 当一 个扩 展段地址 记录 被 读 取, 存 储 于 数 据域的 扩 展段地址被保存, 它 被 应 用于 从 Intel HEX 文件 读 取 来的 随 后的 记录 . 段地址保持有效, 直到 它 被另外一 个扩 展地址 记录 所改 变。 通 过 把 记录当 中的地址域 与 被移位的 来 自 扩 展段地址 记录 的地址 数 据相加 获 得 数 据 记录 的 绝对 存 储器地址。 以下的例子演示了这个过 程… 来自 数 据 记录地址域的地址 2462 + 1200 &lt;&lt; 4 = 00014462","categories":[],"tags":[{"name":"Hex","slug":"Hex","permalink":"https://silencejql.github.io/tags/Hex/"}]},{"title":"轮眉软件调试-棋盘格","slug":"轮眉软件调试-棋盘格","date":"2021-12-14T09:34:59.000Z","updated":"2025-03-07T12:24:54.072Z","comments":true,"path":"轮眉软件调试-棋盘格.html","link":"","permalink":"https://silencejql.github.io/%E8%BD%AE%E7%9C%89%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95-%E6%A3%8B%E7%9B%98%E6%A0%BC.html","excerpt":"前面啥也没有","text":"前面啥也没有 坐标系说明 工位后方是Z轴正方向,右侧为X正方向,上侧为Y正方向 标定界面 参数说明 PixelSize: 传感器像素尺寸 说明: 比如相机Sensor Size 为5.7mm 4.3mm, 分辨率为2592 1944px, 则 PixelSizeH = 5.7 / 2592 PixelSizeV = 4.3 / 1944 左上角: Point3DX: Point3DY: 棋盘格左上角第一个黑块的右下角这一点到地面的高度 Point3DZ: 棋盘格到标定架中心的距离 右边: ChessboardRow: 棋盘格行数 ChessboardColumn: 棋盘格列数 ChessboardLength: 棋盘格边长 ChessboardDistance: 棋盘格到相机的距离 + 110(外壳镜面到相机传感器的距离) 相机坐标: Camera_X: Camera_Y: 相机玻璃面到标定架中心线的距离 Camera_Z: 相机玻璃面中心到地的距离 标定结果 内参标定完成后焦距f应接近相机镜头实际焦距大小; fx,fy两数接近 可以检查棋盘格识别点,表示识别到每个点的像素坐标值 测试界面 与四个孔的标定架不同点: 轮眉距离: 轮眉到车中轴线的距离 测试点识别同样是识别ROI中最下面的白点","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"PostgreSQL数据库安装配置","slug":"PostgreSQL数据库安装配置","date":"2021-12-04T07:19:10.000Z","updated":"2025-03-24T11:36:14.107Z","comments":true,"path":"PostgreSQL数据库安装配置.html","link":"","permalink":"https://silencejql.github.io/PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html","excerpt":"Postgre数据库安装与配置","text":"Postgre数据库安装与配置 安装 目前用的数据库版本为: postgresql-9.5.3-1-windows.exe 驱动安装包为: Setup_Npgsql-2.2.3.0-r2-net40.exe 安装包获取: 自己想办法 网盘路径:/BBK_File_Server/汽车测试事业部/17-转存（每月1日定期清理）/Justin/程序安装包 数据库安装 安装中需设置数据库密码,检测线密码设置为:123,其他自己看着办 安装最后界面取消勾选后点击完成即可 驱动安装 双击安装包一切默认即可 配置 新建数据库 打开安装后的数据库软件:PostgreSQL 9.5 (x86)\\pgAdmin III 点击新建数据库,名称填LocalDB,其他默认点击确定 数据库恢复 检测线联网配置 PostgreSQL配置","categories":[],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://silencejql.github.io/tags/PostgreSQL/"}]},{"title":"轮眉软件调试","slug":"轮眉软件调试","date":"2021-12-04T04:56:52.000Z","updated":"2025-03-07T12:24:46.589Z","comments":true,"path":"轮眉软件调试.html","link":"","permalink":"https://silencejql.github.io/%E8%BD%AE%E7%9C%89%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95.html","excerpt":"BBK轮眉软件调试—标定板为四个孔的版本 棋盘格: 轮眉软件调试-棋盘格 本文未说明的地方自己琢磨吧","text":"BBK轮眉软件调试—标定板为四个孔的版本 棋盘格: 轮眉软件调试-棋盘格 本文未说明的地方自己琢磨吧 相机配置 轮眉相机配置 软件菜单 标定 配置 标定界面 参数说明 左上角为四个相机 图像算法选择: Camera: 相机参数 曝光时间 增益 数字移位n(像素值*2^n)(有滤镜的情况下标定时可配置为1) 标定板: Board_CenterX: Board_CenterY: 标定板后边沿(黑孔处)到标定架中心的距离 Board_CenterZ: 四个识别点组成矩形中心到地的高度 Board_ColumnSpace: 四个识别点列宽 Board_RowSpace: 四个标定点行高 算法参数: Threshold: 二值化阈值 AreaMin: 识别点时的最小像素值 AreaMax: 识别点时的最大像素值 ImageType: 图形格式 相机坐标: Camera_X: Camera_Y: 相机玻璃面到标定架中心线的距离 Camera_Z: 相机玻璃面中心到地的距离 标定注意事项 标定界面通过调节曝光增益等参数使得读取的标定板图像黑白分明,能清晰看到四个标定点,然后点击识别及内外参标定. 焦距f应接近镜头实际焦距,内参标定后大概3500左右,xy相差不大 配置界面 左上角为参数配置选择 左下角为四个相机 轮眉距离: 标定板后方黑点到轮眉相机前玻璃面的距离 Camera: 相机参数 曝光时间 增益 数字移位n(像素值*2^n)(一般配置为0) 轮眉参数: ImageType: Offset: 轮眉高度 = 计算值 + Offset 算法参数: AreaMin: 识别时最小像素范围 AutoROIWide: Threshold: 二值化阈值 车型配置 新建一个参数配置,上车后开启激光,调节曝光等参数使读取到的图像黑白分明,能明确识别到激光在轮眉处的断点,调整ROI大小将其框住. 软件中轮眉识别方法: 在ROI中从下往上根据设定参数识别第一个亮点. 设备图片 实车测试 棋盘格","categories":[{"name":"手册","slug":"手册","permalink":"https://silencejql.github.io/categories/%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"轮眉","slug":"轮眉","permalink":"https://silencejql.github.io/tags/%E8%BD%AE%E7%9C%89/"}]},{"title":"轮眉相机配置","slug":"轮眉相机配置","date":"2021-12-04T03:04:50.000Z","updated":"2025-03-07T12:25:09.432Z","comments":true,"path":"轮眉相机配置.html","link":"","permalink":"https://silencejql.github.io/%E8%BD%AE%E7%9C%89%E7%9B%B8%E6%9C%BA%E9%85%8D%E7%BD%AE.html","excerpt":"BBK轮眉相机配置 本文未说明的地方自己琢磨吧","text":"BBK轮眉相机配置 本文未说明的地方自己琢磨吧 Basler驱动安装 根据相机版本安装对应相机驱动 网卡配置 配置巨帧等,如图: 相机IP配置 识别相机 打开控制面板IP配置 打开Pylon IPConfig软件 根据IP与Serial Number的对应对网卡进行标注 配置静态IP 给相机分配静态IP 分配规则: 1.网卡与相机在同一网段 2.不同相机分配不同网段 例如: 相机检查 打开Pylon View软件检查各相机打开及图像读取是否正常","categories":[{"name":"手册","slug":"手册","permalink":"https://silencejql.github.io/categories/%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"轮眉","slug":"轮眉","permalink":"https://silencejql.github.io/tags/%E8%BD%AE%E7%9C%89/"}]},{"title":"SQLServer权限配置","slug":"SQLServer权限配置","date":"2021-10-08T09:19:53.000Z","updated":"2025-03-07T12:39:40.998Z","comments":true,"path":"SQLServer权限配置.html","link":"","permalink":"https://silencejql.github.io/SQLServer%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE.html","excerpt":"前面啥也没有","text":"前面啥也没有 关键字 GRANT:赋予权限 REVOKE:收回已经授予的权限 DENY:禁掉某个权限 123456789--赋予Jack用户对表student的SELECT,UPDATE,DELETE权限​GRANT SELECT,UPDATE,DELETE ON TABLE student TO Jack--收回Jack SELECT 权限REVOKE SELECT FROM Jack--拒绝Jack 的SELECT 权限DENY SELECT TO Jack 12345678910111213create login test with password=&#x27;test&#x27;,default_database=JIAOGUAN --此登录账户默认拥有数据库JIAOGUAN的权限use JIAOGUANcreate user test for login test with default_schema=dbo --dbo为DataBaseOwner的简写，每个数据库都有一个dbo用户exec sp_addrolemember &#x27;db_owner&#x27;, &#x27;test&#x27; --将test加入 db_owner角色use JIAOGUANdeny insert on Student to test --拒绝test用户对Student表执行insertuse JIAOGUANdeny select on Student(gender,birth) to test --拒绝test用户访问Student表的gender和birth字段","categories":[],"tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"https://silencejql.github.io/tags/SQLServer/"}]},{"title":"SAE-J1939","slug":"SAE-J1939","date":"2021-10-06T01:40:41.000Z","updated":"2025-03-24T11:35:52.608Z","comments":true,"path":"SAE-J1939.html","link":"","permalink":"https://silencejql.github.io/SAE-J1939.html","excerpt":"J1939主要需要了解ID组成,根据所需数据查找SPN,PGN然后组成ID; 了解帧格式 了解单,多帧数据请求","text":"J1939主要需要了解ID组成,根据所需数据查找SPN,PGN然后组成ID; 了解帧格式 了解单,多帧数据请求 简介 J1939标准用于卡车、公共汽车和移动液压等重型车辆 J1939标准定义的大部分报文均旨在广播,使用CAN 2.0B协议中定义的29位标识符 协议结构 J1939物理层（基于J1939-11/15） 速率:250kbit/s 差动电压方式传输,隐性电压均为2.5,显性电压1.5,3.5 终端电阻:120欧 最大传输线长40m 同一网络最多ECU个数为30 J1939数据链路层（基于J1939-21） 优先级/P 扩展数据页/EDP 数据页/DP PDU格式/PF 特定PDU/PS 源地址/SA DATA 3bit 1bit 1bit 8bit 8bit 8bit 0~64bit P：Priority，优先级，调整该值可改变报文在总线上的仲裁优先级 These three bits are used to optimize message latency for transmission onto the bus only. They should be globally masked off by the receiver (ignored). The priority of any message can be set from highest, 0 (0002), to lowest, 7 (1112). The default for all control oriented messages is 3 (0112). The default for all other informational, proprietary, request, and ACK messages is 6 (1102). This permits the priority to be raised or lowered in the future as new PGNs are assigned and bus traffic changes. A recommended priority is assigned to each PGN when it is added to the application layer document. However, the priority field should be reprogrammable to allow for network tuning by the OEM should the need arise EDP及DP：扩展数据页及数据页，当前均为0 The Extended Data Page bit is used in conjunction with the Data Page bit to determine the structure of the CAN identifier of the CAN data frame. All J1939 messages should set the Extended Data Page bit to ZERO on transmit. See Table 3, Definition of Extended Data Page and Data Page Use, to find the defined uses of the EDP and DP fields. Future definitions might possibly be expanding the PDU Format field, defining new PDU formats, or increasing the address space Extended Data Page bit 25 CAN ID bit 25 Data Page bit 24 CAN ID bit 24 Description 0 0 SAE J1939 page 0 PGNs 0 1 SAE J1939 page 1 PGNs 1 0 SAE J1939 reserved 1 1 ISO 15765-3 defined PF：PDU format，确定PDU格式，如PF值区间为0~239（0x00~0xEF），则表明是PDU1格式，如区间为240~255（0xF0~0xFF），则表明是PDU2格式。该场是PGN的组成部分 PS：PDU Specific，如为PUD1格式，则该场表示帧的目标地址，如为PDU2格式，则表示组扩展GE（用于扩展PGN的个数） PDU Format Field PDU Specific Field PDU1 Format 0-239 Destination Address PDU2 Format 240-255 Group Extension SA：Source Address，源地址 The Source Address field is 8 bits long. There shall only be one device on the network with a given source address. Therefore, the source address field assures that the CAN identifier is unique, as required by CAN. Address management and allocation is detailed in SAE J1939-81. Procedures are defined in SAE J1939-81 to prevent duplication of source addresses. Reference SAE J1939 Appendix B, Tables B2 through B9, for source address assignments 在ID场中，Priority值根据需要调整，EDP和DP一般均为0，PF和PS决定了报文的PGN，SA体现了报文的发送节点。 请求PGN PGN55904(EA00)专门用于数据请求 定义:用于从一个或多个网络设备请求参数组 速率:用户定义,推荐每秒不多于2~3次 数据长度:3字节 数据页:0 PDU格式:234(EA) PDU特定域:目标地址 缺省优先级:6 参数组编号:59904(EA00) 参数定义:字节1,2,3位被请求参数组编号 例如:请求发动机转速 Send:18EA00FF 04 F0 00 recv:0CF00400 00 00 00 00 00 00 00 00 多帧传输 定义 缩写 英文 释义 TP Transport Protocol 传输协议 CM Connection Management 连接管理 RTS Request to Send 请求发送 CTS Clear to Send 允许发送 DT Data Transmission 数据传输 BAM Broadcast Announce Message 广播报文 TP.CM 数据 Byte0 Byte1 Byte2 Byte3 Byte4 Byte5 Byte6 Byte7 TP.CM 控制字 报文字节数 全部数据包数 最大数据包数 能够发送的数据包数 要发送的下一个数据包数 包编号 TP.CM.RTS 16 整个报文的字节数 全部数据包数 最大数据包(默认FF) PGN TP.CM.CTS 17 能够发送的包数(不超过RTS[4]) 要发送下一数据包编号 FF FF PGN TP.CM.Abort 255 放弃连接原因 FF FF FF PGN TP.CM.EndofMsgAsk 19 整个报文字节数 全部数据包数 FF PGN 请求多帧示例 T:18EA0081 EC FE 00 R:18EC8100 10 12 00 03 FF EC FE 00 T:18EC0081 11 03 01 FF FF EC FE 00 R:18EB8100 01 XX XX XX XX XX XX XX R:18EB8100 02 XX XX XX XX XX XX XX R:18EB8100 03 XX XX XX XX FF FF FF T:18EC0081 13 12 00 03 FF EC FE 00 J1939网络层（基于J1939-31） J1939应用层（基于J1939-71） This particular SAE Recommended Practice, SAE J1939-71, describes an Application Layer for vehicle use. 定义SPN与PGN J1939网络管理（基于J1939-81） J1939诊断（基于J1939-13/73） DM1 Diagnostic Message 1, Active Diagnostic Trouble Codes DM2 Diagnostic Message 2, Previously Active Diagnostic Trouble Codes DM3 Diagnostic Message 3, Diagnostic Data Clear/Reset For Previously Active DTCs DM4 Diagnostic Message 4, Freeze Frame Parameters DM5 Diagnostic Message 5, Diagnostic Readiness DM6 Diagnostic Message 6, Continuously Monitored Systems Test Results DM7 Diagnostic Message 7, Command Non-Continuously Monitored Test DM8 Diagnostic Message 8, Test Results For Non-Continuously Monitored Systems DM9 Diagnostic Message 9, Oxygen Sensor Test Results DM10 Diagnostic Message 10, Non-Continuously Monitored Systems Test IDs Support DM11 Diagnostic Message 11, Diagnostic Data Clear/Reset For Active DTCs DM12 Diagnostic Message 12, Emissions Related Active DTCs DTC Diagnostic Trouble Code FTP Federal Test Procedure MIL Malfunction Indicator Lamp NA Not applicable PID Parameter Identifier (SAE J1587 or SAE J1979) OBD II On Board Diagnostics II","categories":[],"tags":[{"name":"J1939","slug":"J1939","permalink":"https://silencejql.github.io/tags/J1939/"}]},{"title":"AES加密","slug":"AES加密","date":"2021-09-07T01:42:20.000Z","updated":"2025-03-24T11:35:37.783Z","comments":true,"path":"AES加密.html","link":"","permalink":"https://silencejql.github.io/AES%E5%8A%A0%E5%AF%86.html","excerpt":"高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法","text":"高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法 AES加密过程 AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。（Rijndael加密法因支持更大的区块，其矩阵行数可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤： AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 ShiftRows—将矩阵中的每个横列进行循环式移位。 MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。 C#代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/// &lt;summary&gt;/// 默认密钥-密钥的长度必须是32/// &lt;/summary&gt;private const string PublicKey = &quot;1234567890adbcde&quot;;/// &lt;summary&gt;/// 默认向量/// &lt;/summary&gt;private const string Iv = &quot;1234567890hjlkew&quot;;/// &lt;summary&gt;/// AES加密/// &lt;/summary&gt;/// &lt;param name=&quot;str&quot;&gt;需要加密的字符串&lt;/param&gt;/// &lt;param name=&quot;key&quot;&gt;32位密钥&lt;/param&gt;/// &lt;returns&gt;加密后的字符串&lt;/returns&gt;public static string Encrypt(string str, string key)&#123; Byte[] keyArray = Encoding.UTF8.GetBytes(key); Byte[] toEncryptArray = Encoding.UTF8.GetBytes(str); var rijndael = new System.Security.Cryptography.RijndaelManaged(); rijndael.Key = keyArray; rijndael.BlockSize = 128; rijndael.Mode = System.Security.Cryptography.CipherMode.CBC;// rijndael.Padding = System.Security.Cryptography.PaddingMode.Zeros;// rijndael.IV = Encoding.UTF8.GetBytes(Iv); System.Security.Cryptography.ICryptoTransform cTransform = rijndael.CreateEncryptor(); Byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Convert.ToBase64String(resultArray, 0, resultArray.Length);&#125;/// &lt;summary&gt;/// AES解密/// &lt;/summary&gt;/// &lt;param name=&quot;str&quot;&gt;需要解密的字符串&lt;/param&gt;/// &lt;param name=&quot;key&quot;&gt;32位密钥&lt;/param&gt;/// &lt;returns&gt;解密后的字符串&lt;/returns&gt;public static string Decrypt(string str, string key)&#123; Byte[] keyArray = System.Text.Encoding.UTF8.GetBytes(key); Byte[] toEncryptArray = Convert.FromBase64String(str); var rijndael = new System.Security.Cryptography.RijndaelManaged(); rijndael.Key = keyArray; rijndael.Mode = System.Security.Cryptography.CipherMode.CBC; rijndael.Padding = System.Security.Cryptography.PaddingMode.Zeros; rijndael.IV = System.Text.Encoding.UTF8.GetBytes(Iv); System.Security.Cryptography.ICryptoTransform cTransform = rijndael.CreateDecryptor(); Byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return System.Text.Encoding.UTF8.GetString(resultArray);&#125;","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"AES","slug":"AES","permalink":"https://silencejql.github.io/tags/AES/"}]},{"title":"河北长安中车联网","slug":"河北长安中车联网","date":"2021-08-28T07:04:44.000Z","updated":"2025-03-24T11:35:24.311Z","comments":true,"path":"河北长安中车联网.html","link":"","permalink":"https://silencejql.github.io/%E6%B2%B3%E5%8C%97%E9%95%BF%E5%AE%89%E4%B8%AD%E8%BD%A6%E8%81%94%E7%BD%91.html","excerpt":"前面啥也没有","text":"前面啥也没有 通过VIN获取车型信息 12345678910111213141516171819202122232425262728293031private bool GetVehInfo_MES()&#123; bool _return = false; DataTable dt = DbOperation.GetVehInfo_MES(this.tB_vin.Text);//通过VIN获取车型信息 if (dt != null &amp;&amp; dt.Rows.Count &gt; 0) &#123; VehInfo.SetVehInfo_MES(dt);//设置车型参数信息 _return = true; &#125; return _return;&#125;public static DataTable GetVehInfo_MES(string vin)&#123; DataTable dt = null; string sql = TransferQueryDoc.GetQueryDoc_Login(&quot;L10101&quot;, JsonHelper.JsonSerializerByArrayData&lt;string&gt;(new List&lt;string&gt; &#123; vin &#125;.ToArray())); /* strSql.Append(&quot;SELECT * FROM T_CAR_BRIEF_PARAMETER_V WHERE VIN_CODE=&#x27;&quot;); strSql.Append(strInfo[0]); strSql.Append(&quot;&#x27;&quot;); break; */ if (!string.IsNullOrEmpty(sql)) &#123; dt = DbOperation.Query(sql, 1); &#125; return dt;&#125; 通过MODEL_ID可以获取VSN 侧滑软件测试流程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601等待车型 数据库查询当前工位是否有车型信息SELECT INSP_ITEM,TASKID,VIN FROM &quot;);strSql.Append(&quot;CVIC_INSP_TASK_TMP WHERE CUR_WP=&quot;);strSql.Append(strInfo[0]);strSql.Append(&quot; AND CHECK_STATE=&#x27;G0&#x27; AND LINE_ID=&#x27;&quot;);strSql.Append(strInfo[1]);strSql.Append(&quot;&#x27; ORDER BY PRIORITY DESC,BG_TIME ASC2获取车型信息SELECT * FROM &quot;);strSql.Append(&quot;CVIC_INSP_TASK_TMP WHERE TASKID=&#x27;&quot;);strSql.Append(strInfo[0]);strSql.Append(&quot;&#x27; AND CHECK_STATE=&#x27;G0&#x27; AND VIN=&#x27;&quot;);strSql.Append(strInfo[1]);strSql.Append(&quot;&#x27; ORDER BY PRIORITY DESC,BG_TIME ASC3获取标准SELECT SVL,SVH FROM CVIC_INSP_STD_TMP WHERE TASKID=4初始化设备等待车辆5保存数据strSql.Append(&quot;INSERT INTO CVIC_SS_RESULT_TMP(TASKID,VEH_NO,CHECK_DATA,JUDGE,BG_TIME,INSP_SEQ,ED_TIME)VALUES(&quot;);protected bool SaveResult()&#123; List&lt;string&gt; data = new List&lt;string&gt;(); string tmp = &quot;&quot;; for (int i = 0; i &lt; 6; i++) &#123; switch (i) &#123; case 0: tmp = VehInfo.TASKID; break; case 1: tmp = VehInfo.VIN; break; case 2: tmp = string.Format(&quot;&#123;0:F1&#125;&quot;, VehInfo.DATA[0]); break; case 3: tmp = string.Format(&quot;&#123;0:N0&#125;&quot;, VehInfo.JUDGE[0]); break; case 4: tmp = VehInfo.BGTIME; break; case 5: tmp = VehInfo.CheckSeq.ToString(); break; &#125; data.Insert(i, tmp); &#125; return DbOperation.SaveResult(data);&#125;foreach (string s in strInfo)&#123;strSql.Append(&quot;&#x27;&quot; + s + &quot;&#x27;&quot;);strSql.Append(&quot;,&quot;);&#125;strSql.Append(&quot;CONVERT(VARCHAR(24), GETDATE(), 120)&quot;);strSql.Append(&quot;)&quot;); 12345678Process currentproc = Process.GetCurrentProcess();Process[] processcollection = Process.GetProcessesByName(currentproc.ProcessName);if (processcollection.Length &gt; 1)&#123; MessageBox.Show(&quot;应用程序已经在运行中。。&quot;); Thread.Sleep(1000); Environment.Exit(1);&#125;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Linux C","slug":"Linux-C","date":"2021-07-17T06:23:31.000Z","updated":"2025-03-25T03:24:02.180Z","comments":true,"path":"Linux-C.html","link":"","permalink":"https://silencejql.github.io/Linux-C.html","excerpt":"linux编译、调试c、c++","text":"linux编译、调试c、c++ 安装g++/gcc 创建cpp文件 编译cpp文件生成可执行文件 g++ *.cpp -o outfile 编译*.cpp文件生成可执行文件outfile 拓展 1、没有任何选项：gcc helloworld.c 结果会在与helloworld.c相同的目录下产生一个a.out的可执行文件。 2、-o选项，指定输出文件名：gcc -o helloworld helloworld.c -o意思是Output即需要指定输出的可执行文件的名称。这里的名称为helloworld。 3、-c选项，只编译，不汇编连接：gcc -c helloworld.c -c意思就是Compile，产生一个叫helloworld.o的目标文件 4、-S选项，产生汇编源文件：gcc -s helloworld.c -S意思就是assemble，产生一个叫helloworld.s的汇编源文件 5、-E选项，预处理C源文件：gcc -E helloworld.c -E意思就是prEprocess。输出不是送到一个文件而是标准输出。当然可以对它进行重定向： gcc -E helloworld.c &gt; helloworld.txt 二、优化选项 7、-O选项，基本优化：gcc -O helloworld.c -O意思就是Optimize，产生一个经过优化的叫作a.out的可执行文件。也可以同时使用-o选项，以指定输出文件名。如： gcc -O -o test helloworld.c 即会产生一个叫test的经过优化的可执行文件。 8、-O2选项，最大优化：gcc -O2 helloworld.c 产生一个经过最大优化的叫作a.out的可执行文件。 三、调试选项 9、-g选项，产生供gdb调试用的可执行文件：gcc -g helloworld.c 产生一个叫作a.out的可执行文件，大小明显比只用-o选项编译汇编连接后的文件大。 10、-pg选项，产生供gprof剖析用的可执行文件：gcc -pg helloworld.c 产生一个叫作a.out的执行文件，大小明显比用-g选项后产生的文件还大。 执行 ./outfile 调试 1.编译：gcc -o xxx xxx.c 2.生成可调试文件：gcc -o xxx -g xxx.c 3.调试程序：gdb xxx 4.执行程序： start 从程序第一步开始执行 run 直接运行程序到结束或者断点处 5.设置断点：break line(行数）或函数名或者条件表达式 break 6 在第6行设置断点 break Swap 在Swap函数入口设置断点 break 6 if i == 10 在第6行设置断点，要求i == 10 6.删除断点： clear 删除所有断点 clear 行号 : 删除这行的断点 clear 函数名 : 删除该函数的断点 7.info 查看断点 8.c 继续执行到下一个断点 9.print +变量 打印变量值 10.n 下一步 11.q 退出调试 gcc与g++ gcc 和 g++ 的区别无非就是调用的编译器不同, 并且传递给链接器的参数不同. g++ 会把 .c 文件当做是 C++ 语言 (在 .c 文件前后分别加上 -xc++ 和 -xnone, 强行变成 C++), 从而调用 cc1plus 进行编译. g++ 遇到 .cpp 文件也会当做是 C++, 调用 cc1plus 进行编译. g++ 还会默认告诉链接器, 让它链接上 C++ 标准库. gcc 会把 .c 文件当做是 C 语言. 从而调用 cc1 进行编译. gcc 遇到 .cpp 文件, 会处理成 C++ 语言. 调用 cc1plus 进行编译. gcc 默认不会链接上 C++ 标准库.","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://silencejql.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://silencejql.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://silencejql.github.io/tags/Linux/"}]},{"title":"WebServices创建配置与调用","slug":"WebServices创建配置与调用","date":"2021-07-10T05:44:12.000Z","updated":"2023-04-18T02:46:50.289Z","comments":true,"path":"WebServices创建配置与调用.html","link":"","permalink":"https://silencejql.github.io/WebServices%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B0%83%E7%94%A8.html","excerpt":"ASP.Net C# 创建WebService接口并发布","text":"ASP.Net C# 创建WebService接口并发布 启用Windows IIS功能 操作：控制面板-程序和功能-启用或关闭windows功能 安装Internet Information Services及可承载的Web核心 Webservice接口创建 新建项目 新建文件 创建文件后默认HelloWord接口 Webservice发布 Webservice接口发布到文件夹 项目右键发布选择发布到文件夹，配置好路径后点击发布即可 IIS部署到默认网站 添加虚拟目录 转换为应用程序 添加默认文档 默认文档名为项目中创建Webservice的类名.asmx IIS部署自定义网站 右键网站，添加网站 避坑操作 接口测试 点击IIS中的浏览*：80(http)或访问http://localhost/别名/默认文档名","categories":[],"tags":[{"name":"WebService","slug":"WebService","permalink":"https://silencejql.github.io/tags/WebService/"}]},{"title":"查缺补漏-CSharp","slug":"查缺补漏-CSharp","date":"2021-07-02T04:57:02.000Z","updated":"2025-03-24T11:35:14.870Z","comments":true,"path":"查缺补漏-CSharp.html","link":"","permalink":"https://silencejql.github.io/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-CSharp.html","excerpt":"记录搬砖过程中遇到的疑问","text":"记录搬砖过程中遇到的疑问 构造函数 子类构造函数始终默认调用父类无参构造函数 若父类没有无参构造函数时，子类应显式调用父类有参构造函数，否则编译不过 123456789101112131415161718192021222324252627282930class Program &#123; static void Main(string[] args) &#123; //Console.WriteLine(&quot;Hello World!&quot;); TestFunc(); &#125; static void TestFunc() &#123; Child c = new Child(&quot;22&quot;); &#125; &#125; class BassTest &#123; //public BassTest() //&#123;Console.WriteLine(&quot;BassNoneParam&quot;);&#125; public BassTest(string s) : this(s,&quot;333&quot;) &#123;Console.WriteLine(&quot;BassOneParam&quot; + s);&#125; public BassTest(string s, string t) &#123;Console.WriteLine(&quot;BassTwoParam&quot; + s + t);&#125; &#125; class Child : BassTest &#123; //public Child() //&#123;Console.WriteLine(&quot;ChildNoneParam&quot;);&#125; public Child(string s) : this(s,&quot;111&quot;) &#123;Console.WriteLine(&quot;ChildOneParam&quot; + s);&#125; public Child(string s, string t):base(s) &#123;Console.WriteLine(&quot;ChildTwoParam&quot; + s + t);&#125; &#125; 示例中：this()调用子类中对应参数的构造函数 base()调用父类中对应参数的构造函数 Child c = new Child(&quot;22&quot;);输出为： BassTwoParam22333 BassOneParam22 ChildTwoParam22111 ChildOneParam22","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"构造函数","slug":"构造函数","permalink":"https://silencejql.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"}]},{"title":"BBK程序解析","slug":"BBK程序解析","date":"2021-04-27T08:40:16.000Z","updated":"2025-03-07T12:39:14.016Z","comments":true,"path":"BBK程序解析.html","link":"","permalink":"https://silencejql.github.io/BBK%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90.html","excerpt":"前面啥也没有","text":"前面啥也没有 FreeFormsAlways 程序入口Main() CheckAppHasStart()//判断程序是否已经打开 Initialize()// BackupStart()//Log备份 Environment.GetCommandLineArgs() System.Threading.Mutex(true, sysName, out IsNew) GetStartFile()//获取启动程序文件名 SystemIni(OpenFile, ref Inform)//初始化程序并获取主界面 ReadDataXml()读取xml文件 Configs.ReadXml()读取配置文件 MyLoadXml(xDoc, GetFullPath(XmlFile))加载xml文件 UpdateObjectList()实例化对象列表中的对象 GreateProjectList()创建组合列表 CheckProjectList()检查 BeginExePro(“Always”)//执行Always线程 Run(Inform, true)//执行显示窗体 ExeProject()//执行组合","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"MQTT","slug":"MQTT","date":"2021-03-30T06:56:41.000Z","updated":"2025-03-07T12:39:04.430Z","comments":true,"path":"MQTT.html","link":"","permalink":"https://silencejql.github.io/MQTT.html","excerpt":"前面啥也没有","text":"前面啥也没有 简介 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的&quot;轻量级&quot;通讯协议，协议构建于TCP/IP协议上 MQTT协议有三种身份：发布者、代理、订阅者，发布者和订阅者都为客户端，代理为服务器，同时消息的发布者也可以是订阅者 MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成","categories":[],"tags":[]},{"title":"BEP独立大灯数据接收","slug":"BEP独立大灯数据接收","date":"2021-03-20T06:40:18.000Z","updated":"2025-03-25T03:25:54.628Z","comments":true,"path":"BEP独立大灯数据接收.html","link":"","permalink":"https://silencejql.github.io/BEP%E7%8B%AC%E7%AB%8B%E5%A4%A7%E7%81%AF%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6.html","excerpt":"上位机软件通过TCP读取独立大灯测试数据，参考武汉日产现场。","text":"上位机软件通过TCP读取独立大灯测试数据，参考武汉日产现场。 BEP大灯配置 SoftWare Config–NCA/Host Comm Settings中 NCA Setting使能Use Results Config File 关闭Send HLA Tests To Run 配置文件 NcaResults.xml hoststring.xml","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Markdown语法说明","slug":"Markdown语法说明","date":"2021-01-04T07:39:26.000Z","updated":"2025-03-24T11:59:33.448Z","comments":true,"path":"Markdown语法说明.html","link":"","permalink":"https://silencejql.github.io/Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E.html","excerpt":"[参考](https://www.appinn.com/markdown/)","text":"[参考](https://www.appinn.com/markdown/) 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 ``标签。 如果你确实想要依赖 Markdown 来插入 ``标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 ，但是简单地「每个换行都转换为」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============​This is an H2------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1​## 这是 H2​###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 #​## 这是 H2 ##​### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 1234567891011121314&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.​&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点： 1231. Bird2. McHale3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的列表标记写成： 1231. Bird1. McHale1. Parish 或甚至是： 1233. Bird1. McHale8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 123456* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 `` 标签包起来，举例来说： 12* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个： 123* Bird​* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.​ Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs.​ This is the second paragraph in the list item. You&#x27;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.​* Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote:​ &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： 123* 一列表项包含一个列表区块：​ &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 和 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： ​``` 这是一个代码区块。 12Markdown 会转换成： 这是一个普通段落： ​ 这是一个代码区块。 12这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: ​ tell application \"Foo\" beep end tell 12会被转换为： Here is an example of AppleScript: ​ tell application \"Foo\" beep end tell 1234一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &copy; 2004 Foo Corporation 12会被转换为： &lt;div class=\"footer\"&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 12345代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * ​ *** ​ ***** ​ - - - ​ --------------------------------------- 12345678## 区段元素### 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。不管是哪一种，链接文字都是用 [方括号] 来标记。要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ \"Title\") inline link. ​ [This link](http://example.net/) has no title attribute. 12会产生： This is an example inline link. ​ This link has no title attribute. 12如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 12参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 12你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 12接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ \"Optional Title Here\" 123456789链接内容定义的形式为：方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址选择性地接着 title 内容，可以用单引号、双引号或是括弧包着下面这三种链接的定义都是相同： [foo]: http://example.com/ \"Optional Title Here\" [foo]: http://example.com/ 'Optional Title Here' [foo]: http://example.com/ (Optional Title Here) 1234请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。链接网址也可以用方括号包起来： [id]: \"Optional Title Here\" 12你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here \"Optional Title Here\" 1234网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 12隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 &quot;Google&quot; 链接到 google.com，你可以简化成： [Google][] 12然后定义链接内容： [Google]: http://google.com/ 12由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 1然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 1234链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. ​ [1]: http://google.com/ \"Google\" [2]: http://search.yahoo.com/ \"Yahoo Search\" [3]: http://search.msn.com/ \"MSN Search\" 12如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. ​ [google]: http://google.com/ \"Google\" [yahoo]: http://search.yahoo.com/ \"Yahoo Search\" [msn]: http://search.msn.com/ \"MSN Search\" 12上面两种写法都会产生下面的 HTML。 I get 10 times more traffic from Google than from Yahoo or MSN. 12下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ \"Google\") than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or [MSN](http://search.msn.com/ \"MSN Search\"). 12345678参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。## 强调Markdown 使用星号（`*`）和底线（`_`）作为标记强调字词的符号，被 `*` 或 `_` 包围的字词会被转成用 标签包围，用两个`*`或`_`包起来的话，则会被转成，例如： *single asterisks* ​ _single underscores_ ​ **double asterisks** ​ __double underscores__ 12会转成： single asterisks ​ single underscores ​ double asterisks ​ double underscores 1234你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间： un*frigging*believable 1234但是如果你的 `\\*` 和 _ 两边都有空白的话，它们就只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \\*this text is surrounded by literal asterisks\\* 123代码如果要标记一小段行内代码，你可以用反引号把它包起来（```），例如： Use the `printf()` function. 12会产生： Use the printf() function. 12345如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：``There is a literal backtick (`) here.``这段语法会产生： There is a literal backtick (`) here. 12代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` ​ A backtick-delimited string in a code span: `` `foo` `` 12会产生： A single backtick in a code span: ` ​ A backtick-delimited string in a code span: `foo` 12在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don't use any `` tags. 12转为： Please don't use any &lt;blink&gt; tags. 12你也可以这样写： `&#8212;` is the decimal-encoded equivalent of `&mdash;`. 12以产生： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. 1234567图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ​ ![Alt text](/path/to/img.jpg \"Optional title\") 1234567详细叙述如下：一个惊叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 &#x27;title&#x27; 文字。参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 123456到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `` 标签。## 其它### 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/ 12Markdown 会转为： http://example.com/ 12邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： address@example.com 12Markdown 会转成： address@exa mple.com 12345678910在浏览器里面，这段字串（其实是 `[address@example.com](mailto:address@example.com)`）会变成一个可以点击的「address@example.com」链接。（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）### 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `` 标签），你可以在星号的前面加上反斜杠：`\\*literal asterisks\\*`Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 井字号 加号 减号 . 英文句点 ! 惊叹号","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://silencejql.github.io/tags/Markdown/"}]},{"title":"UDP","slug":"UDP","date":"2020-12-01T02:31:29.000Z","updated":"2025-03-24T11:34:46.696Z","comments":true,"path":"UDP.html","link":"","permalink":"https://silencejql.github.io/UDP.html","excerpt":"前面啥也没有","text":"前面啥也没有 示例 12345678910111213141516171819202122232425262728static void Main(string[] args) &#123; UdpClient client = new UdpClient(new IPEndPoint(IPAddress.Any, 0));//不指定网卡、端口发送 client = new UdpClient(new IPEndPoint(IPAddress.Parse(&quot;1.1.1.1&quot;), 0));//设置网卡发送 IPEndPoint endpoint = new IPEndPoint(IPAddress.Parse(&quot;255.255.255.255&quot;), 7788); byte[] buf = Encoding.Default.GetBytes(&quot;Hello from UDP broadcast&quot;); Thread t = new Thread(new ThreadStart(RecvThread)); t.IsBackground = true; t.Start(); while (true) &#123; client.Send(buf, buf.Length, endpoint); Thread.Sleep(1000); &#125; &#125; static void RecvThread() &#123; UdpClient client = new UdpClient(new IPEndPoint(IPAddress.Any, 7788)); IPEndPoint endpoint = new IPEndPoint(IPAddress.Any, 0); while (true) &#123; byte[] buf = client.Receive(ref endpoint); string msg = Encoding.Default.GetString(buf); Console.WriteLine(msg); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 发送UDP消息/// &lt;/summary&gt;/// &lt;param name=&quot;msg&quot;&gt;消息内容&lt;/param&gt;void Send(string msg)&#123; UdpClient udpClient = new UdpClient(); IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Broadcast, 10249); // IPAddress.Broadcast 就是 255.255.255.255 byte[] buffer = Encoding.UTF8.GetBytes(msg); udpClient.Send(buffer, buffer.Length, ipEndPoint);&#125;static void Main()&#123; UdpClient udpServer = new UdpClient(10249); IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Any, 10249); udpServer.BeginReceive(Received, udpServer);&#125;/// &lt;summary&gt;/// 异步接收UDP数据/// &lt;/summary&gt;/// &lt;param name=&quot;iar&quot;&gt;&lt;/param&gt;void Received(IAsyncResult iar)&#123; udpServer = iar.AsyncState as UdpClient; byte[] buffer = udpServer.EndReceive(iar, ref ipEndPoint); //将获取的byte[]数据转换成字符串 string m = Encoding.UTF8.GetString(buffer).Trim(); Console.WriteLine(&quot;Receive:&#123;0&#125;&quot;,m); //继续异步接收数据 udpServer.BeginReceive(Received, udpServer);&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"UDP","slug":"UDP","permalink":"https://silencejql.github.io/tags/UDP/"}]},{"title":"C#事件与委托","slug":"C-事件与委托","date":"2020-11-18T07:31:24.000Z","updated":"2025-03-24T11:34:42.226Z","comments":true,"path":"C-事件与委托.html","link":"","permalink":"https://silencejql.github.io/C-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%A7%94%E6%89%98.html","excerpt":"参考HeadFirstC#","text":"参考HeadFirstC# 事件 当一个事件发生后，不同的事件监视者完成各自的工作 1、定义产生事件的对象 2、定义事件 3、事件发生 4、不同对象订购(绑定)事件 5、创建事件执行需要的参数对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//定义事件及对象Ball ball = new Ball();//绑定Fan fan = new Fan(ball);//Fan对Ball的处理，Fan先绑定BallInPlayPitcher pitcher = new Pitcher(ball);//Pitcher对Ball的处理，Pitcher后绑定BallInPlayBallEventArgs ballEventArgs = new BallEventArgs(60,80);//事件发生后Fan先响应，Pitcher后响应ball.OnBallInPlay(ballEventArgs)//1、定义产生事件的对象class Ball&#123; //2、定义事件 //无事件绑定对象时BallInPlay = null //事件执行顺序为事件绑定顺序 public event EventHandler BallInPlay; protected void OnBallInPlay(BallEventArgs e)&#123; //EventHandler ballInplay = BallInPlay; //3、事件发生 //事件发生后会执行BallInPlay的委托，具体的执行发放为事件监视者所委托的方法 BallInPlay(this, e); //if (ballInplay != null) // ballInplay(this,e); &#125;&#125;class Pitcher&#123; public Pitcher(Ball ball)&#123; //4、不同对象订购(绑定)事件 //当事件发生后执行ball_BallInPlay1方法 ball.BallInPlay += ball_BallInPlay1; &#125; void ball_BallInPlay1(object sender, EventArgs e)&#123; if (e is BallEventArgs)&#123; BallEventArgs ballEventArgs = e as BallEventArgs; if (ballEventArgs.Distance &lt; 95 &amp;&amp; ballEventArgs.Traj &lt; 60)&#123; CatchBall(); &#125;else GameOver(); &#125; &#125; void CatchBall()&#123; &#125; void GameOver()&#123; &#125;&#125;class Fan&#123; public Fan(Ball ball)&#123; //4、不同对象订购(绑定)事件 //当事件发生后执行ball_BallInPlay2方法 ball.BallInPlay += new EventHandler(ball_BallInPlay2); &#125; void ball_BallInPlay2(object sender, EventArgs e)&#123; if (e is BallEventArgs)&#123; BallEventArgs ballEventArgs = e as BallEventArgs; if (ballEventArgs.Distance &gt; 400) CatchBall(); else Screm(); &#125; &#125; void CatchBall()&#123; &#125; void Screm()&#123; &#125;&#125;//事件执行的参数class BallEventArgs : EventArgs&#123; public int Traj &#123; get; private set; &#125;//击球角度 public int Distance &#123; get; private set; &#125;//飞行距离 public BallEventArgs(int traj, int distance)&#123; this.Traj = traj; this.Distance = distance; &#125;&#125; 委托事件 委托 再讲委托 1234567891011public delegate string Calculate(double x, double y);Calculate calculateString = new Calculate(add);string add = calculateString(1, 1);calculateString = new Calculate(mul);string mul = calculateString(1, 1);public string add(double x, double y)&#123; return (x + y).ToString()&#125;public string mul(double x, double y)&#123; return (x * y).ToString()&#125; 123456789101112131415161718192021222324252627282930313233343536373839delegate void BatCallback(BallEventArgs e);Ball ball = new Ball();//创建一个新的Bat对象，使用BatCallback委托将Ball的OnBallInPlay方法引用传给Bat对象Bat bat = ball.GetNewBat();Fan fan = new Fan(ball);Pitcher pitcher = new Pitcher(ball);BallEventArgs ballEventArgs = new BallEventArgs(60,80);bat.HitTheBall(ballEventArgs);class Ball&#123; //2、定义事件 //无事件绑定对象时BallInPlay = null //事件执行顺序为事件绑定顺序 public event EventHandler BallInPlay; protected void OnBallInPlay(BallEventArgs e)&#123; //EventHandler ballInplay = BallInPlay; //3、事件发生 //事件发生后会执行BallInPlay的委托，具体的执行发放为事件监视者所委托的方法 BallInPlay(this, e); //if (ballInplay != null) // ballInplay(this,e); &#125; public Bat GetNewBat()&#123; //将事件处理委托到击球事件中 return new Bat(new BatCallback(OnBallInPlay)); &#125;&#125;class Bat&#123; private BatCallback hitBallCallback; public Bat(BatCallback callbackDelegate) &#123; //私有化事件发生后的时间处理 //不使用 += 是为了保证击球手只监视场内的一个Ball this.hitBallCallback = new BatCallback(callbackDelegate); &#125; //发生击球事件后，回调Ball类中的OnBallInPlay响应 public void HitTheBall(BallEventArgs e)&#123; if (hitBallCallback != null) hitBallCallback(e); &#125;&#125; 回调和事件 代码上的区别： 事件发生后的响应在当前类 回调响应方法在其他类","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"委托","slug":"委托","permalink":"https://silencejql.github.io/tags/%E5%A7%94%E6%89%98/"},{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"事件","slug":"事件","permalink":"https://silencejql.github.io/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"BBK检测线通讯相关介绍","slug":"BBK检测线通讯相关介绍","date":"2020-11-17T05:24:25.000Z","updated":"2025-03-07T12:38:28.245Z","comments":true,"path":"BBK检测线通讯相关介绍.html","link":"","permalink":"https://silencejql.github.io/BBK%E6%A3%80%E6%B5%8B%E7%BA%BF%E9%80%9A%E8%AE%AF%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D.html","excerpt":"前面啥也没有","text":"前面啥也没有 TCP 客户端配置 GeneralLib.xDvConfigClient.init(GeneralLib.xRemoterClientConfig) 服务端配置 GeneralLib.GenO.InitRemoterTcpServer() 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;&lt;Root&gt; &lt;xDevice updateRate=&quot;50&quot;&gt; &lt;Item ip=&quot;10.18.13.50:10240&quot;&gt; &lt;__COUNTER_OUT value=&quot;None&quot; WriteEnable=&quot;false&quot; Reversion=&quot;false&quot; /&gt; &lt;__COUNTER_IN value=&quot;None&quot; WriteEnable=&quot;false&quot; Reversion=&quot;false&quot; /&gt; &lt;Communication_ZTS value=&quot;CarParam_ZTS&quot; WriteEnable=&quot;true&quot; Reversion=&quot;false&quot; /&gt; &lt;Communication_VIN value=&quot;CarParam_VIN&quot; WriteEnable=&quot;true&quot; Reversion=&quot;false&quot; /&gt; &lt;/Item&gt; &lt;DeviceDescribe&gt; &lt;!--用于与具有远程功能的平台程序通讯(@开头为PubObject对象,#开头为组合控制),默认端口10240,ip格式:127.0.0.1:10240--&gt; &lt;/DeviceDescribe&gt; &lt;Alarms&gt; &lt;AlarmItem value=&quot;None&quot;&gt; &lt;Alarm Index=&quot;0&quot; Name=&quot;告警信息格式模板&quot; /&gt; &lt;/AlarmItem&gt; &lt;/Alarms&gt; &lt;/xDevice&gt;&lt;/Root&gt; 配置完成后，相当于客户端的Communication_VIN与服务端的CarParam_VIN进行了绑定 UDP 客户端配置 SocketOpraLib.UDPClientOpra.SetDestInfoConfig(ConfigSend) SocketOpraLib.UDPClientOpra.SendTo(“{VIN};{ZTS}”) 服务端配置 SocketOpraLib.UDPServerOpra.SetLocalInfoConfig(ConfigRecv)","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Flask框架","slug":"Flask框架","date":"2020-10-30T07:10:56.000Z","updated":"2025-03-24T11:34:32.716Z","comments":true,"path":"Flask框架.html","link":"","permalink":"https://silencejql.github.io/Flask%E6%A1%86%E6%9E%B6.html","excerpt":"前面啥也没有","text":"前面啥也没有 目录结构 123456789101112131415161718flask-demo/ ├ run.py # 应用启动程序 ├ config.py # 环境配置 ├ requirements.txt # 列出应用程序依赖的所有Python包 ├ tests/ # 测试代码包 │ ├ __init__.py │ └ test_*.py # 测试用例 └ myapp/ ├ admin/ # 蓝图目录 ├ static/ │ ├ css/ # css文件目录 │ ├ img/ # 图片文件目录 │ └ js/ # js文件目录 ├ templates/ # 模板文件目录 ├ __init__.py ├ forms.py # 存放所有表单，如果多，将其变为一个包 ├ models.py # 存放所有数据模型，如果多，将其变为一个包 └ views.py # 存放所有视图函数，如果多，将其变为一个包 示例： IconFont网址下载图标 123456789101112131415161718192021222324252627282930313233343536from flask import Flask,render_template,requestimport datetimeapp = Flask(__name__)@app.route(&#x27;/index&#x27;)def hello_world(): return &#x27;Hello World!&#x27;@app.route(&#x27;/user/&lt;name&gt;&#x27;)def welcome(name): return &quot;welcome %s&quot;%name@app.route(&#x27;/user/&lt;int:id&gt;&#x27;)def welcomeid(id): return &quot;welcome num %d&quot;%id@app.route(&quot;/&quot;)def index2(): list = [&quot;l1&quot;,&quot;l2&quot;,&quot;l3&quot;] time = datetime.date.today() task = &#123;&quot;task&quot;:&quot;clean&quot;,&quot;time&quot;:&quot;3hours&quot;&#125; return render_template(&quot;index.html&quot;,var = time,list = list, task = task)#表单提交@app.route(&#x27;/register&#x27;)def register(): return render_template(&quot;register.html&quot;)@app.route(&#x27;/result&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def result(): if request.method == &#x27;POST&#x27;: result = request.form #表单字典 return render_template(&quot;result.html&quot;,result = result)if __name__ == &#x27;__main__&#x27;: app.run(debug=True) #还需要在项目配置中启动Debug 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; welcome. Today is &#123;&#123; var &#125;&#125;&lt;br/&gt; on duty&lt;br/&gt; &#123;% for data in list %&#125; &lt;li&gt; &#123;&#123; data &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; task:s&lt;br/&gt; &lt;table border=&quot;1&quot;&gt; &#123;% for key,value in task.items() %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;key&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;value&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&#123;&#123; url_for(&#x27;result&#x27;) &#125;&#125;&quot; method=&quot;post&quot;&gt; &lt;p&gt;name: &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/p&gt; &lt;p&gt;age: &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;/p&gt; &lt;p&gt;sex: &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot;&gt; &#123;% for key,value in result.items() %&#125; &lt;tr&gt; &lt;th&gt;&#123;&#123;key&#125;&#125;&lt;/th&gt; &lt;td&gt;&#123;&#123;value&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; Result&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://silencejql.github.io/tags/Flask/"}]},{"title":"Modbus通讯协议","slug":"Modbus通讯协议","date":"2020-10-20T04:50:59.000Z","updated":"2025-03-24T11:34:24.888Z","comments":true,"path":"Modbus通讯协议.html","link":"","permalink":"https://silencejql.github.io/Modbus%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.html","excerpt":"前面啥也没有","text":"前面啥也没有 Modbus TCP 数据帧 MBAP + PDU MBAP： Modbus Application Protocol Header PDU：Protocol Data Unit MBAP + Function code + Data 示例： 00 01 00 00 00 06 01 事务标识2+modbus协议2+数据长度2+Slave站号1 Function code： 0x01：读线圈 02：读离散量输入 03：读保持寄存器 04：读输入寄存器 05：写单个线圈 06：写单个保持寄存器 10：写多个保持寄存器 0F：写多个线圈 报文头部： 字节序号 含义 客户端 服务器 BYTE 0 – 1 传输标志，事务标识符 由客户端生成 应答时复制该值 BYTE 2 – 3 协议标识，Modbus 协议=0 由客户端生成 应答时复制该值 BYTE 4 ¬- 5 报文后续数据的字节长度 由客户端生成 应答时由服务器重新生成 BYTE 6 MODBUS单元标志 由客户端生成 应答时复制该值 Modbus TCP协议功能码报文 功能码3 读多个寄存器 请求报文格式 字节序号 含义 BYTE 7 功能码=3 BYTE 8 - 9 读取数据的寄存器偏移地址 BYTE 10 - 11 读取数据的寄存器数量，单位为Word 读数据成功的响应报文格式 字节序号 含义 BYTE 7 功能码=3 BYTE 8 读取到的数据的字节数 BYTE 9- 10 读取到的寄存器1的数据 BYTE 11 - 12 读取到的寄存器2的数据 …. … 功能码16 写多个寄存器 请求报文格式 字节序号 含义 BYTE 7 功能码=16 BYTE 8 - 9 写数据的寄存器偏移地址 BYTE 10 - 11 写数据的寄存器数量，单位为Word BYTE 12 写数据的字节数（数据等于写数据的寄存器数量 x 2） BYTE 13 - 14 寄存器1的数据 BYTE 15 - 16 寄存器1的数据 写数据成功的响应报文格式 字节序号 含义 BYTE 7 功能码=16 BYTE 8 - 9 写数据的寄存器偏移地址 BYTE 10 - 11 写数据的寄存器数量，单位为WORD 功能码6 写单个寄存器 请求报文格式 字节序号 含义 BYTE 7 功能码=6 BYTE 8 - 9 写数据的寄存器偏移地址 BYTE 10 - 11 寄存器的数值 写数据成功的响应报文格式 字节序号 含义 BYTE 7 功能码=6 BYTE 8 - 9 写数据的寄存器偏移地址 BYTE 10 - 11 寄存器的数值 控制 IB IL 24 DO8开关量输出模块请求报文，模块寄存器地址：384，控制数据在最后一个字节； 0F 01 00 00 00 06 FF 06 01 80 00 0F 控制DO输出成功响应报文 0F 01 00 00 00 06 FF 06 01 80 00 0F 读取 IB IL 24 DI8开关量输入模块请求报文，模块寄存器地址：0，数据寄存器长度为1； 0B 01 00 00 00 06 FF 03 00 00 00 01 读取IB IL 24 DI8开关量输入成功的响应报文，数据在最后一个字节； 0B 01 00 00 00 05 FF 03 02 00 XX 读取 IB IL AI2SF-230模拟量输入模块请求报文，模块寄存器地址：192，数据寄存器长度为2，该模块默认连接0~10V信号； 0B 02 00 00 00 06 FF 03 00 C0 00 02 读取数据成功的响应报文，数据在最后4个字节，分别为通道1~2； 0B 02 00 00 00 07 FF 03 04 XX XX XX XX Kepserver Address 输出线圈： 000001 ~ 065536 输入线圈： 100001 ~ 165536 内部寄存器：300001 ~ 365536 保持寄存器：400001 ~ 465536 访问输出线圈：Address：000001 访问连续10个输出线圈：Address：000001#10 访问保持寄存器：Address：400001 访问连续10个保持寄存器：Address：400001[10] 1","categories":[],"tags":[{"name":"Modbus","slug":"Modbus","permalink":"https://silencejql.github.io/tags/Modbus/"}]},{"title":"BBK故障码处理","slug":"BBK故障码处理","date":"2020-10-16T03:03:48.000Z","updated":"2025-03-07T12:27:44.324Z","comments":true,"path":"BBK故障码处理.html","link":"","permalink":"https://silencejql.github.io/BBK%E6%95%85%E9%9A%9C%E7%A0%81%E5%A4%84%E7%90%86.html","excerpt":"检测线处理故障码，包括只判断指定故障码和忽略指定故障码","text":"检测线处理故障码，包括只判断指定故障码和忽略指定故障码 CanCmdOpraLib.CanCmd HandleDTC 该函数参数为忽略的故障码，可以为{0xD1 55 84};{0xD1 55 85}的格式，也可以为U1155-84;U1155-85的格式 不设置参数则将所有读出的DTC添加到useDTClist中 CheckDTC 该函数参数为判断的故障码，判断该故障码是否存在于useDTClist中 存在返回False，不存在返回True 示例 Recv：{0x59 02 AB D1 55 84 2B D1 55 85 2B} HandleDTC({0xD1 55 84}) useDTClist为U1155-85 D1 55 85 CheckDTC({0xD1 55 84})返回true CheckDTC({0xD1 55 85})返回false","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"ABS类名与车型对应","slug":"ABS类名与车型对应","date":"2020-09-18T11:35:01.000Z","updated":"2025-03-07T12:28:08.546Z","comments":true,"path":"ABS类名与车型对应.html","link":"","permalink":"https://silencejql.github.io/ABS%E7%B1%BB%E5%90%8D%E4%B8%8E%E8%BD%A6%E5%9E%8B%E5%AF%B9%E5%BA%94.html","excerpt":"前面啥也没有","text":"前面啥也没有 SGMW ClassName:车型: CN200SESP : BOSCH9CANABS CN200ESP : BOSCH9CANABS CN200SABS : BOSCH9CANABS CN200ABS : BOSCH9CANABS CN113ABS : BOSCH9CANABS CN180MABS : BOSCH9CANABS CN180MESP : BOSCH9CANESP CN180SABS : BOSCH9CANABS CN180SESP : BOSCH9CANESP E100ESP : BOSCH9CANABS E100ABS : BOSCH9CANABS E300ESC : BOSCH9CANABS E300ABS : BOSCH9CANABS N300LABSEV: E100ABS CN210ABS : BOSCH9CANABS E50ABS : E100ABS GP50ABS : BOSCH9ABSCAN CN112ABS : BOSCH9KWPABS CN112 : BOSCH9KWPABS N300LABS : BOSCH9KWPABS N310ABS : BOSCH9KWPABS N350PABS : BOSCH9KWPABS CN100VABS : BOSCH9KWPABS N300MandoABS : BOSCH9KWPABS CN115ABS : BOSCH9KWPABS CN115 : BOSCH9KWPABS CN180SDBC78ABS : DBC78ABS CN180SDBC78ABS4MBK : DBC78ABS CN200DCU : DCU CN200SDCU : DCU CN120SESC : MK100ESC CN120SABS : MK100ABS CN120SABSForACU : MK100ABS CN120SESCForACU : MK100ESC CN180CESC : MK100ESC CN180SESCconfi : CN180CESC CN300SESC : CN180SESCconfi CN180C_2ESC : MK100ESC MK100ESCForMBK : ABSBaseForCAN CN180CESCForMBK : MK100ESCForMBK CN180CABS : MK78ABS N1 : N1ABS 长春一汽轿车 J5LADSC : DSCCAN J71DSC : DSCCAN D181ESP : BOSCH9CANESP D181ABS : BOSCH9CANABS D009ABS : BOSCH9CANABS D009ESP : BOSCH9CANESP C141ESP : BaseBosch_ESP9 C205ESP : C141ESP D090ESP : C141ESP E111ESP : C141ESP","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"新增ABS","slug":"新增ABS","date":"2020-09-16T06:01:34.000Z","updated":"2025-03-07T12:27:57.730Z","comments":true,"path":"新增ABS.html","link":"","permalink":"https://silencejql.github.io/%E6%96%B0%E5%A2%9EABS.html","excerpt":"前面啥也没有","text":"前面啥也没有 准备文件 1、RBABS_xxx.dll 其中包含ABS通讯指令 软件更改 0、备份程序 1、替换BBK\\Bin文件夹下的 RBABS_xxx.dll 文件 2、新增车型信息 如图新增该车型相关车型信息，复制其他车型更改即可 3、新增ABS标准 上图为DVT中动态ABS标准，制动台更改静态ABS标准 Identity为该ABS的标识 ABS类型内容咨询软件工程师 4、新增ZTS 复制其他车型后更改ZTS 更改车型参数 更改动态ABS标准 5、配置串口 复制其他CAN或K线配置，更改KeyName为3中的ABS类型 Param1为串口号、Param3为输出LOG的文件名 说明：该步骤若未提前更改，测试中会自动创建并使用默认串口号导致通讯失败，依据其他车型的配置更改串口号等即可。 6、更改Config\\ABSValveTestConfig中当前ABS类型文件中的增减压时间等进行优化","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"中牟日产打印更改","slug":"中牟日产打印更改","date":"2020-08-11T10:58:08.000Z","updated":"2025-03-07T12:37:43.342Z","comments":true,"path":"中牟日产打印更改.html","link":"","permalink":"https://silencejql.github.io/%E4%B8%AD%E7%89%9F%E6%97%A5%E4%BA%A7%E6%89%93%E5%8D%B0%E6%9B%B4%E6%94%B9.html","excerpt":"","text":"读取Excel保存数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void ReadAndSaveCarInfoFromExcel(string vin)&#123; try &#123; //string serverConnString = &quot;$Npgsql$Database=LocalDB;Host=127.0.0.1;Port=5432;Username=postgres;Password=123&quot;; string sql = string.Format(&quot;select * from [OBD检查表] where [VIN]=&#x27;&#123;0&#125;&#x27; order by [测试时间] desc&quot;, vin); DbDataAdapter adap = BConnString.CreateDataAdapter(sql, serverConnString); DataTable dt = new DataTable(); adap.Fill(dt); DataRow dr = null; if (dt.Rows.Count &gt; 0) dr = dt.Rows[0]; else return; string VIDCode = dr[&quot;VID&quot;].ToString(); // string vid = &quot;1111111111111 SDFVDFSD---- SDAVV6515151 AFDFASFSA ASDFS S 20200707 SDFSF 111255544 &quot; Regex re = new Regex(@&quot;(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+)\\s*&quot;); Match match = re.Match(VIDCode); string CarEI = match.Groups[2].Value; string EngineNo = match.Groups[9].Value; if (EngineNo.Length == 0 || EngineNo == null) &#123; re = new Regex(@&quot;(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+)\\s*&quot;); match = re.Match(VIDCode); EngineNo = match.Groups[8].Value; &#125; if (EngineNo.Length &lt; 4) &#123; re = new Regex(@&quot;(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+?)\\s+(\\S+)\\s*&quot;); match = re.Match(VIDCode); EngineNo = match.Groups[10].Value; &#125; //1909889 TYBGLCFDP0DXA---A L1234567891234567 1H5GPRCOP Y23A S 202008154 M9T M1014785 string carType = &quot;&quot;; string productEnterprise = &quot;&quot;; GetCarInfoByEI(CarEI, ref carType, ref productEnterprise); string sqlCarInfo = string.Format(&quot;select * from [OBD车型表] where [VIN]=&#x27;&#123;0&#125;&#x27; order by [ID] desc&quot;, vin); DbDataAdapter adapCarInfo = BConnString.CreateDataAdapter(sqlCarInfo, serverConnString); DataTable dtCarInfo = new DataTable(); adapCarInfo.Fill(dtCarInfo); DataRow drCarInfo = null; if (dtCarInfo.Rows.Count &gt; 0) drCarInfo = dtCarInfo.Rows[0]; else drCarInfo = dtCarInfo.Rows.Add(); drCarInfo[&quot;VIN&quot;] = vin; drCarInfo[&quot;发动机号&quot;] = EngineNo; drCarInfo[&quot;Cartype车辆型号&quot;] = carType; drCarInfo[&quot;车辆生产企业&quot;] = productEnterprise; drCarInfo[&quot;更新时间&quot;] = DateTime.Now; adapCarInfo.Update(dtCarInfo); &#125; catch (ExcelException ex) &#123; MessageBox.Show(ex.Message); &#125;&#125;void GetCarInfoByEI(string EI, ref string CarType, ref string ProductEnterprise)&#123; // connect Excel //string excelPath = @&quot;D:\\工作\\现场工作文件整理\\中牟日产\\EI-车辆型号.xlsx&quot;; string strConn = string.Format(&quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source =&#123;0&#125;; Extended Properties = &#x27;Excel 12.0; HDR=Yes; IMEX=0&#x27;&quot;, excelPath); DataSet ds = new DataSet(); OleDbConnection conn = new OleDbConnection(strConn); string sql = string.Format(&quot;select * from [Sheet1$] where [Code18/EI] like &#x27;%&#123;0&#125;%&#x27;&quot;, EI); OleDbDataAdapter oada = new OleDbDataAdapter(sql, conn); oada.Fill(ds); DataRow dr = null; if (ds.Tables[0].Rows.Count &gt; 0) dr = ds.Tables[0].Rows[0]; else &#123; MessageBox.Show(&quot;EI车辆型号Excel中没有当前车型，请检查&quot;); return; &#125; CarType = dr[&quot;Cartype/车辆型号&quot;].ToString(); ProductEnterprise = dr[&quot;生产企业&quot;].ToString();&#125;","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Selenium WebDriver","slug":"Selenium-WebDriver","date":"2020-08-05T03:53:10.000Z","updated":"2023-01-05T05:12:30.008Z","comments":true,"path":"Selenium-WebDriver.html","link":"","permalink":"https://silencejql.github.io/Selenium-WebDriver.html","excerpt":"Selenium WebDriver 笔记","text":"Selenium WebDriver 笔记 Selenium 查找 UI 元素（web 元素） 1234567891011121314151617181920212223&lt;div id=&quot;coolestWidgetEvah&quot;&gt;...&lt;/div&gt;WebElement element = driver.findElement(By.id(&quot;coolestWidgetEvah&quot;));&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;List&lt;WebElement&gt; cheeses = driver.findElements(By.className(&quot;cheese&quot;));&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;WebElement frame = driver.findElement(By.tagName(&quot;iframe&quot;));&lt;input name=&quot;cheese&quot; type=&quot;text&quot;/&gt;WebElement cheese = driver.findElement(By.name(&quot;cheese&quot;));//By Link Text&lt;a href=&quot;http://www.google.com/search?q=cheese&quot;&gt;cheese&lt;/a&gt;&gt;WebElement cheese = driver.findElement(By.linkText(&quot;cheese&quot;));//By Partial Link Text&lt;a href=&quot;http://www.google.com/search?q=cheese&quot;&gt;search for cheese&lt;/a&gt;&gt;WebElement cheese = driver.findElement(By.partialLinkText(&quot;cheese&quot;));// By CSS&lt;div id=&quot;food&quot;&gt;&lt;span class=&quot;dairy&quot;&gt;milk&lt;/span&gt;&lt;span class=&quot;dairy aged&quot;&gt;cheese&lt;/span&gt;&lt;/div&gt;WebElement cheese = driver.findElement(By.cssSelector(&quot;#food span.dairy.aged&quot;)); 用户输入 - 填充表单 WebDriver 有一个叫 “Select” 的类，这个类提供了很多有用的方法用于 select 元素进行交互。 123Select select = new Select(driver.findElement(By.tagName(&quot;select&quot;)));select.deselectAll();select.selectByVisibleText(&quot;Edam&quot;); 上述代码取消页面上第一个 select 元素的所有 option 的选中状态，然后选中字面值为 “Edam” 的 option。 如果你已经完成表单填充，你可能希望提交它，你只要找到 “submit” 按钮然后点击它即可。 driver.findElement(By.id(&quot;submit&quot;)).click(); 或者，你可以调用 WebDriver 为每个元素提供的 “submit” 方法。如果你对一个 form 元素调用该方法，WebDriver 将调用这个 form 的 submit 方法。如果这个元素不是一个 form，将抛出一个异常。 element.submit(); 常用类与方法 1234567891011121314151617181920212223from selenium import webdriver # 驱动浏览器from selenium.webdriver import ActionChains # 鼠标的相关操作，比如滑动验证from selenium.webdriver.common.by import By # 选择器，以什么方式选择标签元素from selenium.webdriver.common.keys import Keys # 键盘相关from selenium.webdriver.support import expected_conditions as EC # 各种判断，一般跟等待事件连用，比如说等待某个元素加载出来from selenium.webdriver.support.wait import WebDriverWait # 等待事件，可以与EC连用browser = webdriver.Chrome()wait = WebDriverWait(browser, 10)browser.get(&#x27;https://www.baidu.com&#x27;)browser.maximize_window() # 窗口最大化print(browser.current_url) # 获取当前页URLprint(browser.title) # 获取页面的titleprint(browser.name) # 获取driver对象：chromeprint(browser.current_window_handle) # 获取当前窗口print(browser.get_cookies()) # 获取cookiesprint(browser.page_source) # 获取当前页面内容browser.back() # 后退browser.forward() # 前进browser.refresh() # 刷新browser.save_screenshot(&#x27;error.png&#x27;) # 保存截图browser.close() # 关闭当前窗口browser.quit() # 退出浏览器驱动，关闭所有关联窗口 选择器 1234567891011121314from selenium import webdriver # 驱动浏览器from selenium.webdriver.support.wait import WebDriverWait # 等待事件browser = webdriver.Chrome()wait = WebDriverWait(browser, 10)browser.get(&#x27;https://www.baidu.com&#x27;)browser.find_element_by_id(&#x27;su&#x27;) # id选择器browser.find_element_by_class_name(&#x27;xx&#x27;) # 类选择器，1个browser.find_elements_by_class_name(&#x27;xx&#x27;) # 类选择器，多个browser.find_element_by_link_text(&#x27;xxx&#x27;) # 链接文本选择器browser.find_element_by_xpath(&#x27;xxxx&#x27;) # xpath选择器browser.find_element_by_tag_name(&#x27;h1&#x27;) # 标签选择器，获取1个browser.find_elements_by_tag_name(&#x27;h1&#x27;) # 标签选择器，获取多个browser.find_element_by_css_selector(&#x27;xxx&#x27;) # 样式选择器 find_element_by_xpath 测试网页的HTML代码 123456789101112131415161718192021&lt;html&gt; &lt;body&gt; &lt;div id=&quot;div1&quot; style=&quot;text-align:center&quot;&gt; &lt;img alt=&quot;div1-img1&quot; src=&quot;http://www.sogou.com/images/logo/new/sogou.png&quot; href=&quot;http://www.sogou.com&quot;&gt;sogou image&lt;/img&gt;&lt;br /&gt; &lt;input name=&quot;div1input&quot;&gt; &lt;a href=&quot;http://www.sogou.com&quot;&gt;搜狗搜索&lt;/a&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; &lt;/div&gt; &lt;br&gt; &lt;div id=&quot;div2&quot; style=&quot;text-align:center&quot;&gt; &lt;img alt=&quot;div2-img2&quot; src=&quot;http://www.baidu.com/img/bdlogo.png&quot; href=&quot;http://www.baidu.com&quot;&gt;baidu image&lt;/img&gt;&lt;br /&gt; &lt;input name=&quot;div2input&quot;&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度搜索&lt;/a&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 1、绝对路径element = driver.find_element_by_xpath(&#x27;/html/body/div/input[@value=&quot;查询&quot;]&#x27;)# 上述xpath定位表达式从html dom树的根节点（html节点）开始逐层查找，最后定位到“查询”按钮节点。路径表达式“/”表示跟节点。# 2、相对路径element = driver.find_element_by_xpath(&#x27;//input[@value=&#x27;查询&#x27;]&#x27;)# 上述xpath定位表达式中//表示从匹配选择的当前节点开始选择文档中的节点，而不考虑特面的位置。input[@value=&quot;查询&quot;]表示定位value值为“查询”两个字的input页面元素。# 3、索引号定位元素element=driver.find_element_by_xpath(&quot;//input[1]&quot;)# 索引号定位方式是根据该页面元素在页面中相同标签名之间出现的索引位置来进行定位。上述xpath定位表达式表示查找页面中第二个出现的input元素，即被测试页面上的“查询”按钮。# 4、使用页面元素的属性值定位元素img = driver.find_element_by_xpath(&quot;//input[@alt=&#x27;div1-img1&#x27; and @href=&#x27;http://www.sogou.com&#x27;]&quot;)# 表达式使用了相对路径再结合元素拥有的特定属性方法进行定位，定位元素img的属性是“alt”，值为“div1-img1”，使用@符号指明后面接的是属性，并同属性及属性值一起写到元素后的方括号中。# 5、模糊属性值定位元素elements=driver.find_elements_by_xpath(&quot;//img[starts-with(@alt,&quot;div1&quot;)]&quot;)# 查找属性alt的属性值以div1关键字开始的页面元素elements=driver.find_elements_by_xpath(&quot;//img[contains(@alt,&quot;img&quot;)]&quot;)# 查找alt属性的属性值包含img关键字的页面元素，只要包含即可，无需考虑位置# 6、使用xpath轴定位元素img = driver.find_element_by_xpath(&quot;//img[@alt=&#x27;div2-img2&#x27;]/parent::div&quot;)# 查找到属性alt的属性值为div2-img2的img元素，并基于该img元素的位置找到它上一级的div页面元素img = driver.find_element_by_xpath(&quot;//div[@id=&#x27;div1&#x27;]/child::img&quot;)# 查找到ID属性值为div1的div元素，并基于div的位置找到它下层节点中的img页面元素//img[@alt=&#x27;div2-img2&#x27;]/ancestor::div# 查找到属性alt的属性值为div2-img2的img元素，并基于该img元素的位置找到它上级的div元素//div[@name=&#x27;div2&#x27;]/descendant::img# 查找到属性name的属性值为div2的div元素，并基于该元素的位置找到它下级所有节点中的img页面元素//div[@id=&#x27;div1&#x27;]/following::img# 查找到ID属性值为div1的div页面元素，并基于div的位置找到它后面节点中的img页面元素//a[@href=&#x27;http://www.sogou.com&#x27;]/following-sibling::input# 查找到链接地址为http：//www.sogou.com的链接页面元素a，并基于链接的位置找到它后续兄弟节点中的input页面元素//img[@alt=&#x27;div2-img2&#x27;]/preceding::div# 查找到属性alt的属性值为div2-img2的图片页面元素img，并基于图片的位置找到它前面节点中的div页面元素//input[@value=&#x27;查询&#x27;]/preceding-sibling::a[1]# 查找到value属性值为“查询”的输入框页面元素，并基于该输入框的位置找到他前面同级节点中的第一个链接页面元素# 有时候我们会再轴后面加一个星号*， 便是通配符，如：//input[@value=&quot;查询&quot;]/preceding::*，它表示查找属性value的值为“查询”的输入框input元素前面所有的同级元素，但不包括input元素本身# 7、页面元素的文本定位元素# 通过text()函数可以定位到元素文本包含某些关键内容的页面元素sogou_a=driver.find_element_by_xpath(&#x27;//a[text()=&quot;搜狗搜索&quot;]&#x27;)sogou_a=driver.find_element_by_xpath(&#x27;//a[.=&quot;搜狗搜索&quot;]&#x27;)# 查找文本内容为“搜狗搜索”的链接页面元素，使用的是精准匹配方式，也就是说文本内容必须完全匹配，不能多一个字也不能少一个字。第二个xpath语句中使用了以个点. 这里的点等价于text()，都指代的是当前节点的文本内容baidu_a=driver.find_element_by_xpath(&#x27;//a[contains(.,&quot;百度&quot;)]&#x27;)baidu_a=driver.find_element_by_xpath(&#x27;//a[contains(text(),&#x27;百度&#x27;)]&#x27;)# 查找文本内容包含“百度”关键字的链接页面元素，使用的是模糊匹配方式，即可以根据部分文本关键字进行匹配div=driver.find_element_by_xpath(&#x27;//a[contains(text(),&quot;百度&quot;)]/preceding::div&#x27;)div=driver.find_element_by_xpath(&#x27;//a[contains(. , &quot;百度&quot;)]/..&#x27;)# 查找文本内容包含“百度”关键字的链接页面元素a的上层父元素div，6最后使用了两个点。。，它表示选取当前节点的父节点，等价于preceding::div。 执行JavaScript 1234from selenium import webdriver # 驱动浏览器browser = webdriver.Chrome()browser.get(&#x27;https://www.zhihu.com/explore&#x27;)browser.execute_script(&#x27;alert(&quot;xxoo&quot;)&#x27;)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://silencejql.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Web","slug":"Web","permalink":"https://silencejql.github.io/tags/Web/"}]},{"title":"刷网课随记","slug":"刷网课随记","date":"2020-08-03T03:31:08.000Z","updated":"2025-03-25T03:22:37.374Z","comments":true,"path":"刷网课随记.html","link":"","permalink":"https://silencejql.github.io/%E5%88%B7%E7%BD%91%E8%AF%BE%E9%9A%8F%E8%AE%B0.html","excerpt":"","text":"视频播放参数 倍速播放 document.querySelector('video').playbackRate = 4.0 爬虫执行脚本 12js = &quot;document.querySelector(&#x27;video&#x27;).playbackRate = 4.0&quot;driver.execute_script(js) 下载视频课程 模拟登录 Webdriver 12345678option = webdriver.ChromeOptions()driver = webdriver.Chrome(chrome_options=option)driver.get(&quot;https://www.bjjnts.cn/login&quot;)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;uesrname&quot;) #元素赋值模拟输入driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;password&quot;)driver.find_element_by_xpath(&quot;//button[@class=&#x27;login_btn&#x27; and @type=&#x27;submit&#x27;]&quot;).click() #登录按钮点击事件driver.get(url)return driver.page_source Cookie 通过抓包拿到cookie，再将cookie放到header中请求即可 123456789101112131415driver.find_element_by_id(&#x27;user&#x27;).send_keys(&#x27;用户账号&#x27;)driver.find_element_by_id(&#x27;pass&#x27;).send_keys(&#x27;用户密码&#x27;)driver.find_element_by_xpath(&#x27;//*[@id=&quot;submit&quot;]&#x27;).click()time.sleep(1)cookie = driver.get_cookies()cookiea = [item[&quot;name&quot;] + &quot;=&quot; + item[&quot;value&quot;] for item in cookie]cookiestr = &#x27;; &#x27;.join(item for item in cookiea)driver.close() #获取到登录cookie,就可以关闭窗口了return cookiestr# join说明str = &quot;-&quot;;seq = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); # 字符串序列print str.join( seq );输出: a-b-c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# -*- coding: UTF-8 -*-# -*- coding: UTF-8 -*-import osimport reimport timeimport urllibfrom hashlib import md5import requestsfrom requests.exceptions import RequestExceptionfrom selenium import webdriverfrom bs4 import BeautifulSoupimport jsonfrom selenium.webdriver.common.keys import Keysfrom threading import Threaddef GetPageHtml(url): try: option = webdriver.ChromeOptions() driver = webdriver.Chrome(chrome_options=option) driver.get(&quot;https://www.bjjnts.cn/login&quot;) txt = driver.page_source # 设置默认编码为 utf-8 driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;ID&quot;) driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;KW&quot;) driver.find_element_by_xpath(&quot;//button[@class=&#x27;login_btn&#x27; and @type=&#x27;submit&#x27;]&quot;).click() header = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&#x27;,&#x27;Referer&#x27;:url&#125; time.sleep(2) driver.get(url) return driver.page_source #res = requests.get(url,headers = header) #if res.status_code == 200: #return res.text #return None except RequestException: return Nonedef ParseHtml(html): pattern = re.compile(&#x27;&lt;video src=&quot;(.*?)&quot;\\sposter=&#x27;,re.S) items = re.search(pattern,html) print(items.group(1)) return items.group(1)def ParseVideoHtml(html, name): root = &quot;D://Downloads//&quot; path = root + name + &quot;.mp4&quot; try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(html) with open(path, &#x27;wb&#x27;) as f: f.write(r.content) f.close() print(&quot;文件保存成功&quot;) else: print(&quot;文件已存在&quot;) except: print(&quot;爬取失败&quot;)def read_config(): &quot;&quot;&quot;&quot;读取配置&quot;&quot;&quot; path = os.getcwd() if not os.path.exists(path): os.mkdir(path) if not os.path.isfile(&quot;config.json&quot;): # 无文件时创建 with open(&quot;config.json&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;) as jsonfile: jsonfile.write(json.dump(&#123;&#x27;url&#x27;:&#x27;https://www.bjjnts.cn/lessonStudy/202/4268&#x27;&#125;),indent=4) jsonfile.close() with open(&quot;config.json&quot;) as json_file: config = json.load(json_file) return configdef main(): #html = &quot;https://bjjnts-bd.xuetangx.com/4233125536dfb27e-10.mp4?auth_key=1596034097-0-0-f7f5072dec07ec43c1110ade3a8d412d&quot; #ParseVideoHtml(html) #https://www.bjjnts.cn/login config = read_config() #html = &quot;https://www.bjjnts.cn/lessonStudy/202/4268&quot; html = config[&quot;url&quot;] print(html) url = &quot;https://www.bjjnts.cn/login&quot; option = webdriver.ChromeOptions() driver = webdriver.Chrome(chrome_options=option) driver.get(url) txt = driver.page_source # 设置默认编码为 utf-8 driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;370831199309165413&quot;) driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;bj123465&quot;) driver.find_element_by_xpath(&quot;//button[@class=&#x27;login_btn&#x27; and @type=&#x27;submit&#x27;]&quot;).click() header = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&#x27;,&#x27;Referer&#x27;:url&#125; time.sleep(2) driver.get(html) videoNames = [] bsObj = BeautifulSoup(driver.page_source.replace(&#x27;&amp;nbsp;&#x27;, &#x27; &#x27;), &quot;lxml&quot;) VideoList = bsObj.findAll(class_=&quot;course_study_menubox&quot;) ##print(VideoList) i = 1 for video in VideoList: videoname = video.find(&quot;h4&quot;,class_=&quot;course_study_menutitle&quot;).get_text() ##driver.get(html) videoHtml = ParseHtml(driver.page_source) #th = Thread() ParseVideoHtml(videoHtml, videoname) time.sleep(2) i += 1 driver.find_element_by_xpath(&quot;//a[@class=&#x27;change_chapter lesson-&quot; + str(i) + &quot;&#x27;]&quot;).find_element_by_xpath(&#x27;..&#x27;).click() time.sleep(2) print(str(i)) #videoNames.append(video.find(&quot;h4&quot;,class_=&quot;course_study_menutitle&quot;).get_text()) #print(videoNames) #print(html)if __name__ == &#x27;__main__&#x27;: main()","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://silencejql.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Visual Studio Code配置记录","slug":"Visual-Studio-Code配置记录","date":"2020-07-28T07:39:55.000Z","updated":"2023-04-18T02:46:50.289Z","comments":true,"path":"Visual-Studio-Code配置记录.html","link":"","permalink":"https://silencejql.github.io/Visual-Studio-Code%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html","excerpt":"前面啥也没有","text":"前面啥也没有 插件 已安装插件： Bracket Pair Colorizer Chinese (Simplified) Language compareit Dracula Official Git History GitLens Markdownlint Markdown All in One open in browser Python C# Vetur Python安装第三方库 进入Python安装路径下的Scripts，执行 .\\pip install requests 如果在安装时报错： UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xd7 in position 9: ordinal not in range(128) 修改位于Python的安装路径下的Lib\\mimetypes.py文件,在import下添加如下几行代码： 123if sys.getdefaultencoding() != &#x27;gbk&#x27;: reload(sys)sys.setdefaultencoding(&#x27;gbk&#x27;) 编写C# 创建控制台程序 dotnet -h 查看命令 dotnet new --help 查看帮助 定位文件夹后执行： dotnet new console 程序运行 dotnet run 或 F5","categories":[],"tags":[]},{"title":"GAE AppID","slug":"GAE-AppID","date":"2020-07-16T02:55:23.000Z","updated":"2023-04-18T02:46:50.289Z","comments":true,"path":"GAE-AppID.html","link":"","permalink":"https://silencejql.github.io/GAE-AppID.html","excerpt":"GAEProxy AppID","text":"GAEProxy AppID 1testpro-199603|mytestpro-233908|justinxxnet01|xxnet-1|xxnet-2|xxnet-3|xxnet-4|xxnet-5|xxnet-6|xxnet-7|xxnet-8|xxnet-9|xxnet-10|xxnet-11|xxnet-12|xxnet-13|xxnet-14|xxnet-15|xxnet-16|xxnet-17|xxnet-18|xxnet-19|xxnet-20|xxnet-21|xxnet-22|xxnet-23|xxnet-24|xxnet-25|xxnet-26|xxnet-27|xxnet-28|xxnet-29|xxnet-30|xxnet-31|xxnet-32|xxnet-33|xxnet-34|xxnet-35|xxnet-36|xxnet-37|xxnet-38|xxnet-39|xxnet-40|xxnet-41|xxnet-42|xxnet-43|xxnet-44|xxnet-45|xxnet-46|xxnet-47|xxnet-48|xxnet-49|xxnet-50|xxnet-51|xxnet-52|xxnet-53|xxnet-54|xxnet-55|xxnet-56|xxnet-57|xxnet-58|xxnet-59|xxnet-60|xxnet-61|xxnet-62|xxnet-63|xxnet-64|xxnet-65|xxnet-66|xxnet-67|xxnet-68|xxnet-69|xxnet-70|xxnet-71|xxnet-72|xxnet-72|xxnet-73|xxnet-74|xxnet-75|xxnet-76|xxnet-77|xxnet-78|xxnet-79|xxnet-80|xxnet-81|xxnet-82|xxnet-83|xxnet-84|xxnet-85|xxnet-86|xxnet-87|xxnet-88|xxnet-89|xxnet-90|xxnet-91|xxnet-92|xxnet-93|xxnet-94|xxnet-95|xxnet-96|xxnet-97|xxnet-98|xxnet-99|xxnet-100|xxnet-101|xxnet-102|xxnet-103|xxnet-104|xxnet-105|xxnet-106|xxnet-107|xxnet-108|xxnet-109|xxnet-110|xxnet-111|xxnet-112|xxnet-113|xxnet-114|xxnet-115|xxnet-116|xxnet-117|xxnet-118|xxnet-119|xxnet-120|xxnet-121|xxnet-122|xxnet-123|xxnet-124|xxnet-125|xxnet-126|xxnet-127|xxnet-128|xxnet-129|xxnet-130|xxnet-131|xxnet-132|xxnet-133|xxnet-134|xxnet-135|xxnet-136|xxnet-137|xxnet-138|xxnet-139|xxnet-140|xxnet-141|xxnet-142|xxnet-143|xxnet-144|xxnet-145|xxnet-146|xxnet-147|xxnet-148|xxnet-149|xxnet-150|xxnet-151|xxnet-152|xxnet-153|xxnet-154|xxnet-155|xxnet-156|xxnet-157|xxnet-158|xxnet-159|celtic-bazaar-122813|chrome---1231|chrome--1231|chrome-06|chrome-07|chrome-08|chrome-09|chrome-10|chrome-11|chrome-12|chrome-1231|chrome-1231-1231|cool-continuity-122814|coral-muse-122814|curious-memory-122814|dospytang11|dospytang12|dospytang13|feisty-current-122813|glassy-vial-122813|groovy-patrol-122814|jingtao-001|practical-album-122814|proud-storm-122813|sound-invention-122813|starlit-cocoa-122814|third-circle-122813|wyslmt11|wyslmt12|xx-net-agent|xxnet--1229|xxnet-1017|xxnet-1018|xxnet-1019|xxnet-1021|xxnet-1022|xxnet-1023|xxnet-1024|xxnet-1025|xxnet-1026|xxnet-1027|xxnet-1028|xxnet-1029|xxnet-103-1188|xxnet-1030|xxnet-1031|xxnet-1032-1188|xxnet-1033|xxnet-1034|xxnet-1035|xxnet-1037|xxnet-1053|xxnet-1054|xxnet-200-1199|xxnet-201-1199|xxnet-202-1199|xxnet-203-1199|xxnet-204-1199|xxnet-205-1199|xxnet-206-1199|xxnet-207-1199|xxnet-cntchen|xxnet-evachen|xxnet-fgfw|xxnet-fgfw-1|xxnet-fgfw-2|xxnet-lennon|xxnet-xlx01|xxnet-xlx02|xxnet-xlx03|xxnet-xlx04|xxnet-xlx05|xxnet-xlx06|xxnet-xlx07|xxnet-xlx08|xxnet-xlx09|xxnet-xlx10|xxnet-xlx11|xxnet-xlx12|chrome26-1100|chrome27-1100|chrome28-1100|chrome29-1100|chrome30-1100|xxnet-foshan2|xxnet-foshan3|xxnet-foshan4|xxnet-foshan5|xxnet-foshan6|chrome7-1234|chrome8-1234|chrome10-1209|chrome11-1209|chrome12-1209|chrome2-1209|alpine-air-123504|caramel-theory-123504|compact-life-123504|clean-yew-123504|cobalt-sector-123504|eternal-outlook-123504|flash-moonlight-123504|omega-terrain-123504|premium-weft-123504|starlit-ship-123504|saaas-1235|x-micron-123504|chrome6-1234|chrome5-1234|chrome4-1234|chrome3-1234|chrome2-1234|chrome1-1234|chrome0-1234|chrome--1234|chrome---1234|chrome-1234|chrome6-1209|chrome4-1209|chrome3-1209|universal-stone-123514|stoked-dominion-123514|unique-ellipse-123514|trans-gate-123514|innate-summit-123514|able-involution-123514|helpful-ally-123514|river-karma-123514|future-synapse-123514|booming-alchemy-123514|storied-myth-123514|folkloric-stone-123514|cryptic-lattice-123514|dulcet-bucksaw-123514|airy-machine-123514|e-lexicon-123514|seventh-history-123514|upbeat-voice-123514|stately-math-123514|lucid-sweep-123514|nice-azimuth-123514|spry-equator-123515|neural-tome-123515|famous-charge-123515|elated-practice-123515|unique-antonym-123515|sharp-quest-123515|manifest-altar-123515|steel-citizen-123515|fourth-walker-123515|subtle-sublime-123515|galvanized-case-123515|xxnet-izual1|xxnet-izual2|xxnet-izual3|xxnet-izual4|xxnet-izual5|chrome11-1239|chrome10-1239|chrome9-1239|chrome8-1239|chrome7-1239|chrome6-1239|chrome5-1239|chrome4-1239|chrome3-1239|chrome2-1239|chrome0-1239|xx-net008-1197|tangtdjia|xxnet-kittycheny1|xxnet-kittycheny2|xxnet-kittycheny3|xxnet-kittycheny4|xxnet-kittycheny5|xxnet-kittycheny6|xxnet-sdcff1|xxnet-sdcff2|xxnet-sdcff3|xxnet-sdcff4|xxnet-sdcff5|xxnet-sdcff6|xxnet-sdcff7|xxnet-sdcff8|xxnet-sdcff9|xxnet-sdcff10|xxnet-sdcff11|xxnet-sdcff12|rosy-dialect-124115|xxnet-sdcf8-1241|xxnet-sdcf1|xxnet-sdcf2|xxnet-sdcf3|xxnet-sdcf4|xxnet-sdcf5|xxnet-sdcf6|xxnet-sdcf7|xxnet-sdcf8|xxnet-sdcf9|xxnet-sdcf10","categories":[],"tags":[]},{"title":"SQL Server存储过程","slug":"SQL-Server存储过程","date":"2020-07-12T05:48:33.000Z","updated":"2025-03-24T11:33:56.248Z","comments":true,"path":"SQL-Server存储过程.html","link":"","permalink":"https://silencejql.github.io/SQL-Server%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html","excerpt":"前面啥也没有","text":"前面啥也没有 查询赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647USE [EOLData]GO/****** Object: StoredProcedure [dbo].[UpDateHLAResult] Script Date: 07/12/2020 13:45:44 ******/SET ANSI_NULLS ONGOSET QUOTED_IDENTIFIER ONGO-- =============================================-- Author: &lt;Author,,Name&gt;-- Create date: &lt;Create Date,,&gt;-- Description: &lt;Description,,&gt;-- =============================================ALTER PROCEDURE [dbo].[UpDateHLAResult](@VIN varchar(30),@ZTS varchar(30),@LLOffset FLOAT)ASBEGIN-- SET NOCOUNT ON added to prevent extra result sets from-- interfering with SELECT statements.SET NOCOUNT ON;DECLARE @sem varchar(30) = &#x27;&#x27;&#x27;&#x27;-- 声明变量DECLARE @LHB FLOAT-- 判断是否存在数据IF EXISTS(select [左远光灯高] from [dbo].[车型配置] where [ZTS]=@ZTS)BEGIN -- 查询赋值 select @LHB = [左远光灯高] from [dbo].[车型配置] where [ZTS]=@ZTSENDELSEBEGIN select @LHB = [左远光灯高] from [dbo].[64字节车型配置] where [ZTS]=@ZTSEND-- 赋值SET @LHB = @LHB - @LHOffsetbegin exec( &#x27;UPDATE [dbo].[灯光表] SET &#x27; +&#x27;[左远光灯高] = &#x27;+@sem+ @LHB +@sem +&#x27;WHERE [VIN] = &#x27;+@sem+ @VIN +@sem )endEND","categories":[{"name":"SQLServer","slug":"SQLServer","permalink":"https://silencejql.github.io/categories/SQLServer/"}],"tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"https://silencejql.github.io/tags/SQLServer/"}]},{"title":"HttpWeb","slug":"HttpWeb","date":"2020-06-24T03:31:01.000Z","updated":"2025-03-24T11:33:17.847Z","comments":true,"path":"HttpWeb.html","link":"","permalink":"https://silencejql.github.io/HttpWeb.html","excerpt":"","text":"HttpWebRequest 命名空间： System.Net，这是.NET创建者最初开发用于使用HTTP请求的标准类 使用HttpWebRequest可以让开发者控制请求/响应流程的各个方面，如 timeouts, cookies, headers, protocols 另一个好处是HttpWebRequest类不会阻塞UI线程,例如，当从响应很慢的API服务器下载大文件时，您的应用程序的UI不会停止响应 HttpWebRequest通常和WebResponse一起使用，一个发送请求，一个获取数据 HttpWebRquest更为底层一些，能够对整个访问过程有个直观的认识，但同时也更加复杂一些 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Accept //获取或设置 Accept HTTP 标头的值。Address //获取实际响应请求的 Internet 资源的统一资源标识符 (URI)。AllowAutoRedirect //获取或设置一个值，该值指示请求是否应跟随重定向响应。AllowReadStreamBuffering //获取或设置一个值，该值指示是否对从 Internet 资源接收的数据进行缓冲处理。AllowWriteStreamBuffering //获取或设置一个值，该值指示是否对发送到 Internet 资源的数据进行缓冲处理。AuthenticationLevel //获取或设置用于此请求的身份验证和模拟的级别。(继承自 WebRequest)AutomaticDecompression //获取或设置所使用的解压缩类型。CachePolicy //获取或设置此请求的缓存策略。(继承自 WebRequest)ClientCertificates //获取或设置与此请求关联的安全证书集合。Connection //获取或设置 Connection HTTP 标头的值。ConnectionGroupName //获取或设置请求的连接组的名称。ContentLength //获取或设置 Content-length HTTP 标头。ContentType //获取或设置 Content-type HTTP 标头的值。ContinueDelegate //获取或设置当从 Internet 资源接收到 HTTP 100-continue 响应时调用的委托方法。ContinueTimeout //获取或设置在接收到来自服务器的 100-Continue 之前要等待的超时（以毫秒为单位）。CookieContainer //获取或设置与请求关联的 Cookie。CreatorInstance //当在子类中重写时，获取从 IWebRequestCreate 类派生的工厂对象，该类用于创建为生成对指定 URI 的请求而实例化的 WebRequest。(继承自 WebRequest)Credentials //获取或设置请求的身份验证信息。Date //获取或设置要在 HTTP 请求中使用的 Date HTTP 标头值。DefaultCachePolicy //获取或设置此请求的默认缓存策略。DefaultMaximumErrorResponseLength //获取或设置 HTTP 错误响应的默认最大长度。DefaultMaximumResponseHeadersLength //获取或设置 MaximumResponseHeadersLength 属性的默认值。Expect //获取或设置 Expect HTTP 标头的值。HaveResponse //获取一个值，该值指示是否收到了来自 Internet 资源的响应。Headers //指定构成 HTTP 标头的名称/值对的集合。Host //获取或设置要在 HTTP 请求中独立于请求 URI 使用的 Host 标头值。IfModifiedSince //获取或设置 If-Modified-Since HTTP 标头的值。ImpersonationLevel //获取或设置当前请求的模拟级别。(继承自 WebRequest)KeepAlive //获取或设置一个值，该值指示是否与 Internet 资源建立持续型连接。MaximumAutomaticRedirections //获取或设置请求将跟随的重定向的最大数目。MaximumResponseHeadersLength //获取或设置响应标头允许的最大长度。MediaType //获取或设置请求的媒体类型。Method //获取或设置请求的方法。Pipelined //获取或设置一个值，该值指示是否通过管线将请求传输到 Internet 资源。PreAuthenticate //获取或设置一个值，该值指示是否随请求发送一个 Authorization 标头。ProtocolVersion //获取或设置用于请求的 HTTP 版本。Proxy //获取或设置请求的代理信息。ReadWriteTimeout //获取或设置写入或读取流时的超时（以毫秒为单位）。Referer //获取或设置 Referer HTTP 标头的值。RequestUri //获取请求的原始统一资源标识符 (URI)。SendChunked //获取或设置一个值，该值指示是否将数据分段发送到 Internet 资源。ServerCertificateValidationCallback //获取或设置用于验证服务器证书的回调函数。ServicePoint //获取用于请求的服务点。SupportsCookieContainer //获取指示请求是否为 CookieContainer 提供支持的值。Timeout //获取或设置 GetResponse() 和 GetRequestStream() 方法的超时值（以毫秒为单位）。TransferEncoding //获取或设置 Transfer-encoding HTTP 标头的值。UnsafeAuthenticatedConnectionSharing //获取或设置一个值，该值指示是否允许经过高速 NTLM 身份验证的连接共享。UseDefaultCredentials //获取或设置一个 Boolean 值，该值控制是否随请求一起发送默认凭据。UserAgent //获取或设置 User-agent HTTP 标头的值。 方法 1234567891011121314151617181920212223242526272829Abort() //取消向 Internet 资源发出的请求。AddRange(Int32) //向请求添加从请求数据的开始处或结束处的特定范围的字节范围标头。AddRange(Int32, Int32) //向请求添加指定范围的字节范围标头。AddRange(Int64) //向请求添加从请求数据的开始处或结束处的特定范围的字节范围标头。AddRange(Int64, Int64) //向请求添加指定范围的字节范围标头。AddRange(String, Int32) //向请求添加从请求数据的开始处或结束处计算的特定范围的 Range 标头。AddRange(String, Int32, Int32) //向请求添加指定范围的范围标头。AddRange(String, Int64) //向请求添加从请求数据的开始处或结束处计算的特定范围的 Range 标头。AddRange(String, Int64, Int64) //向请求添加指定范围的范围标头。BeginGetRequestStream(AsyncCallback, Object) //开始对用于写入数据的 Stream 对象执行异步请求。BeginGetResponse(AsyncCallback, Object) //开始对 Internet 资源的异步请求。CreateObjRef(Type) //创建一个对象，该对象包含生成用于与远程对象进行通信的代理所需的全部相关信息。(继承自 MarshalByRefObject)EndGetRequestStream(IAsyncResult) //结束对用来写入数据的 Stream 对象的异步请求。EndGetRequestStream(IAsyncResult, TransportContext) //结束对用于写入数据的 Stream 对象的异步请求，并输出与该流关联的 TransportContext。EndGetResponse(IAsyncResult) //结束对 Internet 资源的异步请求。Equals(Object) //确定指定的对象是否等于当前对象。(继承自 Object)GetHashCode() //作为默认哈希函数。(继承自 Object)GetLifetimeService() //检索控制此实例的生存期策略的当前生存期服务对象。(继承自 MarshalByRefObject)GetObjectData(SerializationInfo, StreamingContext) //使用序列化目标对象时所需的数据填充 SerializationInfo。GetRequestStream() //获取用于写入请求数据的 Stream 对象。GetRequestStream(TransportContext) //获取用于写入请求数据的 Stream 对象，并输出与流关联的 TransportContext。GetRequestStreamAsync()//当在子类中被重写时，将用于写入数据的 Stream 作为异步操作返回到 Internet 资源。(继承自 WebRequest)GetResponse()//返回来自 Internet 资源的响应。GetResponseAsync()//当在子代类中被重写时，将作为异步操作返回对 Internet 请求的响应。(继承自 WebRequest)GetType()//获取当前实例的 Type。(继承自 Object)InitializeLifetimeService()//获取生存期服务对象来控制此实例的生存期策略。(继承自 MarshalByRefObject)MemberwiseClone()//创建当前 Object 的浅表副本。(继承自 Object)MemberwiseClone(Boolean)//创建当前 MarshalByRefObject 对象的浅表副本。(继承自 MarshalByRefObject)ToString()//返回表示当前对象的字符串。(继承自 Object) Post&amp;Get 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//POST方法public static string HttpPost(string Url, string postDataStr)&#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url); request.Method = &quot;POST&quot;; request.ContentType = &quot;application/x-www-form-urlencoded&quot;; Encoding encoding = Encoding.UTF8; byte[] postData = encoding.GetBytes(postDataStr); request.ContentLength = postData.Length; Stream myRequestStream = request.GetRequestStream(); myRequestStream.Write(postData, 0, postData.Length); myRequestStream.Close(); HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); StreamReader myStreamReader = new StreamReader(myResponseStream, encoding); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); if (response != null) response.Close(); if (request != null) request.Abort(); return retString;&#125;public static string Post(string Url, string Data, string Referer)&#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url); request.Method = &quot;POST&quot;; request.Referer = Referer; byte[] bytes = Encoding.UTF8.GetBytes(Data); request.ContentType = &quot;application/x-www-form-urlencoded&quot;; request.ContentLength = bytes.Length; Stream myResponseStream = request.GetRequestStream(); myResponseStream.Write(bytes, 0, bytes.Length); HttpWebResponse response = (HttpWebResponse)request.GetResponse(); StreamReader myStreamReader = new StreamReader(response.GetResponseStream(), Encoding.UTF8); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); if (response != null) response.Close(); if (request != null) request.Abort(); return retString;&#125;//GET方法public static string HttpGet(string Url, string postDataStr)&#123; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url + (postDataStr == &quot;&quot; ? &quot;&quot; : &quot;?&quot;) + postDataStr); request.Proxy = null; request.KeepAlive = false; request.Method = &quot;GET&quot;; //request.ContentType = &quot;text/html;charset=UTF-8&quot;; request.ContentType = &quot;application/json; charset=UTF-8&quot;; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream myResponseStream = response.GetResponseStream(); //StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.GetEncoding(&quot;utf-8&quot;)); StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.UTF8); string retString = myStreamReader.ReadToEnd(); myStreamReader.Close(); myResponseStream.Close(); if (response != null) response.Close(); if (request != null) request.Abort(); return retString;&#125; HttpClient HttpClient是.NET4.5引入的一个HTTP客户端库，其命名空间为 System.Net.Http ，.NET 4.5之前我们可能使用WebClient和HttpWebRequest来达到相同目的 HttpClient利用了最新的面向任务模式，使得处理异步请求非常容易 它适合用于多次请求操作，一般设置好默认头部后，可以进行重复多次的请求，基本上用一个实例可以提交任何的HTTP请求 HttpClient有预热机制，第一次进行访问时比较慢，所以不应该用到HttpClient就new一个出来，应该使用单例或其他方式获取HttpClient的实例 构造函数 123HttpClient() //使用释放此实例时释放的 HttpClientHandler 初始化 HttpClient 类的新实例。HttpClient(HttpMessageHandler) //使用指定的处理程序初始化 HttpClient 类的新实例。 处理程序在释放此实例时被释放。HttpClient(HttpMessageHandler, Boolean) //使用提供的处理程序初始化 HttpClient 类的新实例，并指定在释放此实例时是否应释放该处理程序。 属性 123456BaseAddress//获取或设置用于发送请求的 Internet 资源的统一资源标识符 (URI) 的基址。DefaultProxy//获取或设置全局 HTTP 代理。DefaultRequestHeaders//获取应与每个请求一起发送的标头。DefaultRequestVersion//获取或设置对此 HttpClient 实例发出的后续请求使用的默认 HTTP 版本。MaxResponseContentBufferSize//获取或设置要在读取响应内容时缓冲的最大字节数。Timeout//获取或设置请求超时前等待的时间跨度。 方法 123456789101112131415161718192021222324252627282930313233343536373839404142CancelPendingRequests()//取消该实例上的所有挂起的请求。DeleteAsync(String)//以异步操作将 DELETE 请求发送给指定 URI。DeleteAsync(String, CancellationToken)//用以异步操作的取消标记发送 DELETE 请求到指定的 URI。DeleteAsync(Uri)//以异步操作将 DELETE 请求发送给指定 URI。DeleteAsync(Uri, CancellationToken)//用以异步操作的取消标记发送 DELETE 请求到指定的 URI。Dispose()//释放由 HttpMessageInvoker 使用的非托管资源和托管资源。(继承自 HttpMessageInvoker)Dispose(Boolean)//释放由 HttpClient 使用的非托管资源，并可根据需要释放托管资源。Equals(Object)//确定指定的对象是否等于当前对象。(继承自 Object)GetAsync(String)//以异步操作将 GET 请求发送给指定 URI。GetAsync(String, CancellationToken)//用以异步操作的取消标记发送 GET 请求到指定的 URI。GetAsync(String, HttpCompletionOption)//用以异步操作的 HTTP 完成选项发送 GET 请求到指定的 URI。GetAsync(String, HttpCompletionOption, CancellationToken)//用以异步操作的 HTTP 完成选项和取消标记发送 GET 请求到指定的 URI。GetAsync(Uri)//以异步操作将 GET 请求发送给指定 URI。GetAsync(Uri, CancellationToken)//用以异步操作的取消标记发送 GET 请求到指定的 URI。GetAsync(Uri, HttpCompletionOption)//用以异步操作的 HTTP 完成选项发送 GET 请求到指定的 URI。GetAsync(Uri, HttpCompletionOption, CancellationToken)//用以异步操作的 HTTP 完成选项和取消标记发送 GET 请求到指定的 URI。GetByteArrayAsync(String)//将 GET 请求发送到指定 URI 并在异步操作中以字节数组的形式返回响应正文。GetByteArrayAsync(Uri)//将 GET 请求发送到指定 URI 并在异步操作中以字节数组的形式返回响应正文。GetHashCode()//作为默认哈希函数。(继承自 Object)GetStreamAsync(String)//将 GET 请求发送到指定 URI 并在异步操作中以流的形式返回响应正文。GetStreamAsync(Uri)//将 GET 请求发送到指定 URI 并在异步操作中以流的形式返回响应正文。GetStringAsync(String)//将 GET 请求发送到指定 URI 并在异步操作中以字符串的形式返回响应正文。GetStringAsync(Uri)//将 GET 请求发送到指定 URI 并在异步操作中以字符串的形式返回响应正文。GetType()//获取当前实例的 Type。(继承自 Object)MemberwiseClone()//创建当前 Object 的浅表副本。(继承自 Object)PatchAsync(String, HttpContent)//以异步操作方式将 PATCH 请求发送到指定为字符串的 URI。PatchAsync(String, HttpContent, CancellationToken)//以异步操作方式将带有取消令牌的 PATCH 请求发送到表示为字符串的 URI。PatchAsync(Uri, HttpContent)//以异步操作方式发送 PATCH 请求。PatchAsync(Uri, HttpContent, CancellationToken)//以异步操作方式发送带有取消令牌的 PATCH 请求。PostAsync(String, HttpContent)//以异步操作将 POST 请求发送给指定 URI。PostAsync(String, HttpContent, CancellationToken)//用以异步操作的取消标记发送 POST 请求。PostAsync(Uri, HttpContent)//以异步操作将 POST 请求发送给指定 URI。PostAsync(Uri, HttpContent, CancellationToken)//用以异步操作的取消标记发送 POST 请求。PutAsync(String, HttpContent)//以异步操作将 PUT 请求发送给指定 URI。PutAsync(String, HttpContent, CancellationToken)//用以异步操作的取消标记发送 PUT 请求。PutAsync(Uri, HttpContent)//以异步操作将 PUT 请求发送给指定 URI。PutAsync(Uri, HttpContent, CancellationToken)//用以异步操作的取消标记发送 PUT 请求。SendAsync(HttpRequestMessage)//以异步操作发送 HTTP 请求。SendAsync(HttpRequestMessage, CancellationToken)//以异步操作发送 HTTP 请求。SendAsync(HttpRequestMessage, HttpCompletionOption)//以异步操作发送 HTTP 请求。SendAsync(HttpRequestMessage, HttpCompletionOption, CancellationToken)//以异步操作发送 HTTP 请求。ToString()//返回表示当前对象的字符串。(继承自 Object) 单例模式（Singleton Pattern） 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式 懒汉模式 默认不会实例化，什么时候用什么时候new 饿汉模式 类初始化时,会立即加载该对象，线程天生安全,调用效率高 双检锁/双重校验锁（DCL，即 double-checked locking） 这种方式采用双锁机制，安全且在多线程情况下能保持高性能 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class HttpClientHelper&#123; private static readonly object LockObj = new object(); private static HttpClient client = null; public HttpClientHelper() &#123; GetInstance(); &#125; public static HttpClient GetInstance() &#123; if (client == null) &#123; lock (LockObj) &#123; if (client == null) &#123; client = new HttpClient(); &#125; &#125; &#125; return client; &#125; public async Task&lt;string&gt; PostAsync(string url, string strJson)//post异步请求方法 &#123; try &#123; HttpContent content = new StringContent(strJson); content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(&quot;application/json&quot;); //由HttpClient发出异步Post请求 HttpResponseMessage res = await client.PostAsync(url, content); if (res.StatusCode == System.Net.HttpStatusCode.OK) &#123; string str = res.Content.ReadAsStringAsync().Result; return str; &#125; else return null; &#125; catch (Exception ex) &#123; return null; &#125; &#125; public string Post(string url, string strJson)//post同步请求方法 &#123; try &#123; // private static HttpClient client = new HttpClient(); //client.DefaultRequestHeaders.Accept.TryParseAdd(&quot;application/json&quot;); HttpContent content = new StringContent(strJson); content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(&quot;application/json&quot;); //client.DefaultRequestHeaders.Connection.Add(&quot;keep-alive&quot;); //由HttpClient发出Post请求 Task&lt;HttpResponseMessage&gt; res = client.PostAsync(url, content); if (res.Result.StatusCode == System.Net.HttpStatusCode.OK) &#123; string str = res.Result.Content.ReadAsStringAsync().Result; return str; &#125; else return null; &#125; catch (Exception ex) &#123; return null; &#125; &#125; public string Get(string url) &#123; try &#123; // private static HttpClient client = new HttpClient(); //client.DefaultRequestHeaders.Accept.TryParseAdd(&quot;application/json&quot;); var responseString = client.GetStringAsync(url); return responseString.Result; &#125; catch (Exception ex) &#123; return null; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"JSON字符串","slug":"JSON字符串","date":"2020-06-24T02:58:43.000Z","updated":"2025-03-24T11:33:22.271Z","comments":true,"path":"JSON字符串.html","link":"","permalink":"https://silencejql.github.io/JSON%E5%AD%97%E7%AC%A6%E4%B8%B2.html","excerpt":"","text":"C#生成方法 Newtonsoft 12345678910111213141516171819202122232425String apiClass = &quot;apiClass&quot;;String apiCommand = &quot;apiCommand&quot;;JObject postedJObject = new JObject();postedJObject.Add(&quot;class&quot;, apiClass);postedJObject.Add(&quot;cmd&quot;, apiCommand);String param1 = &quot;param1&quot;;String param2 = &quot;param2&quot;;JObject apiJsonParam = new JObject();apiJsonParam.Add(&quot;param1&quot;, param1);apiJsonParam.Add(&quot;param2&quot;, param2);postedJObject.Add(&quot;param&quot;, apiJsonParam);apiJsonParam[&quot;param1&quot;] = param1);apiJsonParam[&quot;param2&quot;] = param2);postedJObject[&quot;param&quot;] = apiJsonParam;JArray jArray = new JArray();JObject arr1 = new JObject();arr1.Add(&quot;arr1&quot;, &quot;this is arr1&quot;);jArray.Add(arr1);JObject arr2 = new JObject();arr2.Add(&quot;arr2&quot;, &quot;this is arr2&quot;);jArray.Add(arr2);postedJObject.Add(&quot;jarray&quot;, jArray);String paramString = postedJObject.ToString(Newtonsoft.Json.Formatting.Indented, null); 输出结果为 12345678910111213141516&#123; &quot;class&quot;: &quot;apiClass&quot;, &quot;cmd&quot;: &quot;apiCommand&quot;, &quot;param&quot;: &#123; &quot;param1&quot;: &quot;param1&quot;, &quot;param2&quot;: &quot;param2&quot; &#125;, &quot;jarray&quot;: [ &#123; &quot;arr1&quot;: &quot;this is arr1&quot; &#125;, &#123; &quot;arr2&quot;: &quot;this is arr2&quot; &#125; ]&#125; 序列化 string StrJson = JsonConvert.SerializeObject(Classobj); 读取保存JSON文件 1234567891011121314151617181920string json = string.Empty;using (FileStream fs = new FileStream(filepath, FileMode.Open, System.IO.FileAccess.Read, FileShare.ReadWrite))&#123; using (StreamReader sr = new StreamReader(fs, Encoding.GetEncoding(&quot;gb2312&quot;))) &#123; json = sr.ReadToEnd().ToString(); &#125;&#125;string json = GetFileJson(filepath); using (FileStream fs = new FileStream(fileFullPath, FileMode.OpenOrCreate, System.IO.FileAccess.ReadWrite, FileShare.ReadWrite))&#123; fs.Seek(0, SeekOrigin.Begin); fs.SetLength(0); using (StreamWriter sw = new StreamWriter(fs, Encoding.UTF8)) &#123; sw.WriteLine(strJson); &#125;&#125; 反序列化 ClassA a = JsonConvert.DeserializeObject(strResult); 12345678910111213141516List&lt;Student&gt; lstStuModel = new List&lt;Student&gt;()&#123;new Student()&#123;ID=1,Name=&quot;Name1&quot;,Age=250,Sex=&quot;男&quot;&#125;,new Student()&#123;ID=2,Name=&quot;Name2&quot;,Age=300,Sex=&quot;女&quot;&#125;&#125;;//Json.NET序列化string jsonData = JsonConvert.SerializeObject(lstStuModel);//Json.NET反序列化string json = @&quot;&#123; &#x27;Name&#x27;:&#x27;Name1&#x27;,&#x27;Age&#x27;:&#x27;3000&#x27;,&#x27;ID&#x27;:&#x27;1&#x27;,&#x27;Sex&#x27;:&#x27;女&#x27;&#125;&quot;;Student descJsonStu = JsonConvert.DeserializeObject&lt;Student&gt;(json);//反序列化Student descJsonStu = JsonConvert.DeserializeObject&lt;Student&gt;(json, Formatting.Indented);//反序列化, 加缩进Console.WriteLine(string.Format(&quot;反序列化： ID=&#123;0&#125;,Name=&#123;1&#125;,Sex=&#123;2&#125;,Sex=&#123;3&#125;&quot;, descJsonStu.ID, descJsonStu.Name, descJsonStu.Age, descJsonStu.Sex));Console.ReadKey(); 12345678910111213141516171819//序列化时默认都是处理公共成员，如果需要处理非公共成员，就要在该成员上加特性[JsonProperty]//类中所有公有成员会被序列化，如果不想被序列化，可以用特性JsonIgnore[JsonObject(MemberSerialization.OptOut)]class TestItem&#123; [JsonProperty] private int testNo; [JsonIgnore] public string testItem; public string testValue;&#125;//所有的成员不会被序列化，类中的成员只有标有特性JsonProperty的才会被序列化[JsonObject(MemberSerialization.OptIn)]class TestItem1&#123; [JsonIgnore] public string testItem; public string testValue;&#125; 其他格式 123456789101112131415161718192021222324//序列化时忽略空值public class Data&#123; [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string itemResult; [JsonProperty(NullValueHandling = NullValueHandling.Ignore)] public string equipmentData;&#125;//自定义时间格式class CustomDateTimeConverter : IsoDateTimeConverter&#123; public CustomDateTimeConverter() &#123; base.DateTimeFormat = &quot;yyyy-MM-dd HH:mm:ss.fff&quot;; &#125;&#125;[JsonConverter(typeof(CustomDateTimeConverter))]public DateTime sendTime;//自定义序列化名称[JsonProperty(PropertyName = &quot;CName&quot;)]public string Name &#123; get; set; &#125; 全局设置(常用) 1234567891011Newtonsoft.Json.JsonSerializerSettings setting = new Newtonsoft.Json.JsonSerializerSettings();JsonConvert.DefaultSettings = new Func&lt;JsonSerializerSettings&gt;(() =&gt; &#123; //日期类型默认格式化处理 setting.DateFormatHandling = Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat; setting.DateFormatString = &quot;yyyy-MM-dd HH:mm:ss.ffff&quot;; //空值处理 setting.NullValueHandling = NullValueHandling.Ignore; //自定义类型转换 setting.Converters.Add(new 自定义类型转换()); return setting;&#125;); 12345678910Newtonsoft.Json.JsonSerializerSettings setting = new Newtonsoft.Json.JsonSerializerSettings &#123; //日期类型默认格式化处理 setting.DateFormatHandling = Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat; setting.DateFormatString = &quot;yyyy-MM-dd HH:mm:ss.ffff&quot;; //空值处理 setting.NullValueHandling = NullValueHandling.Ignore; //自定义类型转换 setting.Converters.Add(new 自定义类型转换()); return setting;&#125;); 匿名类型生成Json字符串 1234567891011var obj = new &#123; Name = &quot;Jone&quot;, Age = 18, Address = new &#123; Street = &quot;123 St&quot;, City = &quot;Shanghai&quot; &#125;&#125;;string jsonString = JsonConvert.SerializeObject(obj, Formatting.Indented);","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"刷题记","slug":"刷题记","date":"2020-06-21T08:37:21.000Z","updated":"2023-01-06T03:28:45.436Z","comments":true,"path":"刷题记.html","link":"","permalink":"https://silencejql.github.io/%E5%88%B7%E9%A2%98%E8%AE%B0.html","excerpt":"简介 记录刷题过程中遇到问题及新知识","text":"简介 记录刷题过程中遇到问题及新知识 System.Collections ArrayList 在C#中，数组由于是固定长度的，由于这种限制不方便，所以出现了ArrayList ArrayList是可变长数组，可以将任意多的数据Add到ArrayList里面。其内部维护的数组，当长度不足时，会自动扩容为原来的两倍。 但是ArrayList也有一个缺点，就是存入ArrayList里面的数据都是Object类型的，所以如果将值类型存入和取出的时候会发生装箱、拆箱操作(就是值类型与引用类型之间的转换)，这个会影响程序性能。在.Net 2.0泛型出现以后，就提供了List。 List List是ArrayList的泛型版本，它不再需要装箱拆箱，直接取，直接用，它基本与ArrayList一致，不过在使用的时候要先设置好它的类型，而设置好类型之后，不是这种类型的数据，是不允许Add进去的 就性能来说，如果要存进数组的只有一种数据，那么无疑List是最优选择 List存储的数据是有序并且可以重复的。 采用链表存储数据 1234567891011121314151617181920List&lt;int&gt; ListInt = new List&lt;int&gt;();// 属性Count// 方法Add(T)AddRange(IEnumerable&lt;T&gt;)Clear()Contains(T)Find(Predicate&lt;T&gt;) //搜索与指定谓词所定义的条件相匹配的元素，并返回整个 List&lt;T&gt; 中的第一个匹配元素FindAll(Predicate&lt;T&gt;) //检索与指定谓词定义的条件匹配的所有元素 返回List&lt;&gt;IndexOf(T) //搜索指定的对象，并返回整个 List&lt;T&gt; 中第一个匹配项的从零开始的索引LastIndexOf(T) //搜索指定对象并返回整个 List&lt;T&gt; 中最后一个匹配项的从零开始索引IndexOf(T, Int32) //搜索指定对象并返回 List&lt;T&gt; 中从指定索引到最后一个元素这部分元素中第一个匹配项的从零开始索引IndexOf(T, Int32, Int32) //搜索指定对象并返回 List&lt;T&gt; 中从指定索引开始并包含指定元素数的这部分元素中第一个匹配项的从零开始索引Insert(Int32, T) //将元素插入到 List&lt;T&gt; 中的指定索引处Remove(T) //从 List&lt;T&gt; 中删除特定对象的第一个匹配项Reverse() //将整个 List&lt;T&gt; 中元素的顺序反转Reverse(Int32, Int32) //将指定范围中元素的顺序反转Sort() //使用默认比较器对整个 List&lt;T&gt; 中的元素进行排序ToArray() //将 List&lt;T&gt; 的元素复制到新数组中 HashTable HashTable是一种根据key查找非常快的键值数据结构，不能有重复key，而且由于其特点，其长度总是一个素数，所以扩容后容量会比2倍大一点点，加载因子为0.72f。 当要大量使用key来查找value的时候，HashTable无疑是最有选择，HashTable与ArrayList一样，是非泛型的，value存进去是object,存取会发生装箱、拆箱，所以出现了Dictionary&lt;T,T&gt; 1234567891011121314// 属性Count //获取包含在 Hashtable 中的键/值对的数目KeysValues// 方法Add(Object, Object)Clear()Clone()Contains(Object)ContainsKey(Object)ContainsValue(Object)GetHash(Object) //返回指定键的哈希代码Remove(Object) Dictionary&lt;T,T&gt; Dictionary&lt;T,T&gt;是HashTable的泛型版本，存取同样快，但是不需要装箱和拆箱了。而且，其优化了算法，Hashtable是0.72，它的浪费容量少了很多 1Dictionary&lt;string,Person&gt; Dic = new Dictionary&lt;string,Person&gt;(); HashSet HashSet类，算法，存储结构都与哈希表相同，主要是设计用来做高性能集运算的，例如对两个集合求交集、并集、差集等。集合中包含一组不重复出现且无特定顺序的元素 HashSet存储的数据是无序并且唯一的，底层使用HashMap存储数据 Add(T) 方法返回值为如果该元素添加到 HashSet 对象中则为 true；如果该元素已存在则为 false 12345678910111213141516HashSet&lt;int&gt; numbers1;HashSet&lt;int&gt; numbers2;//分别进行numbers1和numbers2的值初始化或赋值numbers1.UnionWith(numbers2);//求两个集合的并集。numbers1.IntersectWith(numbers2);//求两个集合的交集。numbers1.ExceptWith(numbers2);//求两个集合的差集。numbers1.SymmetricExceptWith(numbers2);//求两个集合的对称差集。// 属性Count //获取集中包含的元素数Comparer //获取用于确定集中的值是否相等的 IEqualityComparer&lt;T&gt; 对象// 方法Add() //将项目添加到HashSet之中Clear() //清空HashSet里面的值Remove() //从HashSet中移除值Contains() //判断HashSet是否包含指定项目Equals(Object) //判断是否相等 Queue、Queue Queue队列，Queue泛型队列，队列，先进先出 12345678// 属性Count// 方法Clear()Contains(T)Dequeue() //移除并返回位于 Queue&lt;T&gt; 开始处的对象Enqueue(T) //将一个对象添加到 Queue&lt;T&gt; 的末尾Peek() //返回位于 Queue&lt;T&gt; 开始处的对象但不将其移除 Stack、Stack Stack堆栈，先进后出 123456789// 属性Count// 方法Clear()Contains(T)Pop() //删除并返回 Stack&lt;T&gt; 顶部的对象Push(T) //在 Stack&lt;T&gt; 的顶部插入一个对象Peek() //返回位于 Stack&lt;T&gt; 顶部的对象但不将其移除TryPop(T) //返回一个值，该值指示 Stack&lt;T&gt; 的顶部是否有对象；如果有，则将其复制到 result 参数，并从 Stack&lt;T&gt; 中删除它 SortedList、SortedList&lt;TKey,TValue&gt; SortedList集合中的数据是有序的。可以通过key来匹配数据，也可以通过int下标来获取数据 添加操作比ArrayList，Hashtable略慢；查找、删除操作比ArrayList快，比Hashtable慢 SortedDictionary&lt;TKey,TValue&gt; SortedDictionary&lt;TKey,TValue&gt;相比于SortedList&lt;TKey,TValue&gt;其性能优化了，SortedList&lt;TKey,TValue&gt;其内部维护的是数组而SortedDictionary&lt;TKey,TValue&gt;内部维护的是红黑树(平衡二叉树)的一种，因此其占用的内存，性能都好于SortedDictionary&lt;TKey,TValue&gt;。唯一差在不能用下标取值 ListDictionary(单向链表),LinkedList(双向链表) List,ArrayList,Hashtable等容器类，其内部维护的是数组Array来，ListDictionary和LinkedList不用Array，而是用链表的形式来保存。链表最大的好处就是节约内存空间 ListDictionary是单向链表 LinkedList双向链表。双向链表的优势，可以插入到任意位置 HybridDictionary HybridDictionary的类，充分利用了Hashtable查询效率高和ListDictionary占用内存空间少的优点，内置了Hashtable和ListDictionary两个容器，添加数据时内部逻辑如下: 当数据量小于8时，Hashtable为null，用ListDictionary保存数据 当数据量大于8时，实例化Hashtable，数据转移到Hashtable中，然后将ListDictionary置为null BitArray BitArray用于二进制运算，“或”、“非”、“与”、&quot;异或非&quot;等这种操作，只能存true或false 字符串动态匹配算法 BF算法 RK算法 BM算法 KPM算法 Sunday算法 动态规划 可理解为数列求通项过程 f(n) = f(n - 1) + f(n - 2) 逻辑运算符短路效应 123if(A &amp;&amp; B) // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 falseif(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true","categories":[],"tags":[]},{"title":"字符串匹配算法","slug":"字符串匹配算法","date":"2020-06-19T10:28:52.000Z","updated":"2025-03-25T03:28:48.326Z","comments":true,"path":"字符串匹配算法.html","link":"","permalink":"https://silencejql.github.io/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.html","excerpt":"","text":"","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"栈与队列Stack&Queue","slug":"栈与队列Stack-Queue","date":"2020-06-19T03:33:44.000Z","updated":"2025-03-24T11:33:39.174Z","comments":true,"path":"栈与队列Stack-Queue.html","link":"","permalink":"https://silencejql.github.io/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97Stack-Queue.html","excerpt":"","text":"栈与队列 线性表插入和删除操作不受限制 在任意位置进行 栈和队列是两种特殊的线性表。他们的数据元素之间具有顺序的逻辑关系，都采用顺序结构和链式结构存储 栈的插入和删除操作只允许在线性表的尾端(栈顶Top)进行 队列插入操作限定在线性表的尾部而其它操作限定在表的头部进行 栈的特点为后进先出，队列先进先出 栈 表尾称为栈顶（Top）,另一端称为栈底（Bottom），当栈中没有数据元素时叫空栈（Empty Stack） 方法： Push（）入栈 //添加数据 Pop（）出栈 //删除数据，返回被删除的数据 Peek（）//取得栈顶的元素，不删除 ToArray() //方法创建数组并将堆栈元素复制到其中 Contains() //方法判断一个元素是否在栈中 Clear（）//清空所有数据 Count //取得栈中元素的个数 接口定义： 123456789public interface IStack&#123;int Count&#123;get;&#125;//求栈中元素个数int GetLength();//求栈的长度bool IsEmpty();//判断栈是否为空void Clear();//清空操作void Push(T item);//入栈操作T Pop();//出栈操作T Peek();//取栈顶元素&#125; 栈的本质是一个线性表，线性表有两种存储形式，那么栈也有分为栈的顺序存储结构和栈的链式存储结构 用连续的存储空间来存储栈中的数据元素(使用数组)，这样的栈称为顺序栈(Sequence Stack) 类似于顺序表，用一维数组来存放顺序栈中的数据元素 栈顶指示器 top 设在数组下标为 0 的端，top随着插入和删除而变化，当栈为空时，top=-1 栈的另外一种存储方式是链式存储，这样的栈称为链栈(Linked Stack) 由于链栈的操作只是在一端进行，为了操作方便，把栈顶设在链表的头部，并且不需要头结点 示例 123456789101112131415161718192021222324252627282930313233// Stack&lt;T&gt; staA = new Stack&lt;T&gt;();Stack&lt;string&gt; staA = new Stack&lt;string&gt;(); staA.Push(&quot;one&quot;); staA.Push(&quot;two&quot;); staA.Push(&quot;three&quot;); staA.Push(&quot;four&quot;); staA.Push(&quot;five&quot;); foreach (string a in staA)//遍历元素，将之变成string类型 &#123; Console.WriteLine(a); &#125; //peek是把栈顶元素弹出（取出），但不删除 Console.WriteLine(&quot;取出的元素是：&#123;0&#125;&quot;, staA.Peek()); //pop是把栈顶的元素弹出（取出），并将其删除 Console.WriteLine(&quot;删除的栈顶元素是：&#123;0&#125;&quot;,staA .Pop ()); //此时再输出一次栈的元素，会发现five被删除了 foreach (string b in staA) &#123; Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(b); &#125; //ToArray从栈底到栈顶将一个栈复制到另一个栈中 Stack&lt;string&gt; staB = new Stack&lt;string&gt;(staA.ToArray()); foreach (string c in staB) &#123; Console.ForegroundColor = ConsoleColor.Cyan; Console.WriteLine(c); &#125; Console.WriteLine(&quot; &quot;); Console.ForegroundColor = ConsoleColor.DarkRed; //contains方法，判断一个元素是否在栈中 Console.WriteLine(&quot;six是否在栈中？&quot;); Console.WriteLine(staA .Contains (&quot;six&quot;)); 队列 插入操作的表尾称为队尾(Rear)，把进行其它操作的头部称为队头(Front)。当队列中没有数据元素时称为空队列(EmptyQueue) 方法： Enqueue() 入队（放在队尾） Dequeue() 出队（移除队首元素，并返回被移除的元素） Peek() 取得队首的元素，不移除 Clear() 清空元素 接口定义： 123456789public interface IQueue&lt;T&gt;&#123;int Count&#123;get;&#125;//取得队列长度的属性int GetLength();//求队列的长度bool IsEmpty();//判断队列是否为空void Clear();//清空队列void Enqueue(T item);//入队T Dequque();//出队T Peek();//取队头元素&#125; 用连续的存储空间来存储队列中的数据元素，这样的队列称为顺序队列(SequenceQueue) 类似于顺序栈，用一维数组来存放顺序队列中的数据元素。队头位置设在数组下标为 0 的端，用 front 表示；队尾位置设在数组的另一端，用rear 表示 front 和 rear 随着插入和删除而变化。当队列为空时， front=rear=-1 队列的另外一种存储方式是链式存储，这样的队列称为链队列(LinkedQueue) 由于链队列的操作只是在一端进行，为了操作方便，把队头设在链表的头部，并且不需要头结点","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"Hashmap、Hashtabel、Dictionary","slug":"Hashmap、Hashtabel、Dictionary","date":"2020-06-18T01:58:07.000Z","updated":"2025-03-24T11:33:09.272Z","comments":true,"path":"Hashmap、Hashtabel、Dictionary.html","link":"","permalink":"https://silencejql.github.io/Hashmap%E3%80%81Hashtabel%E3%80%81Dictionary.html","excerpt":"参考：https://blog.csdn.net/woshimaxiao1/article/details/83661464","text":"参考：https://blog.csdn.net/woshimaxiao1/article/details/83661464 Hashmap HashMap是Java 1.2引进的Map接口的一个实现，c#中无HashMap 数组 采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) 线性链表 对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) 二叉树 对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 哈希表 相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。 当要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。 存储位置 = 哈希函数f(关键字) 哈希冲突 两个不同的元素，通过哈希函数得出的实际存储地址相同 HashMap采用了链地址法，也就是数组+链表的方式解决哈希冲突 HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可 HashMap可以简单理解为由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的 Hashtable 哈希表（HashTable）又叫做散列表，是根据关键码值（即键值对）而直接访问的数据结构。也就是说，它通过把关键码映射到表中一个位置来访问记录，以加快查找速度，Hashtable是基于Dictionary类的 Hashtable 与 Hashmap区别 Hashtable 底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化 初始size为11，扩容：newsize = olesize*2+1 计算index的方法：index = (hash &amp; 0x7FFFFFFF) % tab.length Hashmap 底层数组+链表实现，可以存储null键和null值，线程不安全 初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂 扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入 插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容） 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀 计算index方法：index = hash &amp; (tab.length – 1) HashTable和Dictionary区别 HashTable不支持泛型，而Dictionary支持泛型。 Hashtable 的元素属于 Object 类型，所以在存储或检索值类型时通常发生装箱和拆箱的操作，所以你可能需要进行一些类型转换的操作，而且对于int,float这些值类型还需要进行装箱等操作，非常耗时。 单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分。多线程程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型. 而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。 在通过代码测试的时候发现key是整数型Dictionary的效率比Hashtable快，如果key是字符串型，Dictionary的效率没有Hashtable快。","categories":[],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"动态EV(ETP)测试","slug":"动态EV-ETP-测试","date":"2020-06-05T07:31:43.000Z","updated":"2025-03-07T12:37:18.944Z","comments":true,"path":"动态EV-ETP-测试.html","link":"","permalink":"https://silencejql.github.io/%E5%8A%A8%E6%80%81EV-ETP-%E6%B5%8B%E8%AF%95.html","excerpt":"说明 动态EV或ETP工位简单说明","text":"说明 动态EV或ETP工位简单说明 新版本ETP测试工况分四部分：加速、匀速、滑行、制动 测试内容除了基本电流电压等BMS数据读取还包括各阶段的效率及能量消耗率的计算等 程序配置 最新程序增加是否为同轴滚筒的配置：在EvDynamicTestCurve.xml中isCoaxial配置为true表示为同轴滚筒 非同轴滚筒计算时F为左右滚筒的合力 计算方法 加速、匀速过程中电能转化为动能，效率计算公式为 Fvt/UIt 滑行、制动过程中动能转化为电能，效率计算公式为 UIt/Fvt 其中F、v、U、I均为各阶段的平均值 能量消耗率 C = E/D 单位为(kWh)/100km 程序中的计算公式为：整个过程中的平均100UIt/d 说明 由于I为负数时表示放电加速所以计算时简单处理为 I为负：效率 = Fvt/UIt I为正：效率 = UIt/Fvt","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"PostgreSQL数据库","slug":"PostgreSQL数据库","date":"2020-05-27T06:53:36.000Z","updated":"2025-03-24T11:33:01.316Z","comments":true,"path":"PostgreSQL数据库.html","link":"","permalink":"https://silencejql.github.io/PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93.html","excerpt":"BBK设备数据库常用操作说明","text":"BBK设备数据库常用操作说明 新增数据表 创建脚本修改字段和表名 打开数据表所在路径： 更改图中相应字段表名后点击黑色方框中的执行按钮并确认输出窗口为成功即可 新增字段 当保存数据时Systemerror.log中存在警告缺少字段是可在数据库中新增缺少的字段 图中Miss Field List:后面就是数据库中缺少的字段名 创建脚本新增字段 如下所示，新增字段并根据需要更改字段长度即可 1234567-- Column: &quot;前轮侧滑&quot;-- ALTER TABLE public.&quot;侧滑表&quot; DROP COLUMN &quot;前轮侧滑&quot;;ALTER TABLE public.&quot;侧滑表&quot; ADD COLUMN &quot;新增字段1&quot; character varying(10);ALTER TABLE public.&quot;侧滑表&quot; ADD COLUMN &quot;新增字段2&quot; character varying(10);ALTER TABLE public.&quot;侧滑表&quot; ADD COLUMN &quot;新增字段3&quot; character varying(10);","categories":[{"name":"Postgre","slug":"Postgre","permalink":"https://silencejql.github.io/categories/Postgre/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://silencejql.github.io/tags/PostgreSQL/"}]},{"title":"BBK检测线联网","slug":"BBK检测线联网","date":"2020-05-24T01:50:22.000Z","updated":"2025-03-07T12:36:18.510Z","comments":true,"path":"BBK检测线联网.html","link":"","permalink":"https://silencejql.github.io/BBK%E6%A3%80%E6%B5%8B%E7%BA%BF%E8%81%94%E7%BD%91.html","excerpt":"检测线联网相关的基本配置说明","text":"检测线联网相关的基本配置说明 设备设置 1、设备及服务器安装好运行环境 2、关闭防火墙 3、分配IP 4、保证工位与服务器相互可以Ping通 工位配置 PostgreSQL配置 打开PostgreSQL菜单：工具-服务器配置-pg_hba.conf 新增如图配置后保存 BBK软件配置 1、确认流程中有初始化联网步骤，一般在Init_InitConst中一般命名为InitNet 2、确认流程中有上图中的红框中的设备号、线号的步骤 若没有可参考带有初始化联网的程序进行添加 3、打开BBK软件在菜单中配置线号、设备号、服务器IP 服务器软件配置 打开服务软件所在文件夹中Set.mdb数据库进行服务器联网配置 StationConfig 该表中每一行代表一个工位 字段说明： DeviceID：对应工位配置的设备号DeviceID Describe：用于服务器显示的设备描述 LineID：对应工位配置的线号LineID IPAdsress：工位IP StationNo：用于服务器显示工位顺序 StationUpload：设置当前工位需要上传的表名 逗号为英文字符 车辆查看配置 改表为显示测试数据页面的相关配置，根据需求进行相应配置即可 四轮与标定或侧滑通讯 四轮 四轮程序中创建GeneralLib.xDvConfigClient对象 并在该对象下创建需要共享的对象 调用该对象的Init函数，参数选GeneralLib.xRemoterClientConfig； 初始化后会自动生成创建 需要传值时直接给变量赋值即可 标定或侧滑 创建GeneralLib.GenO对象 调用该对象的InitRemoterTcpserver函数即可。 配置 打开四轮程序，配置文件中会自动生成相关配置，对对象进行绑定即可；","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"BBK软件设置密码方法","slug":"BBK软件设置密码方法","date":"2020-05-09T02:15:29.000Z","updated":"2025-03-07T12:36:49.931Z","comments":true,"path":"BBK软件设置密码方法.html","link":"","permalink":"https://silencejql.github.io/BBK%E8%BD%AF%E4%BB%B6%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E6%96%B9%E6%B3%95.html","excerpt":"BBK软件设置密码方法","text":"BBK软件设置密码方法 步骤一 在Bin文件夹中找到LoginLock.Lock文件，将其复制到C盘根目录下 若无此文件可新建文本文档后另存为此名称，内容为 12SuperAccount = &quot;BBKTSTSYS&quot;;SuperPassword = &quot;ZMY20140527&quot;; 均为英文字符 步骤二 编辑方式打开设备程序使用的always文件(桌面快捷方式对应文件) 1、双击打开组合列表中Always下的InitForm组合 2、双击打开Menu，点击HELP进入菜单编辑界面 3、选择需要设置密码的菜单项及子项后，选择右侧需要权限,权限0为不需要权限，不同应权限可设置相应密码 0~9为权限等级，高等级可访问低等级权限，比如权限9可访问所有内容 4、更改完成后依次点击保存后退出 步骤三 设置权限密码 双击打开always程序，点击左上角登录弹出如下界面 输入管理员账号后点击设置进行账户管理 SuperAccount = “BBKTSTSYS” SuperPassword = “ZMY20140527” 设置完成后便可登录相应等级账户","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"VCU","slug":"VCU","date":"2020-04-22T04:13:02.000Z","updated":"2025-03-24T11:32:32.925Z","comments":true,"path":"VCU.html","link":"","permalink":"https://silencejql.github.io/VCU.html","excerpt":"","text":"协议需求 CANID： 静态 预充截止电压PreChargeVoltageGetTest： (D01E- Battery External Voltage电池包外侧总电压) 绝缘电阻InsulationResistanceGetTest： (D01C- Battery Insulation Resistance电池包的绝缘值) 电池静态温度BatteryTemperatureRiseTestT1： (D02B- Battery Average Temperature电池温升) 动态 MCU转速MCUSpeedGetTest： (电机当前转速D034- Motor Actual Speed) MCU温度MCUTempretureGetTest：D061 (MCU温度D02E- Inverter Actual Temperature) 电机温度MotorTempretureGetTest：C952 (电机温度D036- Motor Actual Temperature) 放电电流BatteryTotalCurrentTest：D030 (充电电流D027- Battery Total Current充电时电流为负值) 电池温升BatteryTemperatureRiseTestT2：D047 (D02B- Battery Average Temperature电池温升) 车速传感器SpeedSensorGetTest： 判断制动踏板ReadBrakeStatus： 刹车回馈电流FeedbackCurrentGetTest：D030 (D027- Battery Total Current回馈电流) MCU转速与实际车速差值PreChargeVoltageGetTest：","categories":[],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"lambda Expressions","slug":"lambda-Expressions","date":"2020-04-10T03:57:41.000Z","updated":"2025-03-24T11:32:18.315Z","comments":true,"path":"lambda-Expressions.html","link":"","permalink":"https://silencejql.github.io/lambda-Expressions.html","excerpt":"","text":"Expression lambda 使用 lambda 声明运算符 =&gt; 从其主体中分离 lambda 参数列表。 若要创建 Lambda 表达式，需要在 Lambda 运算符左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。 任何 Lambda 表达式都可以转换为委托类型。 Lambda 表达式可以转换的委托类型由其参数和返回值的类型定义。如果 lambda 表达式不返回值，则可以将其转换为 Action 委托类型之一；否则，可将其转换为 Func 委托类型之一。 例如，有 2 个参数且不返回值的 Lambda 表达式可转换为 Action&lt;T1,T2&gt; 委托。 有 1 个参数且不返回值的 Lambda 表达式可转换为 Func&lt;T,TResult&gt; 委托。 以下示例中，lambda 表达式 x =&gt; x * x （指定名为 x 的参数并返回 x 平方值）将分配给委托类型的变量： 1234Func&lt;int, int&gt; square = x =&gt; x * x;Console.WriteLine(square(5));// Output:// 25 仅当 lambda 只有一个输入参数时，括号才是可选的；否则括号是必需的。 12345678910// 使用空括号指定零个输入参数：Action line = () =&gt; Console.WriteLine();// 括号内的两个或更多输入参数使用逗号加以分隔：Func&lt;int, int, bool&gt; testForEquality = (x, y) =&gt; x == y;// 有时，编译器无法推断输入类型。 可以显式指定类型，如下面的示例所示：Func&lt;int, string, bool&gt; isTooLong = (int x, string s) =&gt; s.Length &gt; x;// 输入参数类型必须全部为显式或全部为隐式； Statement lambda 1234567891011(input-parameters) =&gt; &#123; &lt;sequence-of-statements&gt; &#125;Func&lt;int, int, int&gt; func = (x, y) =&gt; &#123; for (int i = 0; i &lt; y; i++) &#123; x += i; &#125; return x; &#125;;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"工作日志","slug":"工作日志","date":"2020-03-23T01:53:06.000Z","updated":"2025-03-07T12:35:23.060Z","comments":true,"path":"工作日志.html","link":"","permalink":"https://silencejql.github.io/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97.html","excerpt":"记录所有项目工作日志以便查询，年份、项目号分类","text":"记录所有项目工作日志以便查询，年份、项目号分类 2020 March3 郑州日产登录工位偶发卡死现象处理 1、更改原有C++程序，在更新登录表处增加try…catch… 2、用新程序替换，程序中UDP更新服务器表格应在程序处理前 解决方式：更新登录表数据增加超时时间为0解决 金华零跑MES 7月 青岛五菱 双轴制动台改单轴测试小轴距E50ABS 现场制动台车型获取说明:扫完VIN后通过桌面上小黄车的软件从MES获取车型信息包括轴距、ABS类型等，调用的测试流程在SpecialNeed中进行判断赋值，车型库不需要手动维护，MES下载后自动维护。 现场更新不兼容程序有： CANCmdLib.dll CanCmdOpraLib.dll 更改后100V车型K线通讯出现指令数据丢失 MBKDeviceWithOPC.dll 更新后无法控制滚筒转动 E50ABS程序中读取DTC无法判断五菱现场的当前故障码 8月 郑州日产 增加compactor标定 中牟日产 增加国六打印程序，客户只查看不打印，很多信息均从客户配置的excel中读取 9月 十堰小康 RFID调试、国六数据上传国家 长春一汽轿车 新增E111ESP标定和动态测试，跟205、141程序一样。 更改4线服务器线号 更改3线转毂线号，速度表主键丢失导致速度表无法上传 一汽红旗 更新绝缘检测程序，提升20s测试节拍 调试HUD，测试完成传结果给手持，更改测试项判断修正界面显示整体合格 10月 十堰小康老厂 四轮工位增加ACC标定 1017 - 流程调试完成，测试过程中左上反馈的角度与实际相反，标定顺序没问题标靶面对车的一面先低头、再平、再抬头。 - 垂直合格范围-3~-1度存在疑问。 角度计算在RBABS_ShiYXiaoKang.ADASCalculate中的AEBCalculate(ECU回复指令;是否需要调整;调整圈数) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public xState AEBCalculate(string sPara)&#123; try &#123; string[] SepPara; XmlFO.SepParams(sPara, 3, out SepPara); byte[] bRecv = StringToBytes(SepPara[0]); byte[] tmpBytes = new byte[] &#123; bRecv[4], bRecv[3] &#125;; Int16 iHorizontal = BitConverter.ToInt16(tmpBytes, 0); double dHorizontal = (iHorizontal * 0.01); XmlFO.LogOut(&quot;ACCCalculate&quot;, &quot;dHorizontal:&quot; + dHorizontal); double dHorTurns = dHorizontal / 0.5359; tmpBytes = new byte[] &#123; bRecv[6], bRecv[5] &#125;; Int16 iVertical = BitConverter.ToInt16(tmpBytes, 0); double dVertical = (iVertical * 0.01); XmlFO.LogOut(&quot;ACCCalculate&quot;, &quot;dVertical:&quot; + dVertical); double dVerTurns = (-2 - dVertical) / 0.7729; string adjustTips = string.Empty; if (dVertical &lt; -3 || dVertical &gt; -1 || dHorizontal &lt; -0.3 || dHorizontal &gt; 0.3) &#123; // Res XmlFO.ListObject[SepPara[1]].xValue = &quot;Y&quot;; adjustTips = &quot;左上：&quot; + (dHorTurns &gt; 0 ? &quot;逆时针：&quot; + dHorTurns.ToString(&quot;0.00&quot;) + &quot;圈&quot; : &quot;顺时针：&quot; + (-dHorTurns).ToString(&quot;0.00&quot;) + &quot;圈&quot;); adjustTips += &quot;右下：&quot; + (dVerTurns &gt; 0 ? &quot;逆时针：&quot; + dVerTurns.ToString(&quot;0.00&quot;) + &quot;圈&quot; : &quot;顺时针：&quot; + (-dVerTurns).ToString(&quot;0.00&quot;) + &quot;圈&quot;); &#125; else &#123; XmlFO.ListObject[SepPara[1]].xValue = &quot;N&quot;; adjustTips = &quot;水平角度：&quot; + dHorizontal.ToString(&quot;0.00&quot;); adjustTips += &quot;垂直角度：&quot; + dVertical.ToString(&quot;0.00&quot;); adjustTips += &quot;; 不需要调整&quot;; &#125; XmlFO.ListObject[SepPara[2]].xValue = adjustTips; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125; 武汉东风雷诺 卡规侧滑 Modbus读取 卡规：192.168.100.17 : 502 侧滑：192.168.100.18 : 502 03读取保持寄存器，地址为 C0 卡规：0x0B, 0x03, 0x00, 0x00, 0x00, 0x06, 0xFF, 0x03, 0x00, 0xC0, 0x00, 0x02 侧滑: 0x0B, 0x03, 0x00, 0x00, 0x00, 0x06, 0xFF, 0x03, 0x00, 0xC0, 0x00, 0x02 0x0B, 0x01, 0x00, 0x00, 0x00, 0x06, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x01 0x0F, 0x03, 0x00, 0x00, 0x00, 0x06, 0xFF, 0x03, 0x01, 0x80, 0x00, 0x01 0x0F, 0x01, 0x00, 0x00, 0x00, 0x06, 0xFF, 0x06, 0x01, 0x80, 0x00, 0x00// 0xXX 四轮卡规读取：配置文件为MeasToolAnalogLeveler-LH.dat，二进制文件直接转换 公式为：swaAngle = (AI - swaB) / (AI &gt; swaB ? positiveK : negativeK); 侧滑模拟量计算公式(来自fori源代码)： 123456789101112int AI = RvBuf[9] * 256 + RvBuf[10];if ((RvBuf[9] &amp; 0x80) == 0x80) AI = AI - 65535 - 1;if (AI &gt; 0)&#123; AI = (AI &amp; 0xFFF0) &gt;&gt; 4;&#125;else&#123; AI = System.Math.Abs(AI); AI = -(((Int16)AI &amp; 0xFFF0) &gt;&gt; 4);&#125; 更新侧滑软件，更新为Edison给的方式； 转毂在RBDVTEx基础上更改，新增RBDVTForiH 11月 西安比亚迪 IPB升级，参考长沙比亚迪：四轮标定包括SAS、内部传感器、VPC 转毂做IPB泄漏检查和动态(ESC)，泄漏检查结果上传到福瑞数据库 长春一汽轿车 速度表无法上传：access数据库主键丢失 2021 3月 武汉日产 速度制动台，驱动程序同转毂 技术协议中包含：制动、速度、ABS、声级、刹车距离 目前只测试：制动、速度。 武汉东风乘用车 DVT更新G35程序后1112ESC测试中出现故障判定不合格，换回以前的always文件解决(时间太久忘记改了什么，新程序测试结束多了读取故障码的步骤)","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Python爬虫基础","slug":"Python爬虫基础","date":"2020-03-05T04:04:12.000Z","updated":"2025-03-24T11:32:06.104Z","comments":true,"path":"Python爬虫基础.html","link":"","permalink":"https://silencejql.github.io/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80.html","excerpt":"","text":"HTTP URL格式：http://host[:port][path] host：合法的Internet主机域名或IP地址 port：端口号，默认为80 path：请求资源的路径 Urllib Urllib库|说明 :|: urllib.request | 请求模块 urllib.error | 异常处理模块 urllib.parse | url解析模块 urllib.robotparser | robots.txt解析模块 urllib.request.urlopen(url,data=None,[timeout,]*,cafile=None,cadefault=False,context=None) Requests 1r = requests.get(url,params=None,**kwargs) Requests方法 | 说明 :|: requests.request() | 构造一个请求，支撑以下各方法 requests.get() | 获取HTML网页，对应HTTP的GET requests.head() | 获取HTMLheader，对应HTML的HEAD requests.post() | 向HTML网页提交POST请求 requests.put() | 向HTML网页提交PUT请求 requests.patch() | 向HTML网页提交局部修改请求 requests.delete() | 向HTML网页提交删除请求 Requests对象属性|说明 :|: r.status_code |HTTP请求返回的状态，200连接成功，404表示失败 r.text |HTTP响应内容的字符串形式，URL对应的页面内容 r.encoding |HTTP header中猜测的响应内容编码方式 r.apparent_encoding |内容中分析出的响应内容编码格式（备选编码格式） r.content | HTTP响应内容的二进制格式 r.encoding：如果header中不存在charset，则默认编码为ISO-8859-1(不支持解析中文) 将r.apparent_encoding设置为utf-8可解决上述可能出现乱码问题 baidu搜索关键词 百度搜索关键词对应：wd=keyword 123kv = &#123;&#x27;wd&#x27;:&#x27;Python&#x27;&#125;r = requests.get(&quot;http://www.baidu.com/s&quot;,params = kv) 通用代码框架 123456789101112131415import requestsdef GetHTMLText(url): try: header = &#123;&#x27;user-agent&#x27;:&#x27;Mozilla/5.0&#x27;&#125; r = requests.get(url,headers=header) r.raise_for_status() #如果状态不是200则引发HTTPError异常 r.encoding = r.apparent_encoding return r.text except: return &quot;异常&quot;if __name__ == &quot;__main__&quot;: url = &quot;http://&quot; print(GetHTMLText(url)) 信息标记形式 XML 标签、属性、内容 123&lt;name&gt; ... &lt;/name&gt;&lt;name /&gt;&lt;!-- --&gt; JSON 有类型的键值对表示 无法注释 123&quot;key&quot;:&quot;value&quot;&quot;key&quot;:[&quot;value1&quot;,&quot;value2&quot;]&quot;key&quot;:&#123;&quot;subkey&quot;:&quot;subvalue&quot;&#125; YAML 无类型键值对 123456key:valuekey:#comments-value1-value2key: subkey:subvalue Selenium 声明浏览器对象 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.Safari()browser = webdriver.PhantomJS() 1234567891011121314151617# 打开网页browser = webdriver.Chrome()browser.get(&quot;https://www.baidu.com&quot;)print(browser.page_source)browser.close()#查找单个元素first = browser.find_element_by_id(&#x27;q&#x27;)second = browser.find_element_by_css_selector(&#x27;#q&#x27;)# #表示id,.表示类,不加前缀表示标签third = browser.find_element_by_xpath(&#x27;//*[@id=&quot;q&quot;]&#x27;)print(first,second,third)## 通用方法from selenium.webdriver.common.by import Bycommon = browser.find_element(By.ID,&#x27;q&#x27;)commons = browser.find_elements(By.ID,&#x27;q&#x27;) # 查找多个元素browser.close() 元素交互 实现淘宝搜索功能 123456789101112from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get(&quot;https://www.taobao.com&quot;)input = browser.find_element_by_id(&#x27;q&#x27;) #找到网页中搜索框对应的idinput.send_keys(&#x27;iPhone&#x27;) #向搜索框中传递的参数time.sleep(1)input.clear()input.send_keys(&#x27;iPad&#x27;)button = browser.find_element_by_class_name(&#x27;btn_search&#x27;) #找到搜索按钮对应的namebutton.click() 实例 爬取图片、视频等 123456789101112131415161718import requestsimport osurl = &quot;&quot;root = &quot;D://Python//Pic&quot;path = root + url.split(&#x27;/&#x27;)[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path,&#x27;wb&#x27;) as f f.write(r.content) f.close() print(&quot;文件保存成功&quot;) else: print(&quot;文件已存在&quot;)except: print(&quot;爬取失败&quot;)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/tags/Python/"}]},{"title":"网络学习随记","slug":"网络学习随记","date":"2020-02-27T05:54:46.000Z","updated":"2023-04-18T02:46:50.289Z","comments":true,"path":"网络学习随记.html","link":"","permalink":"https://silencejql.github.io/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0.html","excerpt":"应用层-表示层-会话层---HTTP/FTP/DNS/Telnet... 传输层---TCP/UDP 网络层---IP/ARP/ICMP/RARP 数据链路层 物理层","text":"应用层-表示层-会话层---HTTP/FTP/DNS/Telnet... 传输层---TCP/UDP 网络层---IP/ARP/ICMP/RARP 数据链路层 物理层 物理层 -Bit流 数据链路层 帧 交换机 可识别MAC FCS|Data|SIP|DIP|SMAC|DMAC 网络层 包 协议 IP、ARP、ICMP、IGMP 路由器 可识别IP Data|SIP|DIP ARP ARP广播查询目标MAC地址 ipconfig /all查看网卡MAC arp -a查询局域网内MAC ARP欺骗 arp -s ip mac设置静态MAC(更改网络通讯中IP对应的MAC) 网卡属性中修复可重置 ICMP PING-Packet Internet Grope因特网包探索器 ping局域网延迟一般小于10ms TTL数据包生存周期，每过一个路由-1，防止网络回路 ping ip -i n 通过n值查看途经路由器IP 默认TTL： Linux : 64 Windows : 128 Unix : 255 tracert ip 跟踪数据包路径 pathping 跟踪数据包路径，计算丢包情况 路由 静态路由 管理员配置路径 动态路由 RIP协议 最大15级 传输层 netstat -n查看会话 netstat -nb查看会话及会话进程 netstat -an查看监听端口 端口 16位 常用端口：0-1023 登机端口：1024-49151 客户端端口：49152-65535 常见应用层协议端口 协议|端口 :|: http |TCP:80 https |TCP:443 ftp |TCP:21 RDP |TCP:3389 远程桌面 SMTP |TCP:25 POP3 |TCP:110 Telnet |TCP:23 SQL |TCP:1433 | DNS |UDP:53(一般) 套接字 socket=IP:Port 其他 设置开/关机/登录启动脚本 gpedit.msc","categories":[],"tags":[]},{"title":"Python script save somethings","slug":"Python-script-save-somethings","date":"2020-02-07T03:41:22.000Z","updated":"2023-04-18T02:46:50.289Z","comments":true,"path":"Python-script-save-somethings.html","link":"","permalink":"https://silencejql.github.io/Python-script-save-somethings.html","excerpt":"","text":"保存图片 urllib 用法：urlretrieve(url, filename=None, reporthook=None, data=None) 参数 finename 指定了保存本地路径（如果参数未指定，urllib会生成一个临时文件保存数据） 参数 reporthook 是一个回调函数，当连接上服务器、以及相应的数据块传输完毕时会触发该回调，我们可以利用这个回调函数来显示当前的下载进度 参数 data 指 post 到服务器的数据，该方法返回一个包含两个元素的(filename, headers)元组，filename 表示保存到本地的路径，header 表示服务器的响应头 123456789# -*- coding: utf-8 -*-import urllib#常用img_src = &#x27;http://724.169pp.net/bizhi/2017/039/1.jpg&#x27;urllib.request.urlretrieve(img_src,r&#x27;C:\\\\Users\\\\ME\\\\Desktop\\\\1.jpg&#x27;)#seconddata = urllib.urlopen(img_src).read()with open(&quot;bbb.jpg&quot;, &quot;wb&quot;)as f: # wb是写二进制 f.write(data) PIL+requests PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用 requests是python实现的最简单易用的HTTP库，建议爬虫使用requests库。默认安装好python之后，是没有安装requests模块的，需要单独通过pip安装 BytesIO是用来操作二进制数据的，因为图片是二进制数据，和它相对的自然是StringIO，这是用来存str的。他们的区别就好似python读写普通文件和二进制文件 1234567891011121314# -*- coding: utf-8 -*-import requestsfrom PIL import Imagefrom io import BytesIOimg_src = &#x27;http://724.169pp.net/bizhi/2017/039/1.jpg&#x27;response = requests.get(img_src)image = Image.open(BytesIO(response.content))#image = Image.open(StringIO(response.content))image.save(r&#x27;C:\\\\Users\\\\ME\\\\Desktop\\\\&#x27; + &#x27;1.jpg&#x27;)#second 常用src = &quot;https://i0.hdslb.com/bfs/sycp/creative_img/201912/01b2f081d58e49c708c1d32b7b8c20ed.jpg&quot;#r = requests.get(src,headers=header)with open(&quot;bbb.jpg&quot;, &quot;wb&quot;)as f: # wb是写二进制 f.write(requests.get(src,headers=header).content) 保存视频 1234567import reimport requestsresponse = requests.get(&#x27;https://vd4.bdstatic.com/mda-jcrx64vi5vct2d2u/sc/mda-jcrx64vi5vct2d2u.mp4?auth_key=1557734214-0-0-d6a29a90222c6caf233e8a2a34c2e37a&amp;bcevod_channel=searchbox_feed&amp;pd=bjh&amp;abtest=all&#x27;)video = response.content #把文件保存成二进制with open(r&#x27;D:\\图片\\绿色.mp4&#x27;,&#x27;wb&#x27;) as fw: fw.write(video) #将文件内容写入该文件 fw.flush() #刷新","categories":[{"name":"Python3","slug":"Python3","permalink":"https://silencejql.github.io/categories/Python3/"}],"tags":[]},{"title":"Python learning - Script","slug":"Python-learning-Script","date":"2020-02-06T05:02:00.000Z","updated":"2025-03-25T03:22:52.085Z","comments":true,"path":"Python-learning-Script.html","link":"","permalink":"https://silencejql.github.io/Python-learning-Script.html","excerpt":"","text":"例：获取播放量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding: UTF-8 -*-from urllib.request import urlopenfrom bs4 import BeautifulSoupimport requestsimport csvimport timeimport urllibimport refrom selenium import webdriver#html = requests.get(&quot;https://www.bilibili.com/anime/index/#st=1&amp;order=2&amp;season_version=-1&amp;area=-1&amp;is_finish=-1&amp;copyright=-1&amp;season_status=-1&amp;season_month=-1&amp;year=-1&amp;style_id=-1&amp;sort=0&amp;page=1&quot;)#html = urlopen(&quot;https://www.bilibili.com/anime/index/#st=1&amp;order=2&amp;season_version=-1&amp;area=-1&amp;is_finish=-1&amp;copyright=-1&amp;season_status=-1&amp;season_month=-1&amp;year=-1&amp;style_id=-1&amp;sort=0&amp;page=1&quot;)#html.encoding = &#x27;utf-8&#x27;with open(&quot;test.csv&quot;, &quot;w+&quot;) as csvfile: writer = csv.writer(csvfile, delimiter=&#x27;,&#x27;) writer.writerow([&quot;Name&quot;, &quot;Viewers&quot;]) for i in range(1,50): option = webdriver.ChromeOptions() # 设置不加载页面 option.add_argument(&quot;headless&quot;) # 设置默认编码为 utf-8 option.add_argument(&#x27;lang=zh_CN.UTF-8&#x27;) option.add_argument(&#x27;--disable - plugins&#x27;) #option.add_argument(&#x27;blink-settings=imagesEnabled=false&#x27;) #prefs = &#123;&quot;profile.managed_default_content_settings.images&quot;: 2&#125; #option.add_experimental_option(&quot;prefs&quot;, prefs) driver = webdriver.Chrome(chrome_options=option) html = &quot;https://www.bilibili.com/anime/index/#st=1&amp;order=2&amp;season_version=-1&amp;area=-1&amp;is_finish=-1&amp;copyright=-1&amp;season_status=-1&amp;season_month=-1&amp;year=-1&amp;style_id=-1&amp;sort=0&amp;page=&quot; + str(i) print(html) html.encode(&#x27;utf-8&#x27;) driver.get(html) time.sleep(3) driver.minimize_window() bsObj = BeautifulSoup(driver.page_source.replace(&#x27;&amp;nbsp;&#x27;, &#x27; &#x27;),&quot;lxml&quot;) #AnimeList = bsObj.select(&quot;bangumi-item&quot;) AnimeList = bsObj.findAll(class_=&quot;bangumi-item&quot;) for ani in AnimeList: writer.writerow([ani.find(&quot;a&quot;,class_=&quot;bangumi-title&quot;).get_text(),ani.find(&quot;div&quot;,class_=&quot;shadow&quot;).get_text()]) url = ani.find(&quot;div&quot;,class_=&quot;common-lazy-img&quot;).find(&quot;img&quot;)[&#x27;src&#x27;] if len(url) &lt; 2: continue reg = re.search(r&#x27;@(.*)&#x27;,url).group() url = url.replace(&#x27;//&#x27;,&#x27;https://&#x27;).replace(reg,&#x27;&#x27;) urllib.request.urlretrieve(url,&quot;&#123;0&#125;.jpg&quot;.format(ani.find(&quot;a&quot;,class_=&quot;bangumi-title&quot;).get_text().replace(&#x27;/&#x27;,&#x27;-&#x27;))) #with open(&quot;testpic.png&quot;,&quot;wb&quot;) as pic: #pic.write(response.content) driver.quit()&#x27;&#x27;&#x27;except: print(&quot;报错退出&quot;)finally: driver.quit()&#x27;&#x27;&#x27;#for anime in AnimeList: #print(anime.find(&quot;a&quot;,class_=&quot;bangumi-title&quot;).get_text())&#x27;&#x27;&#x27;taskkill /im chromedriver.exe /F taskkill /im chrome.exe /F&#x27;&#x27;&#x27; chrome Options chromeOptions 是一个配置 chrome 启动是属性的类。通过这个类，我们可以为chrome配置如下参数： 设置 chrome 二进制文件位置 (binary_location) 添加启动参数 (add_argument) 添加扩展应用 (add_extension, add_encoded_extension) 添加实验性质的设置参数 (add_experimental_option) 设置调试器地址 (debugger_address) 1234567891011121314# .\\Lib\\site-packages\\selenium\\webdriver\\chrome\\options.pyclass Options(object): def __init__(self): # 设置 chrome 二进制文件位置 self._binary_location = &#x27;&#x27; # 添加启动参数 self._arguments = [] # 添加扩展应用 self._extension_files = [] self._extensions = [] # 添加实验性质的设置参数 self._experimental_options = &#123;&#125; # 设置调试器地址 self._debugger_address = None 常用配置 1234567891011121314151617181920212223242526from selenium import webdriveroptions = webdriver.ChromeOptions()# 设置默认编码为 utf-8options.add_argument(&#x27;lang=zh_CN.UTF-8&#x27;)# 禁止图片的加载prefs = &#123;&quot;profile.managed_default_content_settings.images&quot;: 2&#125;options.add_experimental_option(&quot;prefs&quot;, prefs)options.add_argument(&#x27;--proxy-server=http://ip:port&#x27;) proxyauth_plugin_path = create_proxyauth_extension( proxy_host=&#x27;host&#x27;, proxy_port=&#x27;port&#x27;, proxy_username=&quot;username&quot;, proxy_password=&quot;password&quot; )options.add_extension(proxyauth_plugin_path)options.add_argument(&#x27;window-size=1920x3000&#x27;) # 指定浏览器分辨率options.add_argument(&#x27;--disable-gpu&#x27;) # 加上这个属性来规避bugoptions.add_argument(&#x27;--disable-infobars&#x27;) # 禁用浏览器正在被自动化程序控制的提示options.add_argument(&#x27;--hide-scrollbars&#x27;) # 隐藏滚动条, 应对一些特殊页面options.add_argument(&#x27;blink-settings=imagesEnabled=false&#x27;) # 不加载图片, 提升速度options.add_argument(&#x27;--headless&#x27;) # 浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败options.binary_location = r&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; # 手动指定使用的浏览器位置driver = webdriver.Chrome(chrome_options = options)","categories":[{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/categories/Python/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://silencejql.github.io/tags/Script/"},{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/tags/Python/"}]},{"title":"CSharp调用SQL存储过程","slug":"C-调用SQL存储过程","date":"2019-12-17T04:33:09.000Z","updated":"2025-03-24T11:31:53.603Z","comments":true,"path":"C-调用SQL存储过程.html","link":"","permalink":"https://silencejql.github.io/C-%E8%B0%83%E7%94%A8SQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html","excerpt":"C# 执行SQLServer数据库中的存储过程，新增数据","text":"C# 执行SQLServer数据库中的存储过程，新增数据 123456789存储过程名：SP_Check_Equipotential 参数： @Part2GNDInfo varchar(3000),-- @Part2GND decimal(3,2),-- @Resultflag int output,--1保存成功 0保存失败 @ResultMessage varchar(4000)output--返回success 或 错误信息 返回值： @Resultflag int output,--1保存成功 0保存失败 @ResultMessage varchar(4000)output--返回success 或 错误信息 1234567891011121314151617181920212223SqlConnection DbConnection = new SqlConnection(m_MESConnString);SqlCommand command = new SqlCommand(&quot;SP_Check_Equipotential&quot;, DbConnection);DbConnection.Open();InitCommand(ref command);command.Parameters[&quot;@Part2GNDInfo&quot;].Value = Part2GNDInfo;command.Parameters[&quot;@Part2GND&quot;].Value = Convert.ToDecimal(mo2o(dr[&quot;步骤一最大值&quot;],true));command.ExecuteNonQuery();int result = command.Parameters[&quot;@Resultflag&quot;].Value.zInt32();string ResultMessage = command.Parameters[&quot;@ResultMessage&quot;].Value.ToString();private static void InitCommand(ref SqlCommand command)&#123; command.CommandType = CommandType.StoredProcedure; command.Parameters.Add(&quot;@Part2GNDInfo&quot;, SqlDbType.VarChar, 3000); SqlParameter Part2GND = new SqlParameter(&quot;@Part2GND&quot;, SqlDbType.Decimal); Part2GND.Precision = 3; Part2GND.Scale = 2; command.Parameters.Add(Part2GND); command.Parameters.Add(&quot;@Resultflag&quot;, SqlDbType.Int, 1); command.Parameters[&quot;@Resultflag&quot;].Direction = ParameterDirection.Output; command.Parameters.Add(&quot;@ResultMessage&quot;, SqlDbType.VarChar, 4000); command.Parameters[&quot;@ResultMessage&quot;].Direction = ParameterDirection.Output;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"存储过程","slug":"存储过程","permalink":"https://silencejql.github.io/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"git command","slug":"git-command","date":"2019-11-20T10:10:47.000Z","updated":"2025-03-24T11:31:35.604Z","comments":true,"path":"git-command.html","link":"","permalink":"https://silencejql.github.io/git-command.html","excerpt":"","text":"Bash Bash 常用命令 command 说明 cd 切换目录 pwd 查看当前目录 ls(ll) 查看当前目录文件 touch file.* 新建文件 rm file.* 删除文件 mkdir fold 新建文件夹 rm -r fold 删除文件夹 mv file destfold file 移动文件 clear 清屏 history 查看历史命令 git 设置用户名与邮箱 git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; command 说明 git init 在指定路径下执行，创建本地仓库 git config -l 查看git环境详细配置 git config --system --list 查看系统config git config --global --list 查看当前用户（global）配置 git config --local --list 查看当前仓库配置信息 git add 提交文件到暂存区，多个文件空格分开 git commit 提交到仓库分支 git commit -m “说明” 添加本次提交的说明便于查看更改记录 git log 历史版本信息 Git中版本用HEAD做标识，当前版本为HEAD，上一个版本是HEAD^ git reset --hard HEAD^ 退回到上个版本 git reset --hard commit_id HEAD 可用commit id前几位 git reflog 查看之前所有版本信息 git status 查看状态 git diff HEAD – file 查看工作区与版本库中的区别 git checkout – file 将工作区恢复到暂存区或版本库中的内容 git reset HEAD file 将暂存区恢复到版本库的内容 git rm file 删除文件 git remote add origin git@github.com:yourgithubname/Repositoryname.git 关联远程库 git push -u origin master 将本地仓库推送到远程仓库master分支并关联本地master分支 git push origin master 推送到远程master分支 git clone git@github.com:githubname/Repositoryname.git clone到本地 git branch bra 创建bra分支 git checkout bra 切换到bra分支 git checkout -b bra 等效于上面两条指令 git branch 查看分支，当前分支用*标识，切换分支后提交到当前分支 git checkout master 切换到master分支 git merge 合并指定分支到当前分支 git branch -d bra 删除bra分支 git switch -c bra 创建并切换分支 git switch master 切换到master分支","categories":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"}]},{"title":"IDMDownload","slug":"IDMDownload","date":"2019-11-14T04:57:46.000Z","updated":"2023-04-18T02:46:50.290Z","comments":true,"path":"IDMDownload.html","link":"","permalink":"https://silencejql.github.io/IDMDownload.html","excerpt":"Google Chrome 利用IDM下载器下载资源，可下载百度网盘资源","text":"Google Chrome 利用IDM下载器下载资源，可下载百度网盘资源 安装Google Chrome 安装浏览器插件Tampermonkey 安装百度网盘直接下载助手脚本 安装IDM integration Module","categories":[],"tags":[]},{"title":"IBMMQ错误代码","slug":"IBMMQ错误代码","date":"2019-11-07T04:47:13.000Z","updated":"2025-03-25T03:22:11.757Z","comments":true,"path":"IBMMQ错误代码.html","link":"","permalink":"https://silencejql.github.io/IBMMQ%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81.html","excerpt":"IBM官方说明：https://www.ibm.com/support/knowledgecenter/SSFKSJ_9.0.0/com.ibm.mq.tro.doc/q040710_.htm","text":"IBM官方说明：https://www.ibm.com/support/knowledgecenter/SSFKSJ_9.0.0/com.ibm.mq.tro.doc/q040710_.htm ErrorCode Description 0 (0000) (RC0) MQRC_NONE 900 (0384) (RC900) MQRC_APPL_FIRST 999 (03E7) (RC999) MQRC_APPL_LAST 2001 (07D1) (RC2001) MQRC_ALIAS_BASE_Q_TYPE_ERROR 2002 (07D2) (RC2002) MQRC_ALREADY_CONNECTED 2003 (07D3) (RC2003) MQRC_BACKED_OUT 2004 (07D4) (RC2004) MQRC_BUFFER_ERROR 2005 (07D5) (RC2005) MQRC_BUFFER_LENGTH_ERROR 2006 (07D6) (RC2006) MQRC_CHAR_ATTR_LENGTH_ERROR 2007 (07D7) (RC2007) MQRC_CHAR_ATTRS_ERROR 2008 (07D8) (RC2008) MQRC_CHAR_ATTRS_TOO_SHORT 2009 (07D9) (RC2009) MQRC_CONNECTION_BROKEN 2010 (07DA) (RC2010) MQRC_DATA_LENGTH_ERROR 2011 (07DB) (RC2011) MQRC_DYNAMIC_Q_NAME_ERROR 2012 (07DC) (RC2012) MQRC_ENVIRONMENT_ERROR 2013 (07DD) (RC2013) MQRC_EXPIRY_ERROR 2014 (07DE) (RC2014) MQRC_FEEDBACK_ERROR 2016 (07E0) (RC2016) MQRC_GET_INHIBITED 2017 (07E1) (RC2017) MQRC_HANDLE_NOT_AVAILABLE 2018 (07E2) (RC2018) MQRC_HCONN_ERROR 2019 (07E3) (RC2019) MQRC_HOBJ_ERROR 2020 (07E4) (RC2020) MQRC_INHIBIT_VALUE_ERROR 2021 (07E5) (RC2021) MQRC_INT_ATTR_COUNT_ERROR 2022 (07E6) (RC2022) MQRC_INT_ATTR_COUNT_TOO_SMALL 2023 (07E7) (RC2023) MQRC_INT_ATTRS_ARRAY_ERROR 2024 (07E8) (RC2024) MQRC_SYNCPOINT_LIMIT_REACHED 2025 (07E9) (RC2025) MQRC_MAX_CONNS_LIMIT_REACHED 2026 (07EA) (RC2026) MQRC_MD_ERROR 2027 (07EB) (RC2027) MQRC_MISSING_REPLY_TO_Q 2029 (07ED) (RC2029) MQRC_MSG_TYPE_ERROR 2030 (07EE) (RC2030) MQRC_MSG_TOO_BIG_FOR_Q 2031 (07EF) (RC2031) MQRC_MSG_TOO_BIG_FOR_Q_MGR 2033 (07F1) (RC2033) MQRC_NO_MSG_AVAILABLE 2034 (07F2) (RC2034) MQRC_NO_MSG_UNDER_CURSOR 2035 (07F3) (RC2035) MQRC_NOT_AUTHORIZED 2036 (07F4) (RC2036) MQRC_NOT_OPEN_FOR_BROWSE 2037 (07F5) (RC2037) MQRC_NOT_OPEN_FOR_INPUT 2038 (07F6) (RC2038) MQRC_NOT_OPEN_FOR_INQUIRE 2039 (07F7) (RC2039) MQRC_NOT_OPEN_FOR_OUTPUT 2040 (07F8) (RC2040) MQRC_NOT_OPEN_FOR_SET 2041 (07F9) (RC2041) MQRC_OBJECT_CHANGED 2042 (07FA) (RC2042) MQRC_OBJECT_IN_USE 2043 (07FB) (RC2043) MQRC_OBJECT_TYPE_ERROR 2044 (07FC) (RC2044) MQRC_OD_ERROR 2045 (07FD) (RC2045) MQRC_OPTION_NOT_VALID_FOR_TYPE 2046 (07FE) (RC2046) MQRC_OPTIONS_ERROR 2047 (07FF) (RC2047) MQRC_PERSISTENCE_ERROR 2048 (0800) (RC2048) MQRC_PERSISTENT_NOT_ALLOWED 2049 (0801) (RC2049) MQRC_PRIORITY_EXCEEDS_MAXIMUM 2050 (0802) (RC2050) MQRC_PRIORITY_ERROR 2051 (0803) (RC2051) MQRC_PUT_INHIBITED 2052 (0804) (RC2052) MQRC_Q_DELETED 2053 (0805) (RC2053) MQRC_Q_FULL 2055 (0807) (RC2055) MQRC_Q_NOT_EMPTY 2056 (0808) (RC2056) MQRC_Q_SPACE_NOT_AVAILABLE 2057 (0809) (RC2057) MQRC_Q_TYPE_ERROR 2058 (080A) (RC2058) MQRC_Q_MGR_NAME_ERROR 2059 (080B) (RC2059) MQRC_Q_MGR_NOT_AVAILABLE 2061 (080D) (RC2061) MQRC_REPORT_OPTIONS_ERROR [z/OS]2062 (080E) (RC2062) MQRC_SECOND_MARK_NOT_ALLOWED 2063 (080F) (RC2063) MQRC_SECURITY_ERROR 2065 (0811) (RC2065) MQRC_SELECTOR_COUNT_ERROR 2066 (0812) (RC2066) MQRC_SELECTOR_LIMIT_EXCEEDED 2067 (0813) (RC2067) MQRC_SELECTOR_ERROR 2068 (0814) (RC2068) MQRC_SELECTOR_NOT_FOR_TYPE [z/OS][Windows]2069 (0815) (RC2069) MQRC_SIGNAL_OUTSTANDING [z/OS][Windows]2070 (0816) (RC2070) MQRC_SIGNAL_REQUEST_ACCEPTED 2071 (0817) (RC2071) MQRC_STORAGE_NOT_AVAILABLE 2072 (0818) (RC2072) MQRC_SYNCPOINT_NOT_AVAILABLE 2075 (081B) (RC2075) MQRC_TRIGGER_CONTROL_ERROR 2076 (081C) (RC2076) MQRC_TRIGGER_DEPTH_ERROR 2077 (081D) (RC2077) MQRC_TRIGGER_MSG_PRIORITY_ERR 2078 (081E) (RC2078) MQRC_TRIGGER_TYPE_ERROR 2079 (081F) (RC2079) MQRC_TRUNCATED_MSG_ACCEPTED 2080 (0820) (RC2080) MQRC_TRUNCATED_MSG_FAILED 2082 (0822) (RC2082) MQRC_UNKNOWN_ALIAS_BASE_Q 2085 (0825) (RC2085) MQRC_UNKNOWN_OBJECT_NAME 2086 (0826) (RC2086) MQRC_UNKNOWN_OBJECT_Q_MGR 2087 (0827) (RC2087) MQRC_UNKNOWN_REMOTE_Q_MGR 2090 (082A) (RC2090) MQRC_WAIT_INTERVAL_ERROR 2091 (082B) (RC2091) MQRC_XMIT_Q_TYPE_ERROR 2092 (082C) (RC2092) MQRC_XMIT_Q_USAGE_ERROR 2093 (082D) (RC2093) MQRC_NOT_OPEN_FOR_PASS_ALL 2094 (082E) (RC2094) MQRC_NOT_OPEN_FOR_PASS_IDENT 2095 (082F) (RC2095) MQRC_NOT_OPEN_FOR_SET_ALL 2096 (0830) (RC2096) MQRC_NOT_OPEN_FOR_SET_IDENT 2097 (0831) (RC2097) MQRC_CONTEXT_HANDLE_ERROR 2098 (0832) (RC2098) MQRC_CONTEXT_NOT_AVAILABLE [z/OS][Windows]2099 (0833) (RC2099) MQRC_SIGNAL1_ERROR 2100 (0834) (RC2100) MQRC_OBJECT_ALREADY_EXISTS 2101 (0835) (RC2101) MQRC_OBJECT_DAMAGED 2102 (0836) (RC2102) MQRC_RESOURCE_PROBLEM [UNIX, Linux, Windows, IBM i]2103 (0837) (RC2103) MQRC_ANOTHER_Q_MGR_CONNECTED 2104 (0838) (RC2104) MQRC_UNKNOWN_REPORT_OPTION [z/OS]2105 (0839) (RC2105) MQRC_STORAGE_CLASS_ERROR [z/OS]2106 (083A) (RC2106) MQRC_COD_NOT_VALID_FOR_XCF_Q 2107 (083B) (RC2107) MQRC_XWAIT_CANCELED [z/OS]2108 (083C) (RC2108) MQRC_XWAIT_ERROR 2109 (083D) (RC2109) MQRC_SUPPRESSED_BY_EXIT 2110 (083E) (RC2110) MQRC_FORMAT_ERROR 2111 (083F) (RC2111) MQRC_SOURCE_CCSID_ERROR 2112 (0840) (RC2112) MQRC_SOURCE_INTEGER_ENC_ERROR 2113 (0841) (RC2113) MQRC_SOURCE_DECIMAL_ENC_ERROR 2114 (0842) (RC2114) MQRC_SOURCE_FLOAT_ENC_ERROR 2115 (0843) (RC2115) MQRC_TARGET_CCSID_ERROR 2116 (0844) (RC2116) MQRC_TARGET_INTEGER_ENC_ERROR 2117 (0845) (RC2117) MQRC_TARGET_DECIMAL_ENC_ERROR 2118 (0846) (RC2118) MQRC_TARGET_FLOAT_ENC_ERROR 2119 (0847) (RC2119) MQRC_NOT_CONVERTED 2120 (0848) (RC2120) MQRC_CONVERTED_MSG_TOO_BIG [IBM i][UNIX][Windows]2121 (0849) (RC2121) MQRC_NO_EXTERNAL_PARTICIPANTS [IBM i][UNIX][Windows]2122 (084A) (RC2122) MQRC_PARTICIPANT_NOT_AVAILABLE [UNIX][Windows]2123 (084B) (RC2123) MQRC_OUTCOME_MIXED [UNIX][Windows][z/OS]2124 (084C) (RC2124) MQRC_OUTCOME_PENDING 2125 (084D) (RC2125) MQRC_BRIDGE_STARTED 2126 (084E) (RC2126) MQRC_BRIDGE_STOPPED [z/OS]2127 (084F) (RC2127) MQRC_ADAPTER_STORAGE_SHORTAGE [IBM i][UNIX][Windows]2128 (0850) (RC2128) MQRC_UOW_IN_PROGRESS [z/OS]2129 (0851) (RC2129) MQRC_ADAPTER_CONN_LOAD_ERROR [z/OS]2130 (0852) (RC2130) MQRC_ADAPTER_SERV_LOAD_ERROR [z/OS]2131 (0853) (RC2131) MQRC_ADAPTER_DEFS_ERROR [z/OS]2132 (0854) (RC2132) MQRC_ADAPTER_DEFS_LOAD_ERROR [z/OS]2133 (0855) (RC2133) MQRC_ADAPTER_CONV_LOAD_ERROR [IBM i][UNIX][Windows]2134 (0856) (RC2134) MQRC_BO_ERROR [IBM i][UNIX][Windows]2135 (0857) (RC2135) MQRC_DH_ERROR [IBM i][UNIX][Windows]2136 (0858) (RC2136) MQRC_MULTIPLE_REASONS [IBM i][UNIX][Windows]2137 (0859) (RC2137) MQRC_OPEN_FAILED [z/OS]2138 (085A) (RC2138) MQRC_ADAPTER_DISC_LOAD_ERROR [IBM i][UNIX][Windows]2139 (085B) (RC2139) MQRC_CNO_ERROR [z/OS]2140 (085C) (RC2140) MQRC_CICS_WAIT_FAILED 2141 (085D) (RC2141) MQRC_DLH_ERROR 2142 (085E) (RC2142) MQRC_HEADER_ERROR 2143 (085F) (RC2143) MQRC_SOURCE_LENGTH_ERROR 2144 (0860) (RC2144) MQRC_TARGET_LENGTH_ERROR 2145 (0861) (RC2145) MQRC_SOURCE_BUFFER_ERROR 2146 (0862) (RC2146) MQRC_TARGET_BUFFER_ERROR [Windows][V9.0.0.6 Mar 2019]2147 (0863) (RC2147) MQRC_INCOMPLETE_TRANSACTION 2148 (0864) (RC2148) MQRC_IIH_ERROR 2149 (0865) (RC2149) MQRC_PCF_ERROR 2150 (0866) (RC2150) MQRC_DBCS_ERROR [IBM i][UNIX][Windows]2152 (0868) (RC2152) MQRC_OBJECT_NAME_ERROR [IBM i][UNIX][Windows]2153 (0869) (RC2153) MQRC_OBJECT_Q_MGR_NAME_ERROR [IBM i][UNIX][Windows]2154 (086A) (RC2154) MQRC_RECS_PRESENT_ERROR [IBM i][UNIX][Windows]2155 (086B) (RC2155) MQRC_OBJECT_RECORDS_ERROR [IBM i][UNIX][Windows]2156 (086C) (RC2156) MQRC_RESPONSE_RECORDS_ERROR [z/OS]2157 (086D) (RC2157) MQRC_ASID_MISMATCH [IBM i][UNIX][Windows]2158 (086E) (RC2158) MQRC_PMO_RECORD_FLAGS_ERROR [IBM i][UNIX][Windows]2159 (086F) (RC2159) MQRC_PUT_MSG_RECORDS_ERROR [z/OS]2160 (0870) (RC2160) MQRC_CONN_ID_IN_USE 2161 (0871) (RC2161) MQRC_Q_MGR_QUIESCING 2162 (0872) (RC2162) MQRC_Q_MGR_STOPPING [z/OS]2163 (0873) (RC2163) MQRC_DUPLICATE_RECOV_COORD 2173 (087D) (RC2173) MQRC_PMO_ERROR 2182 (0886) (RC2182) MQRC_API_EXIT_NOT_FOUND 2183 (0887) (RC2183) MQRC_API_EXIT_LOAD_ERROR 2184 (0888) (RC2184) MQRC_REMOTE_Q_NAME_ERROR 2185 (0889) (RC2185) MQRC_INCONSISTENT_PERSISTENCE 2186 (088A) (RC2186) MQRC_GMO_ERROR [z/OS]2187 (088B) (RC2187) MQRC_CICS_BRIDGE_RESTRICTION 2188 (088C) (RC2188) MQRC_STOPPED_BY_CLUSTER_EXIT 2189 (088D) (RC2189) MQRC_CLUSTER_RESOLUTION_ERROR 2190 (088E) (RC2190) MQRC_CONVERTED_STRING_TOO_BIG [IBM i][UNIX][Windows]2191 (088F) (RC2191) MQRC_TMC_ERROR 2192 (0890) (RC2192) MQRC_PAGESET_FULL [z/OS]2192 (0890) (RC2192) MQRC_STORAGE_MEDIUM_FULL [z/OS]2193 (0891) (RC2193) MQRC_PAGESET_ERROR 2194 (0892) (RC2194) MQRC_NAME_NOT_VALID_FOR_TYPE 2195 (0893) (RC2195) MQRC_UNEXPECTED_ERROR 2196 (0894) (RC2196) MQRC_UNKNOWN_XMIT_Q 2197 (0895) (RC2197) MQRC_UNKNOWN_DEF_XMIT_Q 2198 (0896) (RC2198) MQRC_DEF_XMIT_Q_TYPE_ERROR 2199 (0897) (RC2199) MQRC_DEF_XMIT_Q_USAGE_ERROR [z/OS]2201 (0899) (RC2201) MQRC_NAME_IN_USE 2202 (089A) (RC2202) MQRC_CONNECTION_QUIESCING 2203 (089B) (RC2203) MQRC_CONNECTION_STOPPING [z/OS]2204 (089C) (RC2204) MQRC_ADAPTER_NOT_AVAILABLE 2206 (089E) (RC2206) MQRC_MSG_ID_ERROR 2207 (089F) (RC2207) MQRC_CORREL_ID_ERROR 2208 (08A0) (RC2208) MQRC_FILE_SYSTEM_ERROR 2209 (08A1) (RC2209) MQRC_NO_MSG_LOCKED 2210 (08A2) (RC2210) MQRC_SOAP_DOTNET_ERROR 2211 (08A3) (RC2211) MQRC_SOAP_AXIS_ERROR 2212 (08A4) (RC2212) MQRC_SOAP_URL_ERROR [z/OS]2217 (08A9) (RC2217) MQRC_CONNECTION_NOT_AUTHORIZED 2218 (08AA) (RC2218) MQRC_MSG_TOO_BIG_FOR_CHANNEL 2219 (08AB) (RC2219) MQRC_CALL_IN_PROGRESS 2220 (08AC) (RC2220) MQRC_RMH_ERROR 2222 (08AE) (RC2222) MQRC_Q_MGR_ACTIVE 2223 (08AF) (RC2223) MQRC_Q_MGR_NOT_ACTIVE 2224 (08B0) (RC2224) MQRC_Q_DEPTH_HIGH 2225 (08B1) (RC2225) MQRC_Q_DEPTH_LOW 2226 (08B2) (RC2226) MQRC_Q_SERVICE_INTERVAL_HIGH 2227 (08B3) (RC2227) MQRC_Q_SERVICE_INTERVAL_OK 2228 (08B4) (RC2228) MQRC_RFH_HEADER_FIELD_ERROR 2229 (08B5) (RC2229) MQRC_RAS_PROPERTY_ERROR 2232 (08B8) (RC2232) MQRC_UNIT_OF_WORK_NOT_STARTED [IBM i][UNIX][Windows]2233 (08B9) (RC2233) MQRC_CHANNEL_AUTO_DEF_OK [IBM i][UNIX][Windows]2234 (08BA) (RC2234) MQRC_CHANNEL_AUTO_DEF_ERROR [IBM i][UNIX][Windows]2235 (08BB) (RC2235) MQRC_CFH_ERROR [IBM i][UNIX][Windows]2236 (08BC) (RC2236) MQRC_CFIL_ERROR [IBM i][UNIX][Windows]2237 (08BD) (RC2237) MQRC_CFIN_ERROR [IBM i][UNIX][Windows]2238 (08BE) (RC2238) MQRC_CFSL_ERROR [IBM i][UNIX][Windows]2239 (08BF) (RC2239) MQRC_CFST_ERROR 2241 (08C1) (RC2241) MQRC_INCOMPLETE_GROUP 2242 (08C2) (RC2242) MQRC_INCOMPLETE_MSG [IBM i][UNIX][Windows]2243 (08C3) (RC2243) MQRC_INCONSISTENT_CCSIDS [IBM i][UNIX][Windows]2244 (08C4) (RC2244) MQRC_INCONSISTENT_ENCODINGS 2245 (08C5) (RC2245) MQRC_INCONSISTENT_UOW [IBM i][UNIX][Windows]2246 (08C6) (RC2246) MQRC_INVALID_MSG_UNDER_CURSOR 2247 (08C7) (RC2247) MQRC_MATCH_OPTIONS_ERROR 2248 (08C8) (RC2248) MQRC_MDE_ERROR 2249 (08C9) (RC2249) MQRC_MSG_FLAGS_ERROR 2250 (08CA) (RC2250) MQRC_MSG_SEQ_NUMBER_ERROR 2251 (08CB) (RC2251) MQRC_OFFSET_ERROR 2252 (08CC) (RC2252) MQRC_ORIGINAL_LENGTH_ERROR [IBM i][UNIX][Windows]2253 (08CD) (RC2253) MQRC_SEGMENT_LENGTH_ZERO [IBM i][UNIX][Windows]2255 (08CF) (RC2255) MQRC_UOW_NOT_AVAILABLE 2256 (08D0) (RC2256) MQRC_WRONG_GMO_VERSION 2257 (08D1) (RC2257) MQRC_WRONG_MD_VERSION [IBM i][UNIX][Windows]2258 (08D2) (RC2258) MQRC_GROUP_ID_ERROR [IBM i][UNIX][Windows]2259 (08D3) (RC2259) MQRC_INCONSISTENT_BROWSE 2260 (08D4) (RC2260) MQRC_XQH_ERROR [IBM i][UNIX][Windows]2261 (08D5) (RC2261) MQRC_SRC_ENV_ERROR [IBM i][UNIX][Windows]2262 (08D6) (RC2262) MQRC_SRC_NAME_ERROR [IBM i][UNIX][Linux]2263 (08D7) (RC2263) MQRC_DEST_ENV_ERROR [IBM i][UNIX][Windows]2264 (08D8) (RC2264) MQRC_DEST_NAME_ERROR 2265 (08D9) (RC2265) MQRC_TM_ERROR 2266 (08DA) (RC2266) MQRC_CLUSTER_EXIT_ERROR 2267 (08DB) (RC2267) MQRC_CLUSTER_EXIT_LOAD_ERROR 2268 (08DC) (RC2268) MQRC_CLUSTER_PUT_INHIBITED 2269 (08DD) (RC2269) MQRC_CLUSTER_RESOURCE_ERROR 2270 (08DE) (RC2270) MQRC_NO_DESTINATIONS_AVAILABLE [z/OS]2271 (08DF) (RC2271) MQRC_CONN_TAG_IN_USE 2272 (08E0) (RC2272) MQRC_PARTIALLY_CONVERTED 2273 (08E1) (RC2273) MQRC_CONNECTION_ERROR 2274 (08E2) (RC2274) MQRC_OPTION_ENVIRONMENT_ERROR [IBM i][UNIX][Windows]2277 (08E5) (RC2277) MQRC_CD_ERROR [IBM i][UNIX][Windows]2278 (08E6) (RC2278) MQRC_CLIENT_CONN_ERROR 2279 (08E7) (RC2279) MQRC_CHANNEL_STOPPED_BY_USER [UNIX, Linux, Windows, IBM i]2280 (08E8) (RC2280) MQRC_HCONFIG_ERROR [UNIX, Linux, Windows, IBM i]2281 (08E9) (RC2281) MQRC_FUNCTION_ERROR 2282 (08EA) (RC2282) MQRC_CHANNEL_STARTED 2283 (08EB) (RC2283) MQRC_CHANNEL_STOPPED 2284 (08EC) (RC2284) MQRC_CHANNEL_CONV_ERROR [UNIX, Linux, Windows, IBM i]2285 (08ED) (RC2285) MQRC_SERVICE_NOT_AVAILABLE [UNIX, Linux, Windows, IBM i]2286 (08EE) (RC2286) MQRC_INITIALIZATION_FAILED [UNIX, Linux, Windows, IBM i]2287 (08EF) (RC2287) MQRC_TERMINATION_FAILED [UNIX, Linux, Windows, IBM i]2288 (08F0) (RC2288) MQRC_UNKNOWN_Q_NAME [UNIX, Linux, Windows, IBM i]2289 (08F1) (RC2289) MQRC_SERVICE_ERROR [UNIX, Linux, Windows, IBM i]2290 (08F2) (RC2290) MQRC_Q_ALREADY_EXISTS [UNIX, Linux, Windows, IBM i]2291 (08F3) (RC2291) MQRC_USER_ID_NOT_AVAILABLE [UNIX, Linux, Windows, IBM i]2292 (08F4) (RC2292) MQRC_UNKNOWN_ENTITY [UNIX, Linux, Windows, IBM i]2294 (08F6) (RC2294) MQRC_UNKNOWN_REF_OBJECT 2295 (08F7) (RC2295) MQRC_CHANNEL_ACTIVATED 2296 (08F8) (RC2296) MQRC_CHANNEL_NOT_ACTIVATED 2297 (08F9) (RC2297) MQRC_UOW_CANCELED 2298 (08FA) (RC2298) MQRC_FUNCTION_NOT_SUPPORTED 2299 (08FB) (RC2299) MQRC_SELECTOR_TYPE_ERROR 2300 (08FC) (RC2300) MQRC_COMMAND_TYPE_ERROR 2301 (08FD) (RC2301) MQRC_MULTIPLE_INSTANCE_ERROR 2302 (08FE) (RC2302) MQRC_SYSTEM_ITEM_NOT_ALTERABLE 2303 (08FF) (RC2303) MQRC_BAG_CONVERSION_ERROR 2304 (0900) (RC2304) MQRC_SELECTOR_OUT_OF_RANGE 2305 (0901) (RC2305) MQRC_SELECTOR_NOT_UNIQUE 2306 (0902) (RC2306) MQRC_INDEX_NOT_PRESENT 2307 (0903) (RC2307) MQRC_STRING_ERROR 2308 (0904) (RC2308) MQRC_ENCODING_NOT_SUPPORTED 2309 (0905) (RC2309) MQRC_SELECTOR_NOT_PRESENT 2310 (0906) (RC2310) MQRC_OUT_SELECTOR_ERROR 2311 (0907) (RC2311) MQRC_STRING_TRUNCATED 2312 (0908) (RC2312) MQRC_SELECTOR_WRONG_TYPE 2313 (0909) (RC2313) MQRC_INCONSISTENT_ITEM_TYPE 2314 (090A) (RC2314) MQRC_INDEX_ERROR 2315 (090B) (RC2315) MQRC_SYSTEM_BAG_NOT_ALTERABLE 2316 (090C) (RC2316) MQRC_ITEM_COUNT_ERROR 2317 (090D) (RC2317) MQRC_FORMAT_NOT_SUPPORTED 2318 (090E) (RC2318) MQRC_SELECTOR_NOT_SUPPORTED 2319 (090F) (RC2319) MQRC_ITEM_VALUE_ERROR 2320 (0910) (RC2320) MQRC_HBAG_ERROR 2321 (0911) (RC2321) MQRC_PARAMETER_MISSING 2322 (0912) (RC2322) MQRC_CMD_SERVER_NOT_AVAILABLE 2323 (0913) (RC2323) MQRC_STRING_LENGTH_ERROR 2324 (0914) (RC2324) MQRC_INQUIRY_COMMAND_ERROR 2325 (0915) (RC2325) MQRC_NESTED_BAG_NOT_SUPPORTED 2326 (0916) (RC2326) MQRC_BAG_WRONG_TYPE 2327 (0917) (RC2327) MQRC_ITEM_TYPE_ERROR 2328 (0918) (RC2328) MQRC_SYSTEM_BAG_NOT_DELETABLE 2329 (0919) (RC2329) MQRC_SYSTEM_ITEM_NOT_DELETABLE 2330 (091A) (RC2330) MQRC_CODED_CHAR_SET_ID_ERROR 2331 (091B) (RC2331) MQRC_MSG_TOKEN_ERROR [z/OS]2332 (091C) (RC2332) MQRC_MISSING_WIH 2333 (091D) (RC2333) MQRC_WIH_ERROR 2334 (091E) (RC2334) MQRC_RFH_ERROR 2335 (091F) (RC2335) MQRC_RFH_STRING_ERROR 2336 (0920) (RC2336) MQRC_RFH_COMMAND_ERROR 2337 (0921) (RC2337) MQRC_RFH_PARM_ERROR 2338 (0922) (RC2338) MQRC_RFH_DUPLICATE_PARM 2339 (0923) (RC2339) MQRC_RFH_PARM_MISSING [z/OS]2340 (0924) (RC2340) MQRC_CHAR_CONVERSION_ERROR [z/OS]2341 (0925) (RC2341) MQRC_UCS2_CONVERSION_ERROR [z/OS]2342 (0926) (RC2342) MQRC_DB2_NOT_AVAILABLE [z/OS]2343 (0927) (RC2343) MQRC_OBJECT_NOT_UNIQUE [z/OS]2344 (0928) (RC2344) MQRC_CONN_TAG_NOT_RELEASED [z/OS]2345 (0929) (RC2345) MQRC_CF_NOT_AVAILABLE [z/OS]2346 (092A) (RC2346) MQRC_CF_STRUC_IN_USE [z/OS]2347 (092B) (RC2347) MQRC_CF_STRUC_LIST_HDR_IN_USE [z/OS]2348 (092C) (RC2348) MQRC_CF_STRUC_AUTH_FAILED [z/OS]2349 (092D) (RC2349) MQRC_CF_STRUC_ERROR [z/OS]2350 (092E) (RC2350) MQRC_CONN_TAG_NOT_USABLE [Windows][z/OS]2351 (092F) (RC2351) MQRC_GLOBAL_UOW_CONFLICT [Windows][z/OS]2352 (0930) (RC2352) MQRC_LOCAL_UOW_CONFLICT [Windows]2353 (0931) (RC2353) MQRC_HANDLE_IN_USE_FOR_UOW [HPNSS][Windows]2354 (0932) (RC2354) MQRC_UOW_ENLISTMENT_ERROR [HPNSS][Windows]2355 (0933) (RC2355) MQRC_UOW_MIX_NOT_SUPPORTED 2356 (0934) (RC2356) MQRC_WXP_ERROR 2357 (0935) (RC2357) MQRC_CURRENT_RECORD_ERROR 2358 (0936) (RC2358) MQRC_NEXT_OFFSET_ERROR 2359 (0937) (RC2359) MQRC_NO_RECORD_AVAILABLE [z/OS]2360 (0938) (RC2360) MQRC_OBJECT_LEVEL_INCOMPATIBLE 2361 (0939) (RC2361) MQRC_NEXT_RECORD_ERROR 2362 (093A) (RC2362) MQRC_BACKOUT_THRESHOLD_REACHED 2363 (093B) (RC2363) MQRC_MSG_NOT_MATCHED 2364 (093C) (RC2364) MQRC_JMS_FORMAT_ERROR [z/OS]2365 (093D) (RC2365) MQRC_SEGMENTS_NOT_SUPPORTED [z/OS]2366 (093E) (RC2366) MQRC_WRONG_CF_LEVEL 2367 (093F) (RC2367) MQRC_CONFIG_CREATE_OBJECT 2368 (0940) (RC2368) MQRC_CONFIG_CHANGE_OBJECT 2369 (0941) (RC2369) MQRC_CONFIG_DELETE_OBJECT 2370 (0942) (RC2370) MQRC_CONFIG_REFRESH_OBJECT 2371 (0943) (RC2371) MQRC_CHANNEL_SSL_ERROR [z/OS]2373 (0945) (RC2373) MQRC_CF_STRUC_FAILED [UNIX][Windows]2374 (0946) (RC2374) MQRC_API_EXIT_ERROR [UNIX][Windows]2375 (0947) (RC2375) MQRC_API_EXIT_INIT_ERROR [UNIX][Windows]2376 (0948) (RC2376) MQRC_API_EXIT_TERM_ERROR [UNIX][Windows]2377 (0949) (RC2377) MQRC_EXIT_REASON_ERROR [UNIX][Windows]2378 (094A) (RC2378) MQRC_RESERVED_VALUE_ERROR [UNIX, Linux, Windows, IBM i]2379 (094B) (RC2379) MQRC_NO_DATA_AVAILABLE [UNIX][Windows]2380 (094C) (RC2380) MQRC_SCO_ERROR [UNIX][Windows]2381 (094D) (RC2381) MQRC_KEY_REPOSITORY_ERROR [UNIX][Windows]2382 (094E) (RC2382) MQRC_CRYPTO_HARDWARE_ERROR [UNIX][Windows]2383 (094F) (RC2383) MQRC_AUTH_INFO_REC_COUNT_ERROR [UNIX][Windows]2384 (0950) (RC2384) MQRC_AUTH_INFO_REC_ERROR [UNIX][Windows]2385 (0951) (RC2385) MQRC_AIR_ERROR [UNIX][Windows]2386 (0952) (RC2386) MQRC_AUTH_INFO_TYPE_ERROR [UNIX][Windows]2387 (0953) (RC2387) MQRC_AUTH_INFO_CONN_NAME_ERROR [UNIX][Windows]2388 (0954) (RC2388) MQRC_LDAP_USER_NAME_ERROR [UNIX][Windows]2389 (0955) (RC2389) MQRC_LDAP_USER_NAME_LENGTH_ERR [UNIX][Windows]2390 (0956) (RC2390) MQRC_LDAP_PASSWORD_ERROR [UNIX][Windows]2391 (0957) (RC2391) MQRC_SSL_ALREADY_INITIALIZED [UNIX][Windows]2392 (0958) (RC2392) MQRC_SSL_CONFIG_ERROR [UNIX][Windows]2393 (0959) (RC2393) MQRC_SSL_INITIALIZATION_ERROR [z/OS]2394 (095A) (RC2394) MQRC_Q_INDEX_TYPE_ERROR [IBM i][UNIX][Windows]2395 (095B) (RC2395) MQRC_CFBS_ERROR 2396 (095C) (RC2396) MQRC_SSL_NOT_ALLOWED 2397 (095D) (RC2397) MQRC_JSSE_ERROR 2398 (095E) (RC2398) MQRC_SSL_PEER_NAME_MISMATCH 2399 (095F) (RC2399) MQRC_SSL_PEER_NAME_ERROR 2400 (0960) (RC2400) MQRC_UNSUPPORTED_CIPHER_SUITE 2401 (0961) (RC2401) MQRC_SSL_CERTIFICATE_REVOKED 2402 (0962) (RC2402) MQRC_SSL_CERT_STORE_ERROR 2406 (0966) (RC2406) MQRC_CLIENT_EXIT_LOAD_ERROR 2407 (0967) (RC2407) MQRC_CLIENT_EXIT_ERROR 2409 (0969) (RC2409) MQRC_SSL_KEY_RESET_ERROR 2411 (096B) (RC2411) MQRC_LOGGER_STATUS 2412 (096C) (RC2412) MQRC_COMMAND_MQSC 2413 (096D) (RC2413) MQRC_COMMAND_PCF 2414 (096E) (RC2414) MQRC_CFIF_ERROR 2415 (096F) (RC2415) MQRC_CFSF_ERROR 2416 (0970) (RC2416) MQRC_CFGR_ERROR 2417 (0971) (RC2417) MQRC_MSG_NOT_ALLOWED_IN_GROUP 2418 (0972) (RC2418) MQRC_FILTER_OPERATOR_ERROR 2419 (0973) (RC2419) MQRC_NESTED_SELECTOR_ERROR 2420 (0974) (RC2420) MQRC_EPH_ERROR 2421 (0975) (RC2421) MQRC_RFH_FORMAT_ERROR [IBM i][UNIX][Windows]2422 (0976) (RC2422) MQRC_CFBF_ERROR 2423 (0977) (RC2423) MQRC_CLIENT_CHANNEL_CONFLICT 2424 (0978) (RC2424) MQRC_SD_ERROR 2425 (0979) (RC2425) MQRC_TOPIC_STRING_ERROR 2426 (097A) (RC2426) MQRC_STS_ERROR 2428 (097C) (RC2428) MQRC_NO_SUBSCRIPTION 2429 (097D) (RC2429) MQRC_SUBSCRIPTION_IN_USE 2430 (097E) (RC2430) MQRC_STAT_TYPE_ERROR 2431 (097F) (RC2431) MQRC_SUB_USER_DATA_ERROR 2432 (0980) (RC2432) MQRC_SUB_ALREADY_EXISTS 2434 (0982) (RC2434) MQRC_IDENTITY_MISMATCH 2435 (0983) (RC2435) MQRC_ALTER_SUB_ERROR 2436 (0984) (RC2436) MQRC_DURABILITY_NOT_ALLOWED 2437 (0985) (RC2437) MQRC_NO_RETAINED_MSG 2438 (0986) (RC2438) MQRC_SRO_ERROR 2440 (0988) (RC2440) MQRC_SUB_NAME_ERROR 2441 (0989) (RC2441) MQRC_OBJECT_STRING_ERROR 2442 (098A) (RC2442) MQRC_PROPERTY_NAME_ERROR 2443 (098B) (RC2443) MQRC_SEGMENTATION_NOT_ALLOWED 2444 (098C) (RC2444) MQRC_CBD_ERROR 2445 (098D) (RC2445) MQRC_CTLO_ERROR 2446 (098E) (RC2446) MQRC_NO_CALLBACKS_ACTIVE 2448 (0990) (RC2448) MQRC_CALLBACK_NOT_REGISTERED 2449 (0991) (RC2449) MQRC_OPERATION_NOT_ALLOWED 2457 (0999) (RC2457) MQRC_OPTIONS_CHANGED 2458 (099A) (RC2458) MQRC_READ_AHEAD_MSGS 2459 (099B) (RC2459) MQRC_SELECTOR_SYNTAX_ERROR 2460 (099C) (RC2460) MQRC_HMSG_ERROR 2461 (099D) (RC2461) MQRC_CMHO_ERROR 2462 (099E) (RC2462) MQRC_DMHO_ERROR 2463 (099F) (RC2463) MQRC_SMPO_ERROR 2464 (09A0) (RC2464) MQRC_IMPO_ERROR 2465 (09A1) (RC2465) MQRC_PROPERTY_NAME_TOO_BIG 2466 (09A2) (RC2466) MQRC_PROP_VALUE_NOT_CONVERTED 2467 (09A3) (RC2467) MQRC_PROP_TYPE_NOT_SUPPORTED 2469 (09A5) (RC2469) MQRC_PROPERTY_VALUE_TOO_BIG 2470 (09A6) (RC2470) MQRC_PROP_CONV_NOT_SUPPORTED 2471 (09A7) (RC2471) MQRC_PROPERTY_NOT_AVAILABLE 2472 (09A8) (RC2472) MQRC_PROP_NUMBER_FORMAT_ERROR 2473 (09A9) (RC2473) MQRC_PROPERTY_TYPE_ERROR 2478 (09AE) (RC2478) MQRC_PROPERTIES_TOO_BIG 2479 (09AF) (RC2479) MQRC_PUT_NOT_RETAINED 2480 (09B0) (RC2480) MQRC_ALIAS_TARGTYPE_CHANGED 2481 (09B1) (RC2481) MQRC_DMPO_ERROR 2482 (09B2) (RC2482) MQRC_PD_ERROR 2483 (09B3) (RC2483) MQRC_CALLBACK_TYPE_ERROR 2484 (09B4) (RC2484) MQRC_CBD_OPTIONS_ERROR 2485 (09B5) (RC2485) MQRC_MAX_MSG_LENGTH_ERROR 2486 (09B6) (RC2486) MQRC_CALLBACK_ROUTINE_ERROR [z/OS]2487 (09B7) (RC2487) MQRC_CALLBACK_LINK_ERROR 2488 (09B8) (RC2488) MQRC_OPERATION_ERROR 2489 (09B9) (RC2489) MQRC_BMHO_ERROR 2490 (09BA) (RC2490) MQRC_UNSUPPORTED_PROPERTY 2492 (09BC) (RC2492) MQRC_PROP_NAME_NOT_CONVERTED 2494 (09BE) (RC2494) MQRC_GET_ENABLED 2495 (09BF) (RC2495) MQRC_MODULE_NOT_FOUND 2496 (09C0) (RC2496) MQRC_MODULE_INVALID 2497 (09C1) (RC2497) MQRC_MODULE_ENTRY_NOT_FOUND 2498 (09C2) (RC2498) MQRC_MIXED_CONTENT_NOT_ALLOWED 2499 (09C3) (RC2499) MQRC_MSG_HANDLE_IN_USE 2500 (09C4) (RC2500) MQRC_HCONN_ASYNC_ACTIVE 2501 (09C5) (RC2501) MQRC_MHBO_ERROR 2502 (09C6) (RC2502) MQRC_PUBLICATION_FAILURE 2503 (09C7) (RC2503) MQRC_SUB_INHIBITED 2504 (09C8) (RC2504) MQRC_SELECTOR_ALWAYS_FALSE 2507 (09CB) (RC2507) MQRC_XEPO_ERROR 2509 (09CD) (RC2509) MQRC_DURABILITY_NOT_ALTERABLE 2510 (09CE) (RC2510) MQRC_TOPIC_NOT_ALTERABLE 2512 (09D0) (RC2512) MQRC_SUBLEVEL_NOT_ALTERABLE 2513 (09D1) (RC2513) MQRC_PROPERTY_NAME_LENGTH_ERR 2514 (09D2) (RC2514) MQRC_DUPLICATE_GROUP_SUB 2515 (09D3) (RC2515) MQRC_GROUPING_NOT_ALTERABLE 2516 (09D4) (RC2516) MQRC_SELECTOR_INVALID_FOR_TYPE 2517 (09D5) (RC2517) MQRC_HOBJ_QUIESCED 2518 (09D6) (RC2518) MQRC_HOBJ_QUIESCED_NO_MSGS 2519 (09D7) (RC2519) MQRC_SELECTION_STRING_ERROR 2520 (09D8) (RC2520) MQRC_RES_OBJECT_STRING_ERROR 2521 (09D9) (RC2521) MQRC_CONNECTION_SUSPENDED 2522 (09DA) (RC2522) MQRC_INVALID_DESTINATION 2523 (09DB) (RC2523) MQRC_INVALID_SUBSCRIPTION 2524 (09DC) (RC2524) MQRC_SELECTOR_NOT_ALTERABLE 2525 (09DD) (RC2525) MQRC_RETAINED_MSG_Q_ERROR 2526 (09DE) (RC2526) MQRC_RETAINED_NOT_DELIVERED 2527 (09DF) (RC2527) MQRC_RFH_RESTRICTED_FORMAT_ERR 2528 (09E0) (RC2528) MQRC_CONNECTION_STOPPED 2529 (09E1) (RC2529) MQRC_ASYNC_UOW_CONFLICT 2530 (09E2) (RC2530) MQRC_ASYNC_XA_CONFLICT 2531 (09E3) (RC2531) MQRC_PUBSUB_INHIBITED 2532 (09E4) (RC2532) MQRC_MSG_HANDLE_COPY_FAILURE 2533 (09E5) (RC2533) MQRC_DEST_CLASS_NOT_ALTERABLE 2534 (09E6) (RC2534) MQRC_OPERATION_NOT_ALLOWED 2535 (09E7) MQRC_ACTION_ERROR 2537 (09E9) (RC2537) MQRC_CHANNEL_NOT_AVAILABLE 2538 (09EA) (RC2538) MQRC_HOST_NOT_AVAILABLE 2539 (09EB) (RC2539) MQRC_CHANNEL_CONFIG_ERROR 2540 (09EC) (RC2540) MQRC_UNKNOWN_CHANNEL_NAME 2541 (09ED) (RC2541) MQRC_LOOPING_PUBLICATION 2543 (09EF) (RC2543) MQRC_STANDBY_Q_MGR 2544 (09F0) (RC2544) MQRC_RECONNECTING 2545 (09F1) (RC2545) MQRC_RECONNECTED 2546 (09F2) (RC2546) MQRC_RECONNECT_QMID_MISMATCH 2547 (09F3) (RC2547) MQRC_RECONNECT_INCOMPATIBLE 2548 (09F4) (RC2548) MQRC_RECONNECT_FAILED 2549 (09F5) (RC2549) MQRC_CALL_INTERRUPTED 2550 (09F6) (RC2550) MQRC_NO_SUBS_MATCHED 2551 (09F7) (RC2551) MQRC_SELECTION_NOT_AVAILABLE 2552 (09F8) (RC2552) MQRC_CHANNEL_SSL_WARNING 2553 (09F9) (RC2553) MQRC_OCSP_URL_ERROR 2554 (09FA) (RC2554) MQRC_CONTENT_ERROR 2555 (09FB) (RC2555) MQRC_RECONNECT_Q_MGR_REQD 2556 (09FC) (RC2556) MQRC_RECONNECT_TIMED_OUT [UNIX, Linux, Windows, IBM i]2557 (09FD) (RC2557) MQRC_PUBLISH_EXIT_ERROR 2558 (09FE) (RC2558) MQRC_COMMINFO_ERROR 2560 (0A00) (RC2560) MQRC_MULTICAST_ONLY [z/OS]2561 (0A01) (RC2561) MQRC_DATA_SET_NOT_AVAILABLE 2562 (0A02) (RC2562) MQRC_GROUPING_NOT_ALLOWED 2563 (0A03) (RC2563) MQRC_GROUP_ADDRESS_ERROR 2564 (0A04) (RC2564) MQRC_MULTICAST_CONFIG_ERROR 2565 (0A05) (RC2565) MQRC_MULTICAST_INTERFACE_ERROR 2566 (0A06) (RC2566) MQRC_MULTICAST_SEND_ERROR 2567 (0A07) (RC2567) MQRC_MULTICAST_INTERNAL_ERROR 2568 (0A08) (RC2568) MQRC_CONNECTION_NOT_AVAILABLE 2569 (0A09) (RC2569) MQRC_SYNCPOINT_NOT_ALLOWED 2577 (0A11) (RC2577) MQRC_CHANNEL_BLOCKED 2578 (0A12) (RC2578) MQRC_CHANNEL_BLOCKED_WARNING 2583 (0A17) (RC2583) MQRC_INSTALLATION_MISMATCH 2587 (0A1B) (RC2587) MQRC_HMSG_NOT_AVAILABLE 2589 (0A1D) (RC2589) MQRC_INSTALLATION_MISSING 2590 (0A1E) (RC2590) MQRC_FASTPATH_NOT_AVAILABLE 2591 (0A1F) (RC2591) MQRC_CIPHER_SPEC_NOT_SUITE_B 2592 (0A20) (RC2592) MQRC_SUITE_B_ERROR 2593 (0A21)(RC2593) MQRC_CERT_VAL_POLICY_ERROR 2594 (0A22)(RC2594) MQRC_PASSWORD_PROTECTION_ERROR 2595 (0A23)(RC2595) MQRC_CSP_ERROR 2596 (0A24)(RC2596) MQRC_CERT_LABEL_NOT_ALLOWED 2598 (0A26)(RC2598) MQRC_ADMIN_TOPIC_STRING_ERROR 6100 (17D4) (RC6100) MQRC_REOPEN_EXCL_INPUT_ERROR 6101 (17D5) (RC6101) MQRC_REOPEN_INQUIRE_ERROR 6102 (17D6) (RC6102) MQRC_REOPEN_SAVED_CONTEXT_ERR 6103 (17D7) (RC6103) MQRC_REOPEN_TEMPORARY_Q_ERROR 6104 (17D8) (RC6104) MQRC_ATTRIBUTE_LOCKED 6105 (17D9) (RC6105) MQRC_CURSOR_NOT_VALID 6106 (17DA) (RC6106) MQRC_ENCODING_ERROR 6107 (17DB) (RC6107) MQRC_STRUC_ID_ERROR 6108 (17DC) (RC6108) MQRC_NULL_POINTER 6109 (17DD) (RC6109) MQRC_NO_CONNECTION_REFERENCE 6110 (17DE) (RC6110) MQRC_NO_BUFFER 6111 (17DF) (RC6111) MQRC_BINARY_DATA_LENGTH_ERROR 6112 (17E0) (RC6112) MQRC_BUFFER_NOT_AUTOMATIC 6113 (17E1) (RC6113) MQRC_INSUFFICIENT_BUFFER 6114 (17E2) (RC6114) MQRC_INSUFFICIENT_DATA 6115 (17E3) (RC6115) MQRC_DATA_TRUNCATED 6116 (17E4) (RC6116) MQRC_ZERO_LENGTH 6117 (17E5) (RC6117) MQRC_NEGATIVE_LENGTH 6118 (17E6) (RC6118) MQRC_NEGATIVE_OFFSET 6119 (17E7) (RC6119) MQRC_INCONSISTENT_FORMAT 6120 (17E8) (RC6120) MQRC_INCONSISTENT_OBJECT_STATE 6121 (17E9) (RC6121) MQRC_CONTEXT_OBJECT_NOT_VALID 6122 (17EA) (RC6122) MQRC_CONTEXT_OPEN_ERROR 6123 (17EB) (RC6123) MQRC_STRUC_LENGTH_ERROR 6124 (17EC) (RC6124) MQRC_NOT_CONNECTED 6125 (17ED) (RC6125) MQRC_NOT_OPEN 6126 (17EE) (RC6126) MQRC_DISTRIBUTION_LIST_EMPTY 6127 (17EF) (RC6127) MQRC_INCONSISTENT_OPEN_OPTIONS 6128 (17FO) (RC6128) MQRC_WRONG_VERSION 6129 (17F1) (RC6129) MQRC_REFERENCE_ERROR","categories":[{"name":"MQ","slug":"MQ","permalink":"https://silencejql.github.io/categories/MQ/"}],"tags":[{"name":"IBMMQ","slug":"IBMMQ","permalink":"https://silencejql.github.io/tags/IBMMQ/"}]},{"title":"现场工作代码路径说明","slug":"现场工作代码路径说明","date":"2019-11-03T02:16:22.000Z","updated":"2025-03-25T03:29:04.349Z","comments":true,"path":"现场工作代码路径说明.html","link":"","permalink":"https://silencejql.github.io/%E7%8E%B0%E5%9C%BA%E5%B7%A5%E4%BD%9C%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84%E8%AF%B4%E6%98%8E.html","excerpt":"程序版本更新后可能没有合入原有程序，本文作为各现场的程序在电脑中存放的路径进行说明","text":"程序版本更新后可能没有合入原有程序，本文作为各现场的程序在电脑中存放的路径进行说明 国六排放 MES联网 D:\\BaiduNetdiskDownload\\GX\\Platforms2\\PlatABS 包含上汽临港、上汽南京、上汽宁德、上汽郑州、上汽无锡大通、 长沙菲亚特、杭州福特(包含QLS，双怠速转速控制)、重庆福特、哈尔滨福特(继承杭州福特未测试) 上汽 上汽检测线 上汽DSA：D:\\工作\\software\\Platforms_Using\\Platforms2\\SocketOpraLib 其中包括上汽郑州FAS、360；上汽宁德现场程序。 五菱 五菱ABS：D:\\工作\\software\\Platforms_Using\\PlatABS\\RBABS_SGMW 20191028新增宝骏现场更改保持在线3E 00为3E 80备份，目前调试未成功，采用备份程序 程序包含所有五菱现场最新的ABS程序 东风 东风小康 东风小康MES：D:\\工作\\现场工作文件整理\\东风小康\\319015-201905\\Platforms2-正在使用\\SpeciallNeed 程序为东风小康现场最新MES程序，新增64字节车型识别 东风乘用车(武汉) D:\\工作\\现场工作文件整理\\武汉东风乘用车\\Platforms2-武汉东风乘用车 其中SpecialNeed中包含FAS工位AEB相关提示，CanCmdOpraLib包含FAS相关安全算法 ABS：D:\\BaiduNetdiskDownload\\GX\\Platforms2\\PlatABS\\RBABS_DF 合众 D:\\BaiduNetdiskDownload\\GX\\Platforms2\\PlatABS 201909新增EP30ESC 比亚迪 D:\\BaiduNetdiskDownload\\GX\\Platforms2\\Platforms2\\CanCmdOpraLib 201904增加联电供应商的转速控制 程序合并进行中 PlatABS 最新程序在D:\\BaiduNetdiskDownload\\GX\\Platforms2\\PlatABS中 20191120将五菱ABS更新至本工程代码中，待测试，其中包含齿讯学习 ABS 合众 东风乘用车 国六 现场 功能 上汽临港 MES 上汽名爵 MES 上汽宁德 MES 上汽郑州一期 MES 上汽无锡大通 MES、车型信息获取、ZTS匹配 福特杭州 MES、QLS、双怠速转速控制 福特重庆 MES、QLS、双怠速转速控制 福特哈尔滨 MES、QLS、双怠速转速控制 菲亚特长沙 MES 其他 北汽莱西FAS","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"国六排放指令说明","slug":"国六排放指令说明","date":"2019-10-25T10:14:02.000Z","updated":"2025-03-25T03:19:42.816Z","comments":true,"path":"国六排放指令说明.html","link":"","permalink":"https://silencejql.github.io/%E5%9B%BD%E5%85%AD%E6%8E%92%E6%94%BE%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E.html","excerpt":"&emsp; 国六排放测试过程中常用通讯指令说明 详细资料请参考ISO15031-5或J1979-DA","text":"&emsp; 国六排放测试过程中常用通讯指令说明 详细资料请参考ISO15031-5或J1979-DA ISO15031-5 15765-4 Service 01 请求当前动力系统诊断数据 01后最多可以读取6个PID(Parameter Identification) 请求：01 PID PID PID PID PID PID 回复：41 PID Data PID Data PID Data PID Data PID Data PID Data PID PID 说明 数据长度（byte） 计算 00 查看支持的PID 01 清除故障诊断码后的监视器状态 4 04 负载值 1 y=x/255 05 冷却液温度 1 y=x-40 0B 进气歧管绝对压力 1 y=x 0C 发动机转速 2 y=x/4 0D 车速 1 y=x 10 空气流量 2 y=x/100 11 节气门位置 1 y=x/255 44 Commanded Equivalence Ratio 2 y=2x/65535 5C 油温 1 y=x-40 6A 6E 78 尾气温度 7A 83 NOx传感器 85 NOx控制系统 PID 00 请求：01 00 回复： 41 00 A B C D //PID 01~20 41 20 A B C D //PID 21~40 41 40 A B C D //PID 41~60 41 60 A B C D //PID 61~80 41 80 A B C D //PID 81~A0 41 A0 A B C D //PID A1~C0 41 C0 A B C D //PID C1~E0 41 E0 A B C D //PID E1~FF 41 00 A B C D Data A bit7 ~ Data D bit0 表示是否支持PID 01~20 如：41 00 90 39 00 00 Data A = 90 = 1001 0000 bit7 = 1; bit4 = 1 表示支持 PID 01、PID 04 Data B = 39 = 0011 1001 bit5 = bit4 = bit3 = bit0 = 1 表示支持 PID 0B、PID 0C、PID 0D、PID 10 Service 09 PID PID 说明 数据长度（byte） 计算 02 VIN 17 04 Cal.ID 06 Cal.CVN 08 IPT ISO27145 Service 22 22 F4 对应 ISO15031的01服务 22 F8 对应 ISO15031的09服务","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"Rabbit MQ","slug":"Rabbit-MQ","date":"2019-09-19T10:38:53.000Z","updated":"2025-03-24T12:00:34.969Z","comments":true,"path":"Rabbit-MQ.html","link":"","permalink":"https://silencejql.github.io/Rabbit-MQ.html","excerpt":"","text":"安装 Erlang安装 Rabbit MQ安装前需先安装Erlang语言环境安装包下载地址： 链接：https://pan.baidu.com/s/14_Z6JUdvQfY8PGQ4NBb73A 提取码：abtt Rabbit MQ服务端安装 安装 软件安装在C盘(第一次安装到D盘后进入命令行程序不能执行，有兴趣可以研究研究)安装包下载地址： 链接：https://pan.baidu.com/s/1NbHfVoGyo_oVAXzaTnZuAw 提取码：9am0 启用管理工具 在服务程序中确保RabbitMQ服务已启用 安装完成后打开所有程序中的RabbitMQ Command Prompt (sbin dir) 输入命令：‘rabbitmq-plugins enable rabbitmq_management’ 打开浏览器输入http://localhost:15672 默认账号、密码均为guest C# Producer 项目中需要引用RabbitMQ.Client.dll下载链接为： 链接：https://pan.baidu.com/s/1aJ-8RVJnJWibeqtPcTn9hw 提取码：9d8n 此版本支持.Net4.0，全版本请自行下载 下载地址：ht 123456789101112131415161718192021222324252627282930313233343536373839404142434445using RabbitMQ.Client;var factory = new ConnectionFactory();factory.HostName = &quot;localhost&quot;;//RabbitMQ服务在本地运行127.0.0.1factory.UserName = &quot;guest&quot;;//用户名factory.Password = &quot;guest&quot;;//密码using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel())//创建一个Channel &#123; try &#123; channel.QueueDeclarePassive(mqqueueString);//判断队列是否存在 &#125; catch (Exception e) &#123; Log(mqqueueString + &quot;队列未创建!&quot;); throw e; //return false; &#125; /*在创建队列的时候，只有RabbitMQ上该队列不存在，才会去创建。 消息是以二进制数组的形式传输的，所以如果消息是实体对象的话，需要序列化和然后转化为二进制数组。*/ IBasicProperties properties = channel.CreateBasicProperties(); properties.ContentType = &quot;application/json&quot;; properties.ContentEncoding = &quot;UTF-8&quot;; properties.Headers = new Dictionary&lt;string, object&gt;(); properties.Headers.Add(&quot;srcSystem&quot;, &quot;EQP&quot;); properties.Headers.Add(&quot;desSystem&quot;, &quot;IMES&quot;); properties.Headers.Add(&quot;msgType&quot;, &quot;EQP_IMES_EM&quot;); properties.Headers.Add(&quot;msgID&quot;, msgID); channel.ConfirmSelect(); channel.QueueDeclare(mqqueueString, true, false, false, null);//消息队列 var body = Encoding.UTF8.GetBytes(msgStr); channel.BasicPublish(mqExchange, mqRoutingKey, properties, body); //开始传递 if (channel.WaitForConfirms()) &#123; Log(&quot;数据发送成功&quot;); return true; &#125; else &#123; Log(&quot;数据发送成功，但未收到确认消息&quot;); return false; &#125; &#125;&#125; 发送成功后可登录网页在Queues中查看到上传的消息队列及内容 函数说明 QueueDeclare 转自https://blog.csdn.net/vbirdbest/article/details/78670550 1234queueDeclare(String queue, boolean durable, boolean exclusive, Map&lt;String, Object&gt; arguments); queue: 队列名称 durable： 是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库 exclusive：是否排外的，有两个作用，一：当连接关闭时connection.close()该队列是否会自动删除；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常：com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=405, reply-text=RESOURCE_LOCKED - cannot obtain exclusive access to locked queue ‘queue_name’ in vhost ‘/’, class-id=50, method-id=20)一般等于true的话用于一个队列只能有一个消费者来消费的场景 autoDelete：是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除 arguments： 队列中的消息什么时候会自动被删除 Message TTL(x-message-ttl)：设置队列中的所有消息的生存周期(统一为整个队列的所有消息设置生命周期), 也可以在发布消息的时候单独为某个消息指定剩余生存时间,单位毫秒, 类似于redis中的ttl，生存时间到了，消息会被从队里中删除，注意是消息被删除，而不是队列被删除， 特性Features=TTL, 单独为某条消息设置过期时间AMQP.BasicProperties.Builder properties = new AMQP.BasicProperties().builder().expiration(“6000”); channel.basicPublish(EXCHANGE_NAME, “”, properties.build(), message.getBytes(“UTF-8”)); Auto Expire(x-expires): 当队列在指定的时间没有被访问(consume, basicGet, queueDeclare…)就会被删除,Features=Exp Max Length(x-max-length): 限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉， 类似于mongodb中的固定集合，例如保存最新的100条消息, Feature=Lim Max Length Bytes(x-max-length-bytes): 限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小, Features=Lim B Dead letter exchange(x-dead-letter-exchange)： 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉,Features=DLX Dead letter routing key(x-dead-letter-routing-key)：将删除的消息推送到指定交换机的指定路由键的队列中去, Feature=DLK Maximum priority(x-max-priority)：优先级队列，声明队列时先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费, Lazy mode(x-queue-mode=lazy)： Lazy Queues: 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中 Master locator(x-queue-master-locator) basicPublish 1234basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) String exchange – 交换机名称 String routingKey – 路由关键字 BasicProperties props – 消息的基本属性，例如路由头等 byte[] body – 消息体 12345basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body) boolean mandatory – 是否为强制性 123456basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) boolean immediate – 消息是否立即发送出去 BasicProperties 1234567891011121314151617public static class BasicProperties&#123; private String contentType; //上下文类型 private String contentEncoding; //编码集 private Map&lt;String,Object&gt; headers; //消息头 private Integer deliveryMode; //消息的投递模式 private Integer priority; //优先级 private String correlationId; // private String replyTo; // private String expiration; //过期时间 private String messageId; //消息编号 private Date timestamp; //发送消息时的时间戳 private String type; // 消息类型 private String userId; private String appId; private String clusterId;&#125; C# Consumer 编写客户端链接RabbitMQ读取信息 123456789101112131415161718192021222324using RabbitMQ.Client;using RabbitMQ.Client.Events;var factory = new ConnectionFactory();factory.HostName = &quot;localhost&quot;;factory.UserName = &quot;guest&quot;;factory.Password = &quot;guest&quot;;using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(&quot;hello&quot;, false, false, false, null); var consumer = new EventingBasicConsumer(channel); channel.BasicConsume(&quot;hello&quot;, false, consumer); consumer.Received += (model, ea) =&gt; &#123; var body = ea.Body; var message = Encoding.UTF8.GetString(body); Console.WriteLine(&quot;已接收： &#123;0&#125;&quot;, message); &#125;; Console.ReadLine(); &#125;&#125; 函数说明 BasicConsume 123456789101112131415161718192021222324String basicConsume(String queue, Consumer callback)String basicConsume(String queue, boolean autoAck, Consumer callback)String basicConsume(String queue, boolean autoAck, Map&lt;String, Object&gt; arguments, Consumer callback)String basicConsume(String queue, boolean autoAck, String consumerTag, Consumer callback)String basicConsume(String queue, boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, Consumer callback) queue 队列名 autoAck 是否自动确认消息,true自动确认,false 不自动要手动调用,建立设置为false consumerTag 消费者标签，用来区分多个消费者 noLocal 设置为true，表示 不能将同一个Conenction中生产者发送的消息传递给这个Connection中 的消费者 exclusive 是否排他 arguments 消费者的参数 callback 消费者 DefaultConsumer建立使用，重写其中的方法","categories":[{"name":"MQ","slug":"MQ","permalink":"https://silencejql.github.io/categories/MQ/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"Rabbit MQ","slug":"Rabbit-MQ","permalink":"https://silencejql.github.io/tags/Rabbit-MQ/"}]},{"title":"IBM MQ","slug":"IBM-MQ","date":"2019-09-12T11:48:12.000Z","updated":"2025-03-24T11:31:06.763Z","comments":true,"path":"IBM-MQ.html","link":"","permalink":"https://silencejql.github.io/IBM-MQ.html","excerpt":"文中代码部分参考 https://blog.csdn.net/java_sparrow/article/details/80626705 若只做客户端部分的设计不需要安装客户端 网上关于IBMMQ相关资源实在太少，感谢前人的努力，站在前人的肩膀实在上太舒服了","text":"文中代码部分参考 https://blog.csdn.net/java_sparrow/article/details/80626705 若只做客户端部分的设计不需要安装客户端 网上关于IBMMQ相关资源实在太少，感谢前人的努力，站在前人的肩膀实在上太舒服了 IBMMQ 软件安装设置 安装 安装包(WebSphereMQ8.0)已上传网盘，下载后直接安装即可。 链接：https://pan.baidu.com/s/1P9Dz74tvf8_SExH0Dl0hHA 提取码：0a87 服务端配置 下文中未提到的部分默认参数即可 创建队列管理器 设置侦听端口 创建通道 创建队列 添加用户组 将当前用户添加到IBMMQ管理组 其中对象名为下图所示安装IBMMQ后自动创建的组mqm 至此，IBMMQ环境设置完毕 C# 连接MQ 准备 已安装IBMMQ软件 程序中引用：amqmdnet.dll库文件（IBMMQ客户端安装后生成） 路径分别为： C:\\Program Files\\IBM\\WebSphere MQ\\bin\\amqmdnet.dll 程序中添加using IBM.WMQ; 程序安装完成后可能缺少mqdc.dll文件，可下载后放在安装路径 C:\\Program Files\\IBM\\WebSphere MQ\\bin64 下 链接：https://pan.baidu.com/s/19XMuE1q46K1E3BfO8lPPIQ 提取码：5qhq 免安装IBMMQ 准备好amqmdnet.dll在程序中直接引用即可下载地址： 链接：https://pan.baidu.com/s/1Qb4bdDpqXmyQO5_Jx4hmnA 提取码：soua 若缺少其他文件请自取：IBMMQ8.0安装路径Bin文件夹 链接：https://pan.baidu.com/s/1vdg4J2I1-1qLcHh_hnfXBA 提取码：kgi9 C#代码 初始化 方式一 123456789static MQQueueManager qMgr;static int CCSID = 437;MQEnvironment.Hostname = &quot;10.91.232.46&quot;;MQEnvironment.Channel = &quot;CHANNEL1&quot;;MQEnvironment.Port = 8802;MQEnvironment.UserId = &quot;user&quot;;MQEnvironment.Password = &quot;Password&quot;;// 队列管理器qMgr = new MQQueueManager(&quot;LG_2IN1_QMGR&quot;); 方式二 12345678910static MQQueueManager qMgr;Hashtable queueProperties = new Hashtable();queueProperties[MQC.TRANSPORT_PROPERTY] = MQC.TRANSPORT_MQSERIES_MANAGED;queueProperties[MQC.HOST_NAME_PROPERTY] = &quot;192.168.1.9&quot;;queueProperties[MQC.PORT_PROPERTY] = 8802;queueProperties[MQC.CHANNEL_PROPERTY] = &quot;CHANNEL1&quot;;queueProperties[MQC.USER_ID_PROPERTY] = &quot;user&quot;;queueProperties[MQC.PASSWORD_PROPERTY] = &quot;Password&quot;;queueProperties[MQC.CCSID_PROPERTY] = &quot;1381&quot;;qMgr = new MQQueueManager(&quot;LG_2IN1_QMGR&quot;, queueProperties); 发送数据 123456789101112131415161718192021222324252627282930public static void sendMsg(String msgStr)&#123; int openOptions = MQC.MQOO_INPUT_AS_Q_DEF | MQC.MQOO_OUTPUT | MQC.MQOO_INQUIRE; MQQueue queue = null; try &#123; // 建立通道的连接 queue = qMgr.AccessQueue(queueString, openOptions, null, null, null); MQMessage msg = new MQMessage();// 要写入队列的消息 msg.Format = MQC.MQFMT_STRING; msg.CharacterSet = CCSID; msg.Encoding = CCSID; // msg.writeObject(msgStr); msg.WriteString(msgStr); //将消息写入消息对象中 MQPutMessageOptions pmo = new MQPutMessageOptions(); msg.Expiry = -1; // 设置消息用不过期 queue.Put(msg, pmo);// 将消息放入队列 &#125; catch (Exception e) &#123; XmlFO.LogOut(&quot;IBMMQ&quot;,e.ToString()); &#125; finally &#123; if (queue != null) &#123; try &#123; queue.Close(); // qMgr.disconnect(); XmlFO.LogOut(&quot;IBMMQ&quot;,&quot;写入的消息为：&quot; + msgStr); &#125; catch (MQException e) &#123; XmlFO.LogOut(&quot;IBMMQ&quot;, e.ToString()); &#125; &#125; &#125;&#125; 读取数据 1234567891011121314151617181920212223242526272829303132public static void getMsg()&#123; int openOptions = MQC.MQOO_INPUT_AS_Q_DEF | MQC.MQOO_OUTPUT | MQC.MQOO_INQUIRE; MQQueue queue = null; try &#123; queue = qMgr.accessQueue(queueString, openOptions, null, null, null); System.out.println(&quot;===========================&quot;); System.out.println(&quot;该队列当前的深度为:&quot; + queue.getCurrentDepth()); System.out.println(&quot;===========================&quot;); int depth = queue.getCurrentDepth(); // 将队列的里的消息读出来 while (depth-- &gt; 0) &#123; MQMessage msg = new MQMessage();// 要读的队列的消息 MQGetMessageOptions gmo = new MQGetMessageOptions(); queue.get(msg, gmo); System.out.println(&quot;消息的大小为：&quot; + msg.getDataLength()); System.out.println(&quot;消息的内容：&quot; + msg.readStringOfByteLength(msg.getDataLength())); System.out.println(&quot;---------------------------&quot;); &#125; &#125; catch (Exception e) &#123; XmlFO.LogOut(&quot;IBMMQ&quot;, e.ToString()); &#125; finally &#123; if (queue != null) &#123; try &#123; queue.close(); qMgr.disconnect(); &#125; catch (MQException e) &#123; XmlFO.LogOut(&quot;IBMMQ&quot;, e.ToString()); &#125; &#125; &#125;&#125;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://silencejql.github.io/categories/MQ/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"IBMMQ","slug":"IBMMQ","permalink":"https://silencejql.github.io/tags/IBMMQ/"}]},{"title":"数据库自动备份、删除数据","slug":"数据库自动备份、删除数据","date":"2019-08-20T09:28:08.000Z","updated":"2025-03-25T03:21:44.140Z","comments":true,"path":"数据库自动备份、删除数据.html","link":"","permalink":"https://silencejql.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE.html","excerpt":"文中指令可在windows命令行中执行测试 本文介绍的是实用简单的方式实现所需功能，所有功能均可写在上位机软件中自动实现，但不同现场很难通用 通过脚本的形式实现简单易改","text":"文中指令可在windows命令行中执行测试 本文介绍的是实用简单的方式实现所需功能，所有功能均可写在上位机软件中自动实现，但不同现场很难通用 通过脚本的形式实现简单易改 Postgresql 数据库备份脚本 12345echo offset PRJDB=LocalDBset FileName=%PRJDB%_%date:~0,4%_%date:~5,2%_%date:~8,2%.backupif not exist &quot;D:\\BBK\\DBbackup&quot; (md D:\\BBK\\DBbackup)D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin/pg_dump.exe --host localhost --port 5432 --username &quot;postgres&quot; --no-password --format custom --verbose --file &quot;D:\\BBK\\DBbackup\\%FileName%&quot; &quot;LocalDB&quot; 说明： 备份保存路径为D:\\BBK\\DBbackup 命名为：LocalDB_年_月_日.backup D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin/pg_dump.exe为Postgresql数据库程序所在路径 删除表中数据 12// 删除一个月以前的数据D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin/psql -h 127.0.0.1 -p 5432 -d LocalDB -U postgres --command &quot;delete from 侧滑表 where 测试时间 &lt; (now() - interval &#x27;1 month&#x27;)&quot; 说明： D:/&quot;Program Files (x86)&quot;/PostgreSQL/9.5/bin为Postgresql数据库程序所在文件夹 时间扩展 年 interval '2 years' interval '2 year' interval '2 y' interval '2 Y' interval '2Y' 月 interval '1 month' interval 'one month' 周 interval '3 week' 说明：interval 可以不写 运行时会提示数据用户名密码 windows系统可在%APPDATA%\\postgresql\\pgpass.conf中添加服务器信息，实现免密操作 格式：地址:端口:数据库:用户名:密码 如：127.0.0.1:5432:LocalDB:postgres:123 参考：https://www.postgresql.org/docs/current/libpq-pgpass.html 自动运行 将上述shell指令分别复制到文本文档中另存为 name.bat，然后创建任务计划自动调用； 任务计划创建方法：windows运行compmgmt.msc 新建任务计划程序按提示操作即可 SQLServer 数据库自动备份 打开数据库，依次进入：管理——维护计划，根据维护计划向导操作即可 删除数据 启动SQL Server Agent服务，在步骤中新建作业，类型选择transact-SQL， 命令中输入： declare @tm datetime delete from tablename where tm&gt;=dateadd(month,-6,getdate())//删除表中6个月之前的数据 然后打开计划自定义执行周期 Access 直接用脚本复制重命名，新建任务计划自动执行 123set PRJDB=LocalDBset FileName=%PRJDB%_%date:~0,4%_%date:~5,2%_%date:~8,2%.backupcopy D:\\BBK\\LocalDB.mdb D:\\BBK\\DBbackup\\%FileName%&quot;","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"数据库","slug":"工作/数据库","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://silencejql.github.io/tags/PostgreSQL/"}]},{"title":"数据库链接字符串汇总","slug":"数据库链接字符串汇总","date":"2019-08-17T01:47:49.000Z","updated":"2025-03-24T11:30:24.347Z","comments":true,"path":"数据库链接字符串汇总.html","link":"","permalink":"https://silencejql.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%93%BE%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%87%E6%80%BB.html","excerpt":"链接字符串： https://www.connectionstrings.com/","text":"链接字符串： https://www.connectionstrings.com/ 通用示例 12345678910string ConnStr_EOLDDATA = &quot;$System.Data.SqlClient$Data Source=.;Initial Catalog=EOLDATA;Persist Security Info=True;User ID=sa;Password=321&quot;;string SqlLoginTable = string.Format(&quot;select * from [登录表] where [VIN] = &#x27;&#123;0&#125;&#x27;&quot;, textBoxVIN.Text);DbDataAdapter AdapLogin = BConnString.CreateDataAdapter(SqlLoginTable, ConnStr_EOLDDATA);DataTable dtLogin = new DataTable();AdapLogin.Fill(dtLogin);DataRow drLogin = null;if (dtLogin.Rows.Count &lt; 1) drLogin = dtLogin.Rows.Add();else drLogin = dtLogin.Rows[0];//drLogin = dtLogin.Rows.Count &lt; 1 ? dtLogin.Rows.Add() : dtLogin.Rows[0]; Access 链接字符串：$System.Data.OleDb$Provider=Microsoft.Jet.OLEDB.4.0;Data Source=LoginSet.mdb SQL字符串：select * from [Table] where ZTS = 'zts' string strSql = string.Format(&quot;select * from FinalData where DateTime&gt;#&#123;0&#125;#&quot;, dTime); Postgresql 链接字符串：$Npgsql$Database=LocalDB;Host=LocalHost;Port=5432;Username=postgres;Password=123 SQL字符串：select * from [Table] where VIN='vin' order by ID desc string strLocalSql = string.Format(&quot;select * from [四轮表] order by [测试时间] desc limit 1&quot;); 判断字段中包含某字符串所在位 select * from [车型库] where POSITION('&#123;0&#125;' in [VIN])&gt;0 eg:postion('abc' in '123abc123')—&gt;4 时间判断 SELECT * FROM [FAS表] where [VIN]='&#123;0&#125;' and to_char([测试时间],'yyyy-MM-dd HH24:MI:ss')='&#123;1&#125;' limit 1 SQLServer SQLServer字符串：$System.Data.SqlClient$Data Source=EOLSERVICE;Initial Catalog=EOLData;Persist Security Info=True;User ID=sa;Password=321 SQL字符串：select * from [Table] where VIN='vin' order by ID desc SQLServer判断字段中包含某字符串所在位 select * from [车型库] where charindex('&#123;0&#125;',[VIN])&gt;0 选择左侧为某字符串 select * from [车型库] where left([VIN],3)='LZW' Oracle 不需要借助客户端可直接访问数据库 string Ora_ConnStr = &quot;User ID=jcxuser;Password=jcxuser;Data Source =(DESCRIPTION = (ADDRESS_LIST =(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.111.89)(PORT = 1521))) (CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = yadata)))&quot;; 需要安装Oracle客户端并配置链接方可访问 string Ora_ConnStrOLEDB = &quot;Provider=OraOLEDB.Oracle;Data Source=yadata;Persist Security Info=True;Password=jcxuser;User ID=jcxuser&quot;; 有时间对比这两种链接字符串的区别，下面可访问但访问数据不全 string Ora_ConnStr = &quot;$System.Data.OleDb$Provider=MSDAORA;Data Source=yadata;Persist Security Info=True;Password=jcxuser;User ID=jcxuser&quot;; 1234567OracleConnection conn = new OracleConnection(Ora_ConnStr);conn.Open();string OracleSqlStr = string.Format(&quot;select * from &#123;0&#125; where SN = &#x27;&#123;1&#125;&#x27;&quot;, Ora_tableForVSN, sVIN);DataTable dtVSN = new DataTable();OracleDataAdapter odaVSN = new OracleDataAdapter(OracleSqlStr, Ora_ConnStr);odaVSN.Fill(dtVSN);conn.Close(); 123456789OleDbConnection conn = new OleDbConnection(Ora_ConnStrOLEDB);conn.Open();OleDbCommand cmdVSN = conn.CreateCommand();cmdVSN.CommandText = string.Format(&quot;select * from &#123;0&#125; where SN = &#x27;&#123;1&#125;&#x27;&quot;, Ora_tableForVSN, sVIN);DataTable dtVSN = new DataTable();OleDbDataAdapter odaVSN = new OleDbDataAdapter();odaVSN.SelectCommand = cmdVSN;odaVSN.Fill(dtVSN);conn.Close(); SQLServer向Oracle数据库传数据 123456789101112131415161718192021222324using Oracle.ManagedDataAccess;OracleConnection cnn = new OracleConnection(mesConnStr);cnn.Open();DataTable dtMES = new DataTable();OracleDataAdapter oda = new OracleDataAdapter(oraSql, mesConnStr);OracleCommandBuilder ocb = new OracleCommandBuilder(oda);oda.SelectCommand.CommandText = oraSql;oda.InsertCommand = ocb.GetInsertCommand();oda.Fill(dtMES);cnn.Close();DataRow drMES = null;if (dtMES.Rows.Count &gt; 0) drMES = dtMES.Rows[0];else drMES = dtMES.Rows.Add();foreach (DataColumn dcEOL in upload.Columns)&#123; if (dtMES.Columns.Contains(dcEOL.ColumnName)) drMES[dcEOL.ColumnName] = drEOL[dcEOL.ColumnName];&#125;oda.Update(dtMES);dtMES.AcceptChanges(); SQLite 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//创建数据库表static void CreateTable()&#123; SQLiteConnection cn = new SQLiteConnection(connStr);//建立数据库连接 if (cn.State!= System.Data.ConnectionState.Open) &#123; cn.Open();//打开数据库 SQLiteCommand cmd = new SQLiteCommand(); cmd.Connection = cn;//把 SQLiteCommand的 Connection和SQLiteConnection 联系起来 cmd.CommandText = &quot;CREATE TABLE IF NOT EXISTS t1(id varchar(4),score int)&quot;;//输入SQL语句 cmd.ExecuteNonQuery();//调用此方法运行 &#125; cn.Close();&#125;if(!File.Exists(dbPath)) SQLiteConnection.CreateFile(dbPath);SQLiteConnection sqliteConn = new SQLiteConnection(&quot;data source=&quot; + dbPath); if (sqliteConn.State != System.Data.ConnectionState.Open) &#123; sqliteConn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.Connection = sqliteConn; //cmd.CommandText = &quot;DROP TABLE IF EXISTS t1&quot;; //cmd.CommandText = &quot;CREATE TABLE &quot; + &quot;FirstTabel&quot; + &quot;(Name varchar,Team varchar, Number varchar)&quot;; //cmd.CommandText = &quot;INSERT INTO FirstTabel VALUES(&#x27;Kobe&#x27;,&#x27;Lakers&#x27;,&#x27;24&#x27;)&quot;; //cmd.CommandText = &quot;REPLACE INTO t1(id,age) VALUES(@id,@age)&quot;; //cmd.CommandText = &quot;UPDATE t1 SET id=@id,age=@age WHERE id=&#x27;0123456789&#x27;&quot;; //cmd.CommandText = &quot;DELETE FROM t1 WHERE id=&#x27;99999&#x27;&quot;; //cmd.CommandText = &quot;ALTER TABLE t1 ADD COLUMN age int&quot;; cmd.CommandText = &quot;insert into FirstTabel(Name,Team,Number) values(@name,@team,@number)&quot;; cmd.Parameters.AddWithValue(&quot;@name&quot;, &quot;Kobe&quot;); cmd.Parameters.AddWithValue(&quot;@Team&quot;, &quot;Lakers&quot;); cmd.Parameters.AddWithValue(&quot;@Number&quot;, &quot;24&quot;); cmd.ExecuteNonQuery(); &#125; sqliteConn.Close();//常用SQLiteConnection cn = new SQLiteConnection(connStr);cn.Open();SQLiteCommand cmd = cn.CreateCommand();cmd.CommandText= string.Format(&quot;select * from &#123;0&#125; where SN = &#x27;&#123;1&#125;&#x27;&quot;, Ora_tableForVSN, sVIN);//方法一：用DataAdapter和DataTable类，调用方法为using System.DataSQLiteDataAdapter adapter = new SQLiteDataAdapter(cmd);DataTable table = new DataTable();adapter.Fill(table);cn.Close();//方法二：用DataReader，这个效率高些SQLiteDataReader reader = cmd.ExecuteReader(); Mysql 1234567891011121314151617181920212223242526272829303132using MySql.Data.MySqlClient;MySqlConnection myconn = new MySqlConnection(&quot;server=10.102.62.26;database=cartest_reporter;user id=root;password=root;Charset=utf8&quot;);myconn.Open();MySqlCommand mycom = myconn.CreateCommand();mycom.CommandText = &quot;SELECT *FROM student1&quot;;MySqlDataAdapter adap = new MySqlDataAdapter(mycom);MySqlCommandBuilder mysqlcb = new MySqlCommandBuilder(adap);// insertDataTable dt = new DataTable();adap.Fill(dt);/*string MES_ConnStr = @&quot;server = 10.23.1.67;Uid = testams;Pwd = test@ams;database= test;CharSet=utf8&quot;;MySqlConnection conn = new MySqlConnection(MES_ConnStr);if (conn.State != ConnectionState.Open) conn.Open();strOra_Sql = string.Format(&quot;select * from &#123;0&#125;&quot;, MESTableName);MySqlDataAdapter sdap = new MySqlDataAdapter();MySqlCommand mycmdFind = new MySqlCommand(strOra_Sql, conn);MySqlCommandBuilder cb = new MySqlCommandBuilder(sdap);DataTable dt = new DataTable();sdap.SelectCommand = mycmdFind;sdap.Fill(dt);DataRow dr = dt.NewRow();foreach (string s in ListMap.Keys)&#123; dr[s] = drEOL[ListMap[s]];&#125;dt.Rows.Add(dr);sdap.Update(dt);conn.Close();*/ Excel 1234567DataSet ds = new DataSet();OleDbConnection conn = new OleDbConnection(strConn);string sql = string.Format(&quot;select * from [&#123;0&#125;$] where [VIN] like &#x27;%&#123;1&#125;%&#x27;&quot;, sourceTableName, VINString);OleDbDataAdapter oada = new OleDbDataAdapter(sql, conn);oada.Fill(ds);foreach (DataRow drr in ds.Tables[0].Rows)","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"数据库","slug":"工作/数据库","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"链接字符串","slug":"链接字符串","permalink":"https://silencejql.github.io/tags/%E9%93%BE%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"现场软件安装包下载","slug":"现场软件安装包下载","date":"2019-08-08T03:19:57.000Z","updated":"2025-03-25T03:20:07.565Z","comments":true,"path":"现场软件安装包下载.html","link":"","permalink":"https://silencejql.github.io/%E7%8E%B0%E5%9C%BA%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD.html","excerpt":"","text":"百度网盘下载推荐用ENFI下载器 链接：https://www.enfi.cloud/#/index 串口调试助手 链接：https://pan.baidu.com/s/1KAisgybEesC8fMTwJ-oK3w 提取码：au8d Socktools 链接：https://pan.baidu.com/s/1lXWZWLjt9LE4xxCjK873-Q 提取码：v5qn .NetFramework4.0 链接：https://pan.baidu.com/s/1Hwdt4rEToEK4Ao4ljvmURA 提取码：wlfc 虚拟串口 链接：https://pan.baidu.com/s/1FrqtaKrp74EPmyvVqNOu6g 提取码：wkv3 VisualStudio2010 链接：https://pan.baidu.com/s/1Z-EUIWWsJmUN22KS8QNKcg 提取码：rwpn SQLServer2008 链接：https://pan.baidu.com/s/15hGavjba8ewaFxlyd_K-dw 提取码：xdxa KepServer5.2 链接：https://pan.baidu.com/s/1zmX5Myqts5zzG3DTjairdg 提取码：7dwx Postgresql9.5.3 链接：https://pan.baidu.com/s/1NA4aNTu9CGmAEYd9aeo-Gg 提取码：l9h6 Setup_Npgsql-2.2.3.0-r2-net40 链接：https://pan.baidu.com/s/1wLBTi8vgJUCvlqO8HvorOQ 提取码：yv4h Orical 10g Client 链接：https://pan.baidu.com/s/1btHhUl-ataDjq6J7KAWfuA 提取码：ks71 psqlodbc_x86 链接：https://pan.baidu.com/s/19FKNrVT4CxO5yHyvhVayOw 提取码：9yud","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"诊断指令说明--OBD模块","slug":"诊断指令说明-OBD模块","date":"2019-08-08T01:22:46.000Z","updated":"2025-03-07T12:34:48.110Z","comments":true,"path":"诊断指令说明-OBD模块.html","link":"","permalink":"https://silencejql.github.io/%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E-OBD%E6%A8%A1%E5%9D%97.html","excerpt":"","text":"通讯测试 串口测试车辆通讯问题 SendID：0730；RecvID：0738 33 33 07 38 FF FF 88 88 设置滤波 只接收ID为0738的指令 55 55 07 30 02 10 03 00 00 00 00 00 88 88 发送指令 发送ID为0730 其中： 02 10 03 00 00 00 00 00 为CAN指令，第一位为长度位。 为什么用55指令测试通讯： 55指令中不包含CAN通讯等待的时间参数，不会出现第三版协议因超时时间较短而导致收不到车辆回复。 第三版协议指令说明 发送数据 F0 F0 XX XX// 数据长度 XX //指令类型: 10: CAN数据（针对ISO15765协议而定） 13: 设置CAN通信滤波ID 14: 只发送指定长度(小于等于8)CAN数据 15:设置CAN通信波特率及标准帧拓展帧 20 :K线数据 25: 设置K线初始化波特率及通信波特率 05: 设置超时时间 CAN通讯短等待回复时间，默认100ms，长等待时间，默认5000ms XX XX XX XX //本机ID XX XX XX XX //目标ID XX n…//数据 FF//结尾 接收数据 0F 0F XX XX// 数据长度 XX //指令类型: 10: CAN数据（针对ISO15765协议而定） 13: 设置CAN通信滤波ID 14: 接收到已设置了CAN通信滤波ID的CAN数据 15:设置CAN通信波特率及标准帧拓展帧 20: K线数据 25: 设置K线初始化波特率及通信波特率 05: 设置通信响应超时时间成功的响应指令 7F: 收到错误回复，比如超时、数据格式错误等 XX XX XX XX //本机ID XX XX XX XX //目标ID XX n…//数据 FF//结尾 示例： 发送：F0 F0 00 0C 10 00 00 07 20 00 00 07 30 10 03 FF 接收：0F 0F 00 10 10 00 00 07 20 00 00 07 30 50 03 00 32 01 F4 FF 设置指定滤波ID及读取超时时间(0x12) 发送：F0 F0 00 07 12 00 00 07 30 14 FF 接收：若CAN总线上指定滤波ID(00 00 07 20)对应的数据及超时时间（20*10=200ms），则返回： 0F 0F 00 0E 12 00 00 07 30 00 01 02 03 04 05 06 07 FF //(00 00 07 30 目标ID) 否则返回超时提示； 设置滤波ID(0x13) 发送：F0 F0 00 0A 13 00 00 07 20 FF FF FF FF FF 接收：若CAN总线上有设置的ID对应的数据，则返回： 0F 0F 00 0E 14 00 00 07 30 50 03 00 32 01 F4 FF//(00 00 07 30 目标ID) 否则无返回； 只发送单帧数据(0x14) 发送：F0 F0 00 0E 14 00 00 07 20 00 00 00 00 12 34 56 78 FF 发送的目标ID: 00 00 07 20 发送的CAN数据: 12 34 56 78 设置波特率及标准帧拓展帧（0x15） 第6字节及第7字节表示设置波特率大小，单位kbps 第8字节及第9字节表示设置标准帧或拓展帧：00 00 标准帧 00 01 拓展帧 接收数据01代表设置成功，无返回或者返回其他字节数目则设置失败，请注意检测数据格式。 比如 发送：F0 F0 00 06 15 01 F4 00 01 FF//设置波特率500K，拓展帧 接收：0F 0F 00 03 15 01 FF//设置成功 设置波特率及标准帧拓展帧，无返回确认指令（针对0x15）(0x16) 第6字节及第7字节表示设置波特率大小，单位kbps 第8字节及第9字节表示设置标准帧或拓展帧：00 00 标准帧 00 01 拓展帧 设置成功与否，都不返回数据 发送：F0 F0 00 06 16 01 F4 00 01 FF//设置波特率500K，拓展帧 接收：无 K-Line设置初始波特率及正常通讯波特率（0x25） 第6字节及第7字节表示设置初始波特率（单位：bps），默认200bps 第8字节及第9字节表示设置正常通讯波特率（单位：bps），默认10400bps 接收数据01代表设置成功，无返回或者返回其他字节数目则设置失败，请注意检测数据格式。 发送：F0 F0 00 06 25 00 C8 28 A0 FF//设置波初始波特率200bps及正常通讯波特率10400bps 接收：0F 0F 00 03 25 01 FF//设置成功 K线指令（0x20） 发送：F0 F0 00 08 20 80 28 F1 01 81 1b FF 接收：0F 0F 00 0A 20 80 F1 28 03 C1 6B 8F 57 FF 通讯错误的回复指令（0x7F） 0F 0F 00 03 7F XX FF 故障码说明 XX故障码(Hex) 说明 00 等待接收或延时发送 02 发送单帧100ms超时未收到CAN数据 03 5000ms超时提示 04 接收多帧时，未收到数据100ms超时提示 05 读取指定ID数据，超时提示 11 接收多帧时未收到流控帧提示 12 接收到的CAN数据长度大于7错误提示 13 接收到未符合要求的数据类型 21 发送Kline数据500ms超时未收到CAN数据 F2 接收到PC数据不是以0xFF结尾 F1 CAN数据超过4096个字节 2A K线初始化后未接收到”格式”字节 2B K线初始化后自反馈是未接收到指定长度K线数据 2C K线未接收到0x80字节","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"诊断指令","slug":"诊断指令","permalink":"https://silencejql.github.io/tags/%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4/"},{"name":"CAN","slug":"CAN","permalink":"https://silencejql.github.io/tags/CAN/"}]},{"title":"工作-BBK","slug":"工作-BBK","date":"2019-08-07T08:28:57.000Z","updated":"2025-03-24T11:30:11.944Z","comments":true,"path":"工作-BBK.html","link":"","permalink":"https://silencejql.github.io/%E5%B7%A5%E4%BD%9C-BBK.html","excerpt":"","text":"诊断指令说明--OBD模块 现场软件备份路径 现场问题整理 Postgresql数据导入导出 现场软件安装包下载","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"}]},{"title":"HTML常用标签","slug":"HTML常用标签","date":"2019-08-07T01:59:59.000Z","updated":"2025-03-24T11:30:03.421Z","comments":true,"path":"HTML常用标签.html","link":"","permalink":"https://silencejql.github.io/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE.html","excerpt":"","text":"HTML标签 HTML标题 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;h2&gt;h2&lt;/h2&gt; &lt;h3&gt;h3&lt;/h3&gt; &lt;h4&gt;h4&lt;/h4&gt; &lt;h5&gt;h5&lt;/h5&gt; &lt;h6&gt;h6&lt;/h6&gt; &lt;/body&gt;&lt;/html&gt; 水平线/分割线 &lt;hr/&gt; 注释 html注释：&lt;!-- comment --&gt; 段落及换行 html段落&lt;p&gt;以及段落换行&lt;br/&gt; 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;p&gt;hello &lt;br/&gt; world&lt;/p&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; 文本格式化 标签 描述 &lt;b&gt; 加粗 &lt;big&gt; 大号字体 &lt;em&gt; 着重文字 &lt;i&gt; 斜体 &lt;small&gt; 小号字体 &lt;sub&gt; 下标 &lt;sup&gt; 上标 超链接 &lt;a&gt;比较重要的属性有两个，分别是href、target href指定超链接地址 target指定打开方式 _blank 新页面打开 普通链接 &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; 邮件链接 标签最简式 &lt;a href=&quot;mailto:xxx@xx.com&quot;&gt;联系站长&lt;/a&gt; 图像 使用格式：&lt;img src=&quot;url&quot;&gt; alt 定义当图片无法加载时，显示什么信息 width 定义宽度，单位可以为像素 也可以为百分比 height 定义高度 &lt; img src=“11.jpg” width=&quot;100px&quot; height=&quot;200px&quot; title=&quot;title&quot; alt=&quot;图片无法显示，请刷新&quot;/&gt; 表格 表格由&lt;table&gt;来定义，每行&lt;tr&gt; 有许多单元格&lt;td&gt;。表头可以使用&lt;th&gt; &lt;table&gt;标签属性： border：表格边框属性；当使用border=&quot;1&quot;设置边框时，会在所有td以及table上嵌套边框，当border加大时，只有table框会加粗。 cellspacing：单元格与单元格之间的间隙。当cellspacing=&quot;0&quot;时，单元格之间的间隙为0，但边框线并不会合并。 ☆☆合并边框的写法style=“border-collapse:collapse;” 使用边框合并时，无需设置cellspacing。 cellpadding:单元格内边距，单元格中文字与单元格边框之间的距离。 width/height:表格的宽高 align：设置表格在父容器中的对齐方式 ，left/居左 center/居中 right/居右 ☆☆当表格使用align属性时，相当于使表格浮动，可能会导致表格后面的元素受表格浮动影响，导致布局错乱。 bgcolor：背景色 background：背景图，后接相对路径。背景图和背景色同时生效时，图会覆盖背景色 bordercolor：设置边框颜色 在&lt;table&gt;中可以嵌入&lt;th&gt; &lt;tr&gt; &lt;td&gt;等标签 &lt;tr&gt; 定义行 &lt;th&gt; 定义表头 colspan 定义表头单元格可以横跨的列数。 rowspan 定义表头单元格横跨的行数 heardes 定义与表头单元格相关联的一个或者多个单元格。(html5新增) &lt;td&gt; 定义单元格 colspan 定义单元格可以横跨的列数。 rowspan 定义单元格横跨的行数 heardes 定义与单元格相关联的一个或者多个单元格。(html5新增) 表格固定高度：overflow-y:auto; 列表 无序列表&lt;ul&gt; 有序列表&lt;ol&gt; 123456789&lt;ul&gt; &lt;li&gt;male&lt;/li&gt; &lt;li&gt;female&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;ol&gt; &lt;li&gt;male&lt;/li&gt; &lt;li&gt;female&lt;/li&gt;&lt;/ol&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://silencejql.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://silencejql.github.io/tags/HTML/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-06T09:46:21.000Z","updated":"2025-03-07T12:33:03.807Z","comments":true,"path":"正则表达式.html","link":"","permalink":"https://silencejql.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","excerpt":"","text":"Re库 re.search 扫描整个字符串并返回第一个成功的匹配 re.search(pattern,string,flag=0) pattern:正则表达式字符串 string:待匹配字符串 flag:控制标记 re.I或re.IGNORECASE表示忽略正则表达式的大小写，[A-Z]可匹配大小写 re.M或re.MULTILINE正字表达式中的^操作符能将给定字符串的每一行当做匹配开始 re.S或re.DOTALL正则表达式中的.操作符能匹配所有字符，默认不能匹配换行符 re.match(pattern,string,flag=0) re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配 re.findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表 re.split(pattern,string,maxsplit=0,flag=0) 将字符串按照正则表达式匹配的结果进行分割，返回列表 re.split([a],sadfab)返回s,df,b re.sub(pattern,repl,string,count=0,flag=0) 在一个字符串中替换所有正则表达式所匹配的子串，返回替换后的字符串 repl:替换匹配字符串的字符串 count:匹配的最大替换次数 Match对象属性 .string:待匹配文本 .re:匹配时使用的pattern对象 .pos:正则表达式搜索文本的开始位置 .endpos:正则表达式搜索文本的结束位置 Match对象方法 .group():group(0)获取匹配后的字符串,group(n)匹配正则表达式中如(\\d+)第n个括号所匹配字符串 .start():匹配字符串在原始字符串的开始位置 .end(): .span():返回(.start(),.end()) 常用字符 字符|描述|实例 :|:|: . | 任意单个字符 | [] | 字符集，对单个字符给出取值范围 | [abc]表示a或b或c的单个字符，[a-z]表示a-z的单个字符 [^] |非字符集，对单个字符给出排除范围 | [^abc]表示非a或b或c的单个字符 * | 前一个字符0次或无限次重复 | abc*表示ab、abc、abccccc + | 前一个字符的1次或无限次重复 |abc+表示abc、abccc ? | 前一个字符0次或1次重复 | abc?表示ab或abc | |左右表达式任意一个 |a|b 表示a或b {m} |重复前一个字符m次 |ab{2}cb表示abbcb,注意次数 {m,n} | 重复前面一个字符m至n次(包含n) | ab{1,2}c表示abc或abbc ^ | 匹配字符串开头 | ^abc表示abc在一个字符串的开头 $ | 匹配字符串结尾 | abc$abc表示abc在一个字符串的结尾 () | 分组标记，内部只能用|操作符 | (abc)表示abc,(abc|def)表示abc或def \\d | 数字，等价于[0-9] | \\w | 单词字符，等价于[A-Za-z0-9] | 非打印字符 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 [] [abc]表示a或b或c，[a~z]表示a~z其中一个 [^] [^abc]表示非a或b或c ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。‘\\n’ 匹配换行符。序列 ‘\\’ 匹配 &quot;&quot;，而 ‘(’ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配 定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 环视 环视又叫预搜索和零宽断言 环视只占用逻辑位置 不占用物理位置 环视 | 含义 |:|:| (?=exp) | 肯定顺序环视，子表达式能匹配右侧的文本 (?!exp) | 否定顺序环视，子表达式不能匹配右侧的文本 (?&lt;=exp) | 肯定逆序环视，子表达式能匹配左侧的文本 (?&lt;!exp) | 否定逆序环视，子表达式不能匹配左侧的文本 示例： 下列环视正则匹配均输出&quot;AAA&quot; 123456import reprint(re.findall(&quot;(?&lt;=B)AAA&quot;,&quot;BAAA&quot;))print(re.findall(&quot;(?&lt;!B)AAA&quot;,&quot;CAAA&quot;))#这里使用(?&lt;!B)、(?&lt;!=B)均可print(re.findall(&quot;AAA(?=B)&quot;,&quot;AAAB&quot;))print(re.findall(&quot;AAA(?!B)&quot;,&quot;AAAC&quot;))#这里使用(?!B)、(?!=B)均可","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://silencejql.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://silencejql.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"现场问题整理","slug":"现场问题整理","date":"2019-08-06T03:31:16.000Z","updated":"2025-03-24T11:30:49.750Z","comments":true,"path":"现场问题整理.html","link":"","permalink":"https://silencejql.github.io/%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86.html","excerpt":"","text":"通讯测试 串口测试车辆通讯问题 SendID：0730；RecvID：0738 33 33 07 38 FF FF 88 88 设置滤波 只接收ID为0738的指令 55 55 07 30 02 10 03 00 00 00 00 00 88 88 发送指令 发送ID为0730 其中： 02 10 03 00 00 00 00 00 为CAN指令，第一位为长度位。 四轮大灯 四轮设备中文乱码导致数据上传失败 解决方法 更改时间、区域为China 详情请咨询 Coulsonxia 宝骏现场大灯数据单独上传 实现方法 流程中新建TCPClient用于接收大灯通讯 启动大灯需要发送车型信息，格式为：{0x02}{车辆信息_ToHLA_ZTS};{车辆信息_ToHLA_VIN}{0x0D}{0x0A} 接收解析并保存大灯数据","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"现场问题","slug":"现场问题","permalink":"https://silencejql.github.io/tags/%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98/"}]},{"title":"现场软件备份路径","slug":"现场软件备份路径","date":"2019-08-06T02:54:24.000Z","updated":"2025-03-24T11:30:33.937Z","comments":true,"path":"现场软件备份路径.html","link":"","permalink":"https://silencejql.github.io/%E7%8E%B0%E5%9C%BA%E8%BD%AF%E4%BB%B6%E5%A4%87%E4%BB%BD%E8%B7%AF%E5%BE%84.html","excerpt":"网盘中软件工程下有相应文件夹的上传在相应文件夹中，没有的上传在对应项目文件夹中，后期会提醒Dean在软件工程中新建相应文件夹。 Z:\\4-软件共享John\\软件工程","text":"网盘中软件工程下有相应文件夹的上传在相应文件夹中，没有的上传在对应项目文件夹中，后期会提醒Dean在软件工程中新建相应文件夹。 Z:\\4-软件共享John\\软件工程 网盘地址 内网：http://192.168.1.80:5000/ 外网：https://bbknick.synology.me:5001/ 北汽 莱西被动式ACC 更新时间：20190806 Z:\\6-项目管理Jason\\2018\\218039 北汽新能源莱西工厂一套驾驶辅助标定设备项目-Jones\\17-现场设备调试程序 北汽昆明 更新时间：20190806 Z:\\6-项目管理Jason\\2017\\117314 北汽新能源汽车工程技术中心（昆明）检测线项目-Jones\\17-现场设备调试程序\\设备程序 众泰 贵港腾骏 更新时间：20190806 Z:\\4-软件共享John\\软件工程\\腾骏\\腾骏贵港","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"现场软件备份","slug":"现场软件备份","permalink":"https://silencejql.github.io/tags/%E7%8E%B0%E5%9C%BA%E8%BD%AF%E4%BB%B6%E5%A4%87%E4%BB%BD/"}]},{"title":"数据库导入导出","slug":"数据库导入导出","date":"2019-07-30T00:32:28.000Z","updated":"2023-01-05T05:08:16.588Z","comments":true,"path":"数据库导入导出.html","link":"","permalink":"https://silencejql.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html","excerpt":"","text":"Postgresql 测试软件导出、Postgresql导入 测试软件导出 连接数据库设置完筛选条件后点击导出到Excel重命名为：表名.csv 测试软件导入 1、打开导出表添加新的数据后，删除第一行表头以及第一列序号 2、删除原数据库已有行后保存 3、打开Postgres找到相应表右键导入 4、文件名选择csv文件路径、格式选csv、字符编码可选 5、点击导入即可 如果主键为自增序列执行6、7 6、将相应表的序列创建脚本后删除 7、更改脚本中的START大于新增数据的主键ID后执行脚本 SQL shell(psql)导入 1、将excel处理好后，另存为csv（Comma Delimited） 2、运行SQL shell(psql) 并登录 3、运行’COPY mytable FROM ‘/myfile.csv’ WITH CSV HEADER SQL shell(psql)导出 COPY (select * from mytable) to ‘/myfile.csv’ with csv header;","categories":[{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"数据库","slug":"工作/数据库","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Postgresql","slug":"Postgresql","permalink":"https://silencejql.github.io/tags/Postgresql/"}]},{"title":"Postgresql数据导入导出","slug":"Postgresql数据导入导出","date":"2019-07-30T00:32:28.000Z","updated":"2025-03-24T11:38:46.097Z","comments":true,"path":"Postgresql数据导入导出.html","link":"","permalink":"https://silencejql.github.io/Postgresql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html","excerpt":"","text":"测试软件导出、Postgresql导入 测试软件导出 连接数据库设置完筛选条件后点击导出到Excel重命名为：表名.csv 测试软件导入 1、打开导出表添加新的数据后，删除第一行表头以及第一列序号 2、删除原数据库已有行后保存 3、打开Postgres找到相应表右键导入 4、文件名选择csv文件路径、格式选csv、字符编码可选 5、点击导入即可 如果主键为自增序列执行6、7 6、将相应表的序列创建脚本后删除 7、更改脚本中的START大于新增数据的主键ID后执行脚本 SQL shell(psql)导入 1、将excel处理好后，另存为csv（Comma Delimited） 2、运行SQL shell(psql) 并登录 3、运行’COPY mytable FROM ‘/myfile.csv’ WITH CSV HEADER SQL shell(psql)导出 COPY (select * from mytable) to ‘/myfile.csv’ with csv header; 数据库备份脚本 12345echo offset PRJDB=LocalDBset FileName=%PRJDB%_%date:~0,4%_%date:~5,2%_%date:~8,2%.backupif not exist &quot;D:\\BBK\\DBbackup&quot; (md D:\\BBK\\DBbackup)D:/“Program Files (x86)“/PostgreSQL/9.5/bin\\pg_dump.exe --host localhost --port 5432 --username &quot;postgres&quot; --no-password --format custom --verbose --file &quot;D:\\BBK\\DBbackup\\%FileName%&quot; &quot;LocalDB&quot; 删除表中数据 12// 删除7天以前的数据D:/“Program Files (x86)“/PostgreSQL/9.5/bin/psql -h 127.0.0.1 -p 5432 -d LocalDB -U postgres --command &quot;delete from 侧滑表 where 测试时间 &lt; (now() - interval &#x27;7 day&#x27;)&quot; 时间扩展 年 interval ‘2 years’ interval ‘2 year’ interval ‘2 y’ interval ‘2 Y’ interval ‘2Y’ 月 interval ‘1 month’ interval ‘one month’ 周 interval ‘3 week’ 说明：interval 可以不写 运行时会提示数据用户名密码 windows系统可在%APPDATA%\\postgresql\\pgpass.conf中添加服务器信息，实现免密操作。 参考：https://www.postgresql.org/docs/current/libpq-pgpass.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://silencejql.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://silencejql.github.io/tags/PostgreSQL/"}]},{"title":"csharp XML","slug":"C-XML","date":"2019-07-11T04:56:29.000Z","updated":"2025-03-24T11:29:05.304Z","comments":true,"path":"C-XML.html","link":"","permalink":"https://silencejql.github.io/C-XML.html","excerpt":"","text":"XML创建、读取配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static public void WirteConfig(string FileName, string KeyName, string Value)&#123; try &#123; string FilePath = OnlyOneStartUp.UseConfigPath; string AllFileName = FilePath + &quot;\\\\&quot; + FileName + &quot;.xml&quot;; if (!Directory.Exists(FilePath)) Directory.CreateDirectory(FilePath); DataSet ds = new DataSet(); if (File.Exists(AllFileName)) ds.ReadXml(AllFileName); if (ds.Tables.Count &lt; 1) ds.Tables.Add(); if (ds.Tables[0].Rows.Count &lt; 1) ds.Tables[0].Rows.Add(); if (!ds.Tables[0].Columns.Contains(KeyName)) ds.Tables[0].Columns.Add(KeyName); ds.Tables[0].Rows[0][KeyName] = Value; ds.WriteXml(AllFileName); &#125; catch (Exception e) &#123; string sError = string.Format(&quot;写入配置信息Error:&#123;0&#125;&quot;, e.Message); ErrorOut(MethodInfo.GetCurrentMethod().Name, sError); &#125;&#125;/// &lt;summary&gt;/// 读出配置文件/// &lt;/summary&gt;/// &lt;param name=&quot;FileName&quot;&gt;配置文件名称&lt;/param&gt;/// &lt;param name=&quot;KeyName&quot;&gt;键名&lt;/param&gt;/// &lt;param name=&quot;Value&quot;&gt;返回的值&lt;/param&gt;static public bool ReadConfig(string FileName, string KeyName, ref string Value)&#123; try &#123; string FilePath = OnlyOneStartUp.UseConfigPath; string AllFileName = FilePath + &quot;\\\\&quot; + FileName + &quot;.xml&quot;; if (!Directory.Exists(FilePath)) return false; DataSet ds = new DataSet(); if (File.Exists(AllFileName)) ds.ReadXml(AllFileName); else return false; if (ds.Tables.Count &lt; 1) return false; if (ds.Tables[0].Rows.Count &lt; 1) return false; if (!ds.Tables[0].Columns.Contains(KeyName)) return false; Value = Convert.ToString(ds.Tables[0].Rows[0][KeyName]); return true; &#125; catch (Exception e) &#123; string sError = string.Format(&quot;读取配置信息Error:&#123;0&#125;&quot;, e.Message); ErrorOut(MethodInfo.GetCurrentMethod().Name, sError); return false; &#125;&#125;static public void ReadConfigEx(string FileName, string KeyName, ref string Value)&#123; if (!ReadConfig(FileName, KeyName, ref Value)) WirteConfig(FileName, KeyName, Value);&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"XML","slug":"XML","permalink":"https://silencejql.github.io/tags/XML/"}]},{"title":"数据转换","slug":"数据转换","date":"2019-07-11T03:13:39.000Z","updated":"2025-03-25T03:18:43.495Z","comments":true,"path":"数据转换.html","link":"","permalink":"https://silencejql.github.io/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2.html","excerpt":"","text":"IEEE to Double、Char、int 在线转换工具 http://www.binaryconvert.com C# IEEE to Single 123456789101112131415161718192021222324252627private Single IEEE2Single(byte[] b)&#123; try &#123; Array.Reverse(b); Single d = BitConverter.ToSingle(b, 0); return (Single)Math.Round(d, 5); &#125; catch (System.Exception ex) &#123; return 0; &#125;&#125;private byte[] SingleToIEEE(Single d)&#123; try &#123; byte[] b = new byte[]&#123;&#125;; b = BitConverter.GetBytes(d); Array.Reverse(b); return b; &#125; catch (System.Exception ex) &#123; return new byte[] &#123; 0x00, 0x00, 0x00, 0x00&#125;; &#125;&#125; 3CA97E13-&gt;0.02069 格式转换 Double to Hex 12345int Height_LF = (int)Convert.ToDouble(XmlFO.ListObject[&quot;WBH_LF&quot;].xValue);Height_RR *= 4;string s = string.Empty;s = s + ((byte)(Height_LF &gt;&gt; 8)).ToString(&quot;x2&quot;)+ &quot; &quot;;s = s + ((byte)(Height_LF)).ToString(&quot;x2&quot;) + &quot; &quot;; 2700-&gt;0a 8c Byte to uint 1234567891011121314151617181920uint BytesToUint(byte[] bys)&#123; uint ReVal = 0; foreach (byte b in bys) &#123; ReVal &lt;&lt;= 8; ReVal += b; &#125; return ReVal;&#125;byte[] UintToBytes(uint UnVal, int Count)&#123; byte[] ReVal = new byte[Count]; for (int i = 0; i &lt; Count; i++) &#123; ReVal[Count - i - 1] = (byte)(UnVal &gt;&gt; (i * 8)); &#125; return ReVal;&#125; Int to Byte 1234567891011121314151617181920212223242526272829public xState ToByte(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; xBytes tmpbyte = (xBytes)XmlFO.GetCheckSpecTypeObject(SepPara[0], typeof(xBytes)); if (tmpbyte == null) return xState.xError; int Count = Convert.ToInt32(SepPara[1]); if (Count &gt; 4) Count = 4; if (Count &lt; 1) Count = 1; Byte[] TmpByte = new byte[Count]; for (int i = 0; i &lt; Count; i++) &#123; TmpByte[i] = (byte)((iValue &gt;&gt; ((Count - i - 1) * 8)) &amp; 0xFF); &#125; tmpbyte.Bytes = TmpByte; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125; Byte 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442public byte[] xHexToBytes(string InStr)&#123; if (!InStr.StartsWith(&quot;0x&quot;)) return System.Text.Encoding.GetEncoding(cPage).GetBytes(InStr); InStr = InStr.Substring(2); string NSpaceStr = InStr.Replace(&quot; &quot;, string.Empty); List&lt;byte&gt; ReByte = new List&lt;byte&gt;(); for (int i = 0; i &lt; NSpaceStr.Length / 2; i++) &#123; ReByte.Add(Convert.ToByte(NSpaceStr.Substring(i * 2, 2), 16)); &#125; return ReByte.ToArray();&#125;public byte[] StringAnaToBytes(string StrAna)&#123; List&lt;byte&gt; ReByte = new List&lt;byte&gt;(); try &#123; string[] strs = StrAna.Split(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;); for (int i = 0; i &lt; strs.Length; i++) &#123; if (i % 2 == 0) ReByte.AddRange(System.Text.Encoding.GetEncoding(cPage).GetBytes(strs[i])); else ReByte.AddRange(xHexToBytes(strs[i])); &#125; &#125; catch (Exception e) &#123; string xError = string.Format(&quot;字符串转换到BYTE失败Error:&#123;0&#125; 字串：&#123;1&#125;&quot;, e.Message, StrAna); xErrorOut(MethodInfo.GetCurrentMethod().Name, xError); &#125; return ReByte.ToArray();&#125;public string PackBytes(byte[] ArrByte)&#123; string ReStr = &quot;&#123;0x&quot;; foreach (byte b in ArrByte) &#123; ReStr += b.ToString(&quot;X2&quot;); &#125; ReStr += &quot;&#125;&quot;; return ReStr;&#125;public int cPage = Encoding.Default.CodePage;public byte[] StringToBytes(string InValue)&#123; string str = XmlFO.StringAnalysis(InValue); return StringAnaToBytes(str);&#125;public string BytesToString(byte[] InBytes)&#123; return System.Text.Encoding.GetEncoding(cPage).GetString(Bytes);&#125;public xState ToString(string sPara)&#123; try &#123; XmlFO.ListObject[sPara].xValue = BytesToString(Bytes); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = (sbyte)Bytes[0]; if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt_MinusSign(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = (Bytes[0] &amp; 0x7F); if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; if (Bytes[0] &gt; 0x7F) NumTmp = -NumTmp; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState ToInt_Uint(string sPara)&#123; try &#123; xInt TmpInt = (xInt)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xInt)); if (TmpInt == null) return xState.xError; int Count = Bytes.Length; int NumTmp = 0; if (Count &gt; 0) &#123; NumTmp = Bytes[0]; if (Count &gt; 4) Count = 4; for (int i = 1; i &lt; Count; i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; &#125; TmpInt.iValue = NumTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState CopyFrom(string sPara)&#123; try &#123; xBytes TmpByte = (xBytes)XmlFO.GetCheckSpecTypeObject(sPara, typeof(xBytes)); if (TmpByte == null) return xState.xError; if (TmpByte.cPage != cPage) Bytes = Encoding.Convert(Encoding.GetEncoding(TmpByte.cPage), Encoding.GetEncoding(cPage), TmpByte.Bytes); else Bytes = TmpByte.Bytes.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState SubByteFrom(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 3, out SepPara)) return xState.xError; List&lt;Byte&gt; tmpByte = new List&lt;byte&gt;(); tmpByte.AddRange(StringToBytes(SepPara[0])); if (tmpByte.Count &gt; 0) &#123; int start = Convert.ToInt32(SepPara[1]);//start 0 int leng = Convert.ToInt32(SepPara[2]); if (start &gt;= tmpByte.Count) start = tmpByte.Count - 1; if ((start + leng) &gt; tmpByte.Count) leng = tmpByte.Count - start; Bytes = tmpByte.GetRange(start, leng).ToArray(); &#125; else Bytes = tmpByte.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState IsEqual(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; byte[] tmpByte = StringToBytes(SepPara[0]); int start = Convert.ToInt32(SepPara[1]);//start 0 if ((start + tmpByte.Length) &gt; Bytes.Length) return xState.xFalse; for (int i = 0; i &lt; tmpByte.Length; i++) &#123; if (tmpByte[i] != Bytes[start + i]) return xState.xFalse; &#125; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState CheckBit(string sPara)&#123; try &#123; string[] SepPara; if (!XmlFO.SepParams(sPara, 2, out SepPara)) return xState.xError; int byteNo = Convert.ToInt32(SepPara[0]);//start 0 int bitNo = Convert.ToInt32(SepPara[1]);//start 7---0 if (bitNo &gt; 7) bitNo = 7; if (bitNo &lt; 0) bitNo = 0; int Num = (Bytes[byteNo] &lt;&lt; (7 - bitNo)) &amp; 0xFF; Num = (Num &gt;&gt; 7) &amp; 0xFF; if (Num == 1) return xState.xTrue; else return xState.xFalse; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xError; &#125;&#125;public xState UseDefaultCodePage(string sPara)&#123; cPage = Encoding.Default.CodePage; return xState.xTrue;&#125;public xState UseUTF8CodePage(string sPara)&#123; cPage = Encoding.UTF8.CodePage; return xState.xTrue;&#125;public xState UseUnicodeCodePage(string sPara)&#123; cPage = Encoding.Unicode.CodePage; return xState.xTrue;&#125;//转换public xState Convert_String_ASCII(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, Bytes.Length); XmlFO.ListObject[Sep.sName].xValue = Encoding.ASCII.GetString(Bytes, Sep.iStart, Sep.iCount); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_String_BCD(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, Bytes.Length); string strTmp = string.Empty; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) strTmp += Bytes[i].ToString(&quot;X2&quot;); XmlFO.ListObject[Sep.sName].xValue = strTmp; return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double_Bit(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); double NumTmp = 0; if (Sep.iCount &gt; 4) NumTmp = BitConverter.ToDouble(Bytes, Sep.iStart); else NumTmp = BitConverter.ToSingle(Bytes, Sep.iStart); double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Double_Minus(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = (Bytes[0] &amp; 0x7F); for (int i = (Sep.iStart + 1); (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; if (Bytes[0] &gt; 0x7F) NumTmp = -NumTmp; double DoubTmp = (NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = DoubTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Int(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; for (int i = Sep.iStart; (i &lt; Bytes.Length) &amp;&amp; (i &lt; (Sep.iStart + Sep.iCount)); i++) &#123; NumTmp &lt;&lt;= 8; NumTmp += Bytes[i]; &#125; NumTmp = (int)(NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = NumTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Convert_Int_Bit(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 1); int NumTmp = 0; if (Sep.iCount &gt; 4) NumTmp = (int)BitConverter.ToInt64(Bytes, Sep.iStart); else if (Sep.iCount &gt; 2) NumTmp = (int)BitConverter.ToInt32(Bytes, Sep.iStart); else if (Sep.iCount &gt; 1) NumTmp = (int)BitConverter.ToInt16(Bytes, Sep.iStart); else NumTmp = Bytes[Sep.iStart]; NumTmp = (int)(NumTmp * Sep.dRadio + Sep.dOffset); XmlFO.ListObject[Sep.sName].xValue = NumTmp.ToString(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;public xState Append_Double(string sPara)&#123; try &#123; cSepParams Sep = new cSepParams(sPara, 4); int iTmp = (int)(Convert.ToDouble(XmlFO.ListObject[Sep.sName].xValue) * Sep.dRadio + Sep.dOffset); List&lt;Byte&gt; ListTmp = new List&lt;byte&gt;(); ListTmp.AddRange(Bytes); for (int i = 0; i &lt; Sep.iCount; i++) &#123; ListTmp.Add((byte)((iTmp &gt;&gt; ((Sep.iCount - i - 1) * 8)) &amp; 0xFF)); &#125; Bytes = ListTmp.ToArray(); return xState.xTrue; &#125; catch (Exception e) &#123; xErrorOutException(e); return xState.xFalse; &#125;&#125;","categories":[{"name":"数据转换","slug":"数据转换","permalink":"https://silencejql.github.io/categories/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"IEEE","slug":"IEEE","permalink":"https://silencejql.github.io/tags/IEEE/"}]},{"title":"RGB颜色","slug":"RGB颜色","date":"2019-07-05T06:20:25.000Z","updated":"2023-01-05T05:08:56.674Z","comments":true,"path":"RGB颜色.html","link":"","permalink":"https://silencejql.github.io/RGB%E9%A2%9C%E8%89%B2.html","excerpt":"","text":"","categories":[{"name":"RGB","slug":"RGB","permalink":"https://silencejql.github.io/categories/RGB/"}],"tags":[{"name":"RGB颜色表","slug":"RGB颜色表","permalink":"https://silencejql.github.io/tags/RGB%E9%A2%9C%E8%89%B2%E8%A1%A8/"}]},{"title":"css常用属性","slug":"css常用属性","date":"2019-07-05T05:54:12.000Z","updated":"2025-03-25T03:24:37.163Z","comments":true,"path":"css常用属性.html","link":"","permalink":"https://silencejql.github.io/css%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7.html","excerpt":"","text":"文本设置 123456789101112font: italic bold 36px 宋体; //顺序不可变font-wight: 100-900、bold（加粗）font-size: 10px; // 12px(12像素)、50%、larger、smallfont-style: initial（初始）、italic（斜体字）、normal（默认）、oblique（倾斜）font-family: &quot;微软雅黑&quot; // 宋体text-align: center; //横向排列 left、right 和 centerline-height: 200px; //文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比vertical-align:-4px; //设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效text-indent: 150px; //首行缩进letter-spacing: 10px; //字母间隙word-spacing: 20px; //单词间隙text-transform: capitalize; //单词大写 背景属性 1234567background-color: cornflowerblue; //背景颜色background-image: url(&#x27;1.jpg&#x27;); //背景图片background-repeat: no-repeat/repeat-x/repeat=t; //(默认铺满，不重复，x重复，y重复)background-size:600px 250px //大小background-position: right top（20px 20px）;//(横向：left center right)(纵向：top center bottom) //简写：&lt;body style=&quot;background: 20px 20px no-repeat #ff4 url(&#x27;1.jpg&#x27;)&quot;&gt;&lt;div style=&quot;width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url(&#x27;1.jpg&#x27;)&quot;&gt; 颜色属性 1234&lt;div style=&quot;color:blueviolet&quot;&gt;ppppp&lt;/div&gt; //颜色少&lt;div style=&quot;color:#ffee33&quot;&gt;ppppp&lt;/div&gt; //百度颜色代码可以查询更多&lt;div style=&quot;color:rgb(255,0,0)&quot;&gt;ppppp&lt;/div&gt; //三原色 红绿蓝256级&lt;div style=&quot;color:rgba(255,0,0,0.5)&quot;&gt;ppppp&lt;/div&gt; //比上一个 加了一个透明度","categories":[{"name":"CSS","slug":"CSS","permalink":"https://silencejql.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://silencejql.github.io/tags/CSS/"}]},{"title":"泛型的特点","slug":"泛型的特点","date":"2019-07-05T05:36:31.000Z","updated":"2025-03-24T11:29:57.255Z","comments":true,"path":"泛型的特点.html","link":"","permalink":"https://silencejql.github.io/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9.html","excerpt":"","text":"泛型的主要特性 泛型类型的一些重要特征使它们相比传统的非泛型类型具有如下的显著特征： 类型安全 性能 二进制代码复用 类型安全 泛型最重要的特征之一是类型安全性。对于非泛型ArrayList类，如果使用对象类型，则可以向集合中添加任何类型，这些类型有时会导致严重的问题。下面的示例显示向ArrayList类型的集合添加一个整数、字符串和对象； 1234ArrayList obj = new ArrayList(); obj.Add(50); obj.Add(&quot;Dog&quot;); obj.Add(new TestClass()); 现在，如果使用整数对象来使用foreach语句进行遍历的话，当编译器接受到代码，但是因为集合中的所有元素都不是整数，所以会导致运行时异常； 1234foreach(int i in obj) &#123; Console.WriteLine(i); &#125; 编程的经验法则是应该尽早检测到错误。对于泛型类Test，泛型类型T定义允许哪些类型。通过使用Test的定义，只能向集合添加整型类型的数据。这时候当Add()方法具有以下无效参数的时候编译器将不编译代码； 1234Test&lt;int&gt; obj = new Test&lt;int&gt;(); obj.Add(50); obj.Add(&quot;Dog&quot;); //编译错误obj.Add(new TestClass()); //编译错误 性能 在下面的示例中，ArrayList类存储对象，并且定义了Add()方法来存储一些整型参数。因此，整数类型被装箱。当使用foreach语句读取ArrayList中的值时，将发生拆箱。 1234567ArrayList obj = new ArrayList(); obj.Add(50); //装箱- 值类型转换成引用类型int x= (int)obj[0]; //拆箱foreach(int i in obj) &#123; Console.WriteLine(i); // 拆箱&#125; 注意：泛型比其他集合（如ArrayList）更快。 代替使用对象类型，TestClass类的泛型类型被定义为int，因此在从编译器动态生成的类中将使用int类型。所以将不会发生装箱和拆箱，如下所示； 1234567TestClass&lt;int&gt; obj = new TestClass&lt;int&gt;(); obj.Add(50); //没有装箱int x= obj[0]; // 没有拆箱foreach(int i in obj) &#123; Console.WriteLine(i); //没有拆箱&#125; 二进制代码复用 泛型类型提供了一种源代码保护机制。泛型类可以定义一次，并且可以使用许多不同类型来进行实例化。泛型可以在一种CLR支持的语言中定义，并可以被另一种.NET语言使用。以下TestClass 使用int和string类型进行实例化： 12345TestClass&lt;int&gt; obj = new TestClass&lt;int&gt;(); obj.Add(50); TestClass&lt;string&gt; obj1 = new TestClass&lt;string&gt;(); Obj1.Add(&quot;hello&quot;);","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"泛型","slug":"泛型","permalink":"https://silencejql.github.io/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"CSharp Static","slug":"C-Static","date":"2019-07-05T02:59:00.000Z","updated":"2025-03-25T03:21:21.531Z","comments":true,"path":"C-Static.html","link":"","permalink":"https://silencejql.github.io/C-Static.html","excerpt":"静态方法只能访问类的静态成员，不能访问类的非静态成员； 非静态方法可以访问类的静态成员，也可以访问类的非静态成员； 静态方法不能使用实例来调用，只能使用类名来调用。","text":"静态方法只能访问类的静态成员，不能访问类的非静态成员； 非静态方法可以访问类的静态成员，也可以访问类的非静态成员； 静态方法不能使用实例来调用，只能使用类名来调用。 static 静态全局变量 特点： 1、该变量在全局数据区分配内存。 2、初始化：如果不显式初始化，那么将被隐式初始化为0。 静态局部变量 特点： 1、该变量在全局数据区分配内存。 2、初始化：如果不显式初始化，那么将被隐式初始化为0。 3、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 静态数据成员 内存分配：在程序的全局数据区分配。 初始化和定义： 1、静态数据成员定义时要分配空间，所以不能在类声明中定义。 2、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。 3、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。 特点 对相于 public,protected,private 关键字的影响它和普通数据成员一样，因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。 访问形式 类对象名.静态数据成员名 静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。 静态成员函数 特点： 1、静态成员函数与类相联系，不与类的对象相联系。 2、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。 作用： 主要用于对静态数据成员的操作。 调用形式： 类对象名.静态成员函数名（） 总结 静态方法只能访问类的静态成员，不能访问类的非静态成员； 非静态方法可以访问类的静态成员，也可以访问类的非静态成员； 静态方法不能使用实例来调用，只能使用类名来调用。 12345678910111213static int i = getNum();int j = getNum();static int num = 1;static int getNum()&#123; return num;&#125;static void Main(string[] args)&#123; Console.WriteLine(&quot;i=&#123;0&#125;&quot;,i); Console.WriteLine(&quot;j=&#123;0&#125;&quot;, new class1().j); Console.Read();&#125; 分析：Console.WriteLine(&quot;i=&#123;0&#125;&quot;,i);这里i是static变量，而且类class1是第一次被引用，要先为class1里面所有的static变量分配内存。尽管现在有超线程技术，但是指令在逻辑还是一条一条的按顺序执行的，所以先为static int i分配内存，并且在该内存中保持int的缺省值0，接着再为static int num 变量分配内存，值当然也为0。 然后执行第二步，为变量赋值：先为static int i变量赋值，i＝getNum()，看getNum里面的代码，就是return num，这个时候num的值是0，于是i就为0了。然后对变量num赋值，num＝1；这行代码执行后，num就为1了。 static的优点是什么？为什么要使用static 变量或函数？？ 有一些频繁使用的东西，如果你每次使用都重新new一下，那么这个开销可能会很高，如果使用static，一直放在内存中，那么想用就直接用，而不需要重新new一块空间初始化数据。那么static就是为了实现一个系统的缓存作用的，其生命周期直到应用程序退出结束。 静态成员包括静态字段和静态属性，静态成员和类相关联，不依赖于对象而存在，只能由类访问，而不能由对象访问； 静态成员属于类所有，无论创建多少实例对象，静态成员在内存中只有一份；实例成员属于类的实例所有，每创建一个实例对象，实例成员都会在内存中分配一块内存区域。 所以静态成员一般用于存放共享的数据段，如数据库连接字符串等。 一个类如果只包含静态成员和静态方法，则该类可以定义为静态类，给类加上static修饰符； 静态方法和非静态方法 一、性能上：静态方法和实例方法差别不大。所有方法，不管是静态方法还是实例方法，都是在JIT加载类时分配内存，不同的是静态方法以类名引用，而实例方法对对象实例引用。创建实例时，不会再为类的方法分配内存，所有的实例对象共用一个类的方法代码。因此静态方法和实例方法的调用，在性能上的差别微乎其微。 二、静态方法只能由类访问；实例方法只能由对象访问。 优点： 1、静态变量在类载入时，就装入内存 2、使用时不用 New 就意味的不必创建类中所有对象，就可以调用某个方法 缺点： 垃圾回收机制不能回收静态变量，静态类变量会常驻内存 c#中静态类的优缺点 缺点： 1、整个类型在程序运行期间只加载一次。 这样是对于那些经常使用的类型来说的，那就不用每次使用前都先加载。效率高些。但是对那些不常用的类型来说。 如果是静态类型，那就要一直占用相当的内存；一直到程序停止。或者应用程序域被卸载。所以应该只对那些常用的类型定义成静态类型。 优点： 1、它们仅包含静态成员。 2、它们不能被实例化。 3、它们是密封的。 4、它们不能包含实例构造函数（C# 编程指南）。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"CSharp基础","slug":"C-基础","date":"2019-07-05T02:59:00.000Z","updated":"2025-03-24T11:29:10.472Z","comments":true,"path":"C-基础.html","link":"","permalink":"https://silencejql.github.io/C-%E5%9F%BA%E7%A1%80.html","excerpt":"记录写bug过程中遇到的一些疑问","text":"记录写bug过程中遇到的一些疑问 面向对象 protected:只有同一类或派生类中的代码可以访问该类型或成员 internal:同一程序集中的任何代码都可以访问该类型或成员，但其他程序集中的代码不可以。 protected internal:同一程序集中的任何代码或其他程序集中的任何派生类都可以访问该类型或成员。 private protected:同一类或基类程序集内派生类中的代码可以访问该类型或成 员。 abstract:要求在派生类中重写类成员。 数据类型 值类型存储在堆栈上，引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。 C#类为引用类型，结构为值类型。 从值类型转化为引用类型称为装箱，如果方法需要把一个对象作为参数，而且传送一个值类型，装箱操作会自动进行；装箱的值类型可以使用拆箱操作转换为值类型，在拆箱时，需要使用类型转换运算符。 值类型 结构体 数值类型(整数，浮点数，高精度浮点数) 可空类型 布尔 字符 枚举 引用类型 数组，用户定义的类、接口、委托，object，字符串 装箱和拆箱 装箱是一种通过将变量存储到System.Object中来显式地将值类型转换为引用类型的机制。当您装入值时，CLR会将新对象分配到堆中，并将值类型的值复制到该实例中。例如： 12int a = 20; object b = a; //装箱 相反的操作是拆箱，它是将引用类型转换回值类型的过程。此过程验证接收数据类型是否与装箱类型一致; int c = (int)b; // 拆箱 泛型 特征： 类型安全 性能 二进制代码复用 详见： 泛型的特点 为什么不用object代替泛型 由于Object为所有类型的基类，所以可以处理任何数据类型的数据，但是其中存在这拆箱和装箱，如果数据太多会影响到程序的性能。 在使用泛型的时候程序会在编译阶段根据我们提供的类型生成相应的二进制代码，无须进行装箱和拆箱操作。 接口 为什么要用接口 接口一般由上层人员发起，下层人员实现。 写接口并不是为了扩展，而是为了扩展以后的模块仍然跟项目模块保持高度一致，为了扩展后的规范化。 反射 实例化接口对象 接口回调 接口不仅可以声明对象，而且可以把对象实例化，还可以当做参数被传入。 即继承中的向上转型，父类 FL=new 子类()，只不过这里的父类就是interface接口。 12345678910111213141516171819202122232425interface Itemp&#123; double plus();&#125;public class num : Itemp&#123; double aa, bb; public num(double a, double b) &#123; this.bb = b; this.aa = a; &#125; public double plus() &#123; return (aa + bb); &#125;&#125;static void Main(string[] args)&#123; Itemp tm = null;//声明接口对象引用 tm = new num(1, 2);//接口回调(向上转型) Console.WriteLine(tm.plus());&#125; 类型参数约束 在定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的类型种类施加限制。如果客户端代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译时错误。这些限制称为约束。 类型参数约束.NET支持的类型参数约束有以下五种： 123456where T : struct //类型参数必须是值类型；可以指定除 Nullable 以外的任何值类型where T : class //类型参数必须是引用类型；这一点也适用于任何类、接口、委托或数组类型where T : new() //类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定where T : NameOfBaseClass //类型参数必须是指定的基类或派生自指定的基类where T : NameOfInterface //类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的where T : U //为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数 当前程序运行路径 Directory.GetCurrentDirectory() + &quot;\\\\Config 数据类型补充 @&quot;&quot;&quot;Ahoy!&quot;&quot; cried the captain.&quot; // &quot;Ahoy!&quot; cried the captain. 12345678910111213141516171819202122double d = 3D;d = 4d;d = 3.934_001;float f = 3_000.5F;f = 5.4f;decimal myMoney = 3_000.5m;myMoney = 400.75M;[Flags]public enum Days&#123; None = 0b_0000_0000, // 0 Monday = 0b_0000_0001, // 1 Tuesday = 0b_0000_0010, // 2 Wednesday = 0b_0000_0100, // 4 Thursday = 0b_0000_1000, // 8 Friday = 0b_0001_0000, // 16 Saturday = 0b_0010_0000, // 32 Sunday = 0b_0100_0000, // 64 Weekend = Saturday | Sunday&#125;Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday; checked 关键字用于对整型类型算术运算和转换显式启用溢出检查 12345678int i = 2147483647;checked&#123; i += 10; Console.WriteLine(i);&#125;//i=0;不会抛异常 lock lock 语句获取给定对象的互斥 lock，执行语句块，然后释放 lock。 持有 lock 时，持有 lock 的线程可以再次获取并释放 lock。 阻止任何其他线程获取 lock 并等待释放 lock。 lock(引用类型) 当同步对共享资源的线程访问时，请锁定专用对象实例（例如,private readonly object balanceLock = new object(); ）或另一个不太可能被代码无关部分用作 lock 对象的实例。避免对不同的共享资源使用相同的 lock 对象实例，因为这可能导致死锁或锁争用 when 12345678910111213141516171819var client = new HttpClient();var streamTask = client.GetStringAsync(&quot;https://localHost:10000&quot;);try&#123; var responseText = await streamTask; return responseText;&#125;catch (HttpRequestException e) when (e.Message.Contains(&quot;301&quot;))&#123; return &quot;Site Moved&quot;;&#125; catch (HttpRequestException e) when (e.Message.Contains(&quot;404&quot;))&#123; return &quot;Page Not Found&quot;;&#125; catch (HttpRequestException e)&#123; return e.Message;&#125; case 标签无需是互斥的，且 case 标签在 switch 语句中的显示顺序可以决定要执行的 switch块。 when 关键字可指定一个筛选条件，该条件使得仅当筛选条件也为 true 时，与其相关联的 case 标签才为 true。 123456case (expr) when (when-condition):case Shape shape when shape.Area == 0:Console.WriteLine($&quot;The shape: &#123;shape.GetType().Name&#125; with no dimensions&quot;);break; 运算符 C#8.0 从末尾运算符 ^ 开始索引 123int[] xs = new[] &#123; 0, 10, 20, 30, 40 &#125;;int last = xs[^1];// last = 40 12345678910int[] numbers = new[] &#123; 0, 10, 20, 30, 40, 50 &#125;;int start = 1;int amountToTake = 3;int[] subset = numbers[start..(start + amountToTake)];Display(subset); // output: 10 20 30//a.. 等效于 a..^0//..b 等效于 0..b//.. 等效于 0..^0 命名空间别名限定符 :: 访问已设置别名的命名空间的成员 123456using forwinforms = System.Drawing;using forwpf = System.Windows;public class Converters&#123; public static forwpf::Point Convert(forwinforms::Point point) =&gt; new forwpf::Point(point.X, point.Y);&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"Hexo博客部署到Coding和github","slug":"Hexo博客部署到Coding和github","date":"2019-07-04T06:48:17.000Z","updated":"2025-03-25T03:23:26.585Z","comments":true,"path":"Hexo博客部署到Coding和github.html","link":"","permalink":"https://silencejql.github.io/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0Coding%E5%92%8Cgithub.html","excerpt":"","text":"部署到Github和Coding 新建仓库 Github： 新建Repository：name.github.io Coding： 新建Repository：name.coding.me 添加SSH key 若无SSHkey ssh-keygen -t rsa -C “your e-mail” Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt; 打开生成的id_rsa.pub文件并复制其中的内容添加到Github或Coding项目中然后在git中执行 Github： ssh -T git@github.com Coding： ssh -T git@git.coding.net //coding ssh -T git@git.dev.tencent.com //腾讯云 添加到腾讯云后需要开启Pages服务才可通过name.coding.me登录 更改博客配置文件 123456deploy: type: git repository: github: git@github.com:silencejql/silencejql.github.io.git coding: git@git.dev.tencent.com:silencejql/silencejql.coding.me.git branch: master 不同格式相应作出调整即可 可能出现的问题 http://name.coding.me 在google chrome中打开可能会默认https，修复方式为: 地址栏中输入 chrome://net-internals/#hsts 在 Delete domain security policies 中输入项目的域名，并 Delete 删除 可以在 Query domain 测试是否删除成功 这里如果还是不行， 请清除浏览器缓存！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"}]},{"title":"托管DLL与非托管DLL","slug":"托管DLL与非托管DLL","date":"2019-07-03T01:03:34.000Z","updated":"2025-03-25T03:25:26.492Z","comments":true,"path":"托管DLL与非托管DLL.html","link":"","permalink":"https://silencejql.github.io/%E6%89%98%E7%AE%A1DLL%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1DLL.html","excerpt":"托管DLL和非托管DLL的区别：狭义解释讲，托管DLL就在Dotnet环境生成的DLL文件；非托管DLL不是在Dotnet环境生成的DLL文件。 托管DLL文件，可以在Dotnet环境通过 “添加引用” 的方式，直接把托管DLL文件添加到项目中，然后通过 Using DLL命名空间，来调用相应的DLL对象；非托管DLL文件，在Dotnet环境应用时，通过DllImport 调用。","text":"托管DLL和非托管DLL的区别：狭义解释讲，托管DLL就在Dotnet环境生成的DLL文件；非托管DLL不是在Dotnet环境生成的DLL文件。 托管DLL文件，可以在Dotnet环境通过 “添加引用” 的方式，直接把托管DLL文件添加到项目中，然后通过 Using DLL命名空间，来调用相应的DLL对象；非托管DLL文件，在Dotnet环境应用时，通过DllImport 调用。 概述 托管dll虽然符合windows的PE格式规范，但是代码是以IL的形式保存在.Text 区的，而不是机器码，CLR会在运行时JIT编译成机器码再交给操作系统执行，这也就为什么托管代码称之为”托管”的意义。 所以，要想注入托管dll，首先需要在目标进程中启动CLR，然后让CLR来加载managed dll。 托管DLL，指完全由.NET托管代码实现的DLL，完全依赖于 .NET 平台的 CLR 运行。托管DLL，受.NET CLR管控，支持内存自动回收等的，对于.NET平台是安全DLL 非托管DLL，是指完全或者部分 不是用.NET代码实现，不依赖于.NET平台即可运行，例如 COM方式 的DLL，不支持自动回收内存，对于.NET平台而言，也是非安全可控的。 正常编程所用的高级语言，是无法被计算机识别的。需要先将高级语言翻译为机器语言，才能被机器理解和运行。 在标准C/C++中，编译过程是这样的： 源代码首先经过预处理器，对头文件以及宏进行解析，然后经过编译器，生成汇编代码，接着，经过汇编，生成机器指令，最后将所有文件连接起来。这种编译方式的优点在于，最终直接生成了机器码，可以直接被计算机识别和运行，无需任何中间运行环境，但缺点也在于，由于不同平台能够识别的机器码不同，因此程序的跨平台能力较差。 而在Java语言中，源代码并没有被直接翻译成机器码，而是编译成了一种中间代码（字节码Bytecode）。因此，运行Java程序需要一个额外的JRE（Java Runtime Enviromental）运行环境，在JRE中存在着JVM（Java Virtual Mechinal，Java虚拟机），在程序运行的时候，会将中间代码进一步解释为机器码，并在机器上运行。 使用中间代码的好处在于，程序的跨平台性比较好，一次编译，可以在不同的设备上运行。 托管/非托管是微软的.net framework中特有的概念，其中，非托管代码也叫本地（native）代码。与Java中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由.net中的CLR将中间代码编译成机器代码。 而C#与Java的区别在于，Java是先编译后解释，C#是两次编译。 调用DLL中的非托管函数一般方法 首先，应该在C#语言源程序中声明外部方法，其基本形式是： [DLLImport(“DLL文件”)] 修饰符 extern 返回变量类型 方法名称 （参数列表） 其中： DLL文件：包含定义外部方法的库文件。 修饰符： 访问修饰符，除了abstract以外在声明方法时可以使用的修饰符。 返回变量类型：在DLL文件中你需调用方法的返回变量类型。 方法名称：在DLL文件中你需调用方法的名称。 参数列表：在DLL文件中你需调用方法的列表。 注意：需要在程序声明中使用System.Runtime.InteropServices命名空间。 DllImport只能放置在方法声明上。 DLL文件必须位于程序当前目录或系统定义的查询路径中（即：系统环境变量中Path所设置的路径）。 返回变量类型、方法名称、参数列表一定要与DLL文件中的定义相一致。 若要使用其它函数名，可以使用EntryPoint属性设置，如： 12345[DllImport(&quot;user32.dll&quot;, EntryPoint=&quot;MessageBoxA&quot;)]static extern int MsgBox(int hWnd, string msg, string caption, int type);[DllImportAttribute(&quot;CN210S_CSM_LV1.dll&quot;, EntryPoint = &quot;uds_calc_key&quot;, CharSet = CharSet.Ansi)]private static extern void uds_calc_key_ldw(string seed, StringBuilder key); 其它可选的 DllImportAttribute 属性： CharSet： 指示用在入口点中的字符集，如：CharSet=CharSet.Ansi； SetLastError： 指示方法是否保留 Win32&quot;上一错误&quot;，如：SetLastError=true； ExactSpelling： 指示 EntryPoint 是否必须与指示的入口点的拼写完全匹配，如：ExactSpelling=false； PreserveSig： 指示方法的签名应当被保留还是被转换， 如：PreserveSig=true； CallingConvention： 指示入口点的调用约定， 如：CallingConvention=CallingConvention.Winapi；","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"委托-匿名-Lambda表达式","slug":"委托-匿名-Lambda表达式","date":"2019-06-26T07:05:21.000Z","updated":"2025-03-24T11:28:53.736Z","comments":true,"path":"委托-匿名-Lambda表达式.html","link":"","permalink":"https://silencejql.github.io/%E5%A7%94%E6%89%98-%E5%8C%BF%E5%90%8D-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.html","excerpt":"","text":"概括 数值可以赋值的类型是变量 方法可以赋值的类型是委托 C#中委托通过返回类型，参数类型进行分类，微软提供Action和Func两个泛型委托免去声明委托的步骤 提供lambda表达式免去声明函数体的步骤 12345void Do(Action doSth)&#123; doSth();&#125;Do(()=&gt;Console.Write(AddResult)); 委托 123456789101112131415161718192021222324252627282930313233delegate int calculator(int x, int y); //委托类型static void Main()&#123; calculator add = new calculator(Addition); int AddResult = add(1, 1); Console.Write(AddResult); calculator dec = new calculator(Subtraction); int SubResult = dec(2,1); Console.write(SubResult);&#125;/// &lt;summary&gt;/// 加法/// &lt;/summary&gt;/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;x+y&lt;/returns&gt;public static int Addition(int x, int y)&#123; return x + y;&#125;/// &lt;summary&gt;/// 减法/// &lt;/summary&gt;/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;x-y&lt;/returns&gt;public static int Subtraction(int x, int y)&#123; return x - y;&#125; 匿名方法 12345678910111213141516delegate int calculator(int x, int y); //委托static void Main()&#123; calculator add = delegate(int num1,int num2) &#123; return num1 + num2; &#125;; calculator dec = delegate(int num1,int num2) &#123; return num1 - num2; &#125;; int AddResult = dec(1, 1); int SubResult = dec(2, 1); Console.Write(AddResult); Console.Write(SubResult);&#125; Lambda表达式 1234567891011121314151617181920212223242526272829303132333435363738delegate bool MyBol(int x, int y);delegate bool MyBol_2(int x, string y);delegate int calculator(int x, int y); //委托类型delegate void VS();static void Main()&#123; MyBol Bol = (x, y) =&gt; x == y; MyBol_2 Bol_2 = (x, s) =&gt; s.Length &gt; x; calculator C = (X, Y) =&gt; X * Y; VS S = () =&gt; Console.Write(&quot;我是无参数Labada表达式&quot;); int[] numbers = &#123; 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 &#125;; int oddNumbers = numbers.Count(n =&gt; n % 2 == 1); List&lt;People&gt; people = LoadData();//初始化 IEnumerable&lt;People&gt; results = people.Where(delegate(People p) &#123; return p.age &gt; 20; &#125;);&#125;private static List&lt;People&gt; LoadData()&#123; List&lt;People&gt; people = new List&lt;People&gt;(); //创建泛型对象 People p1 = new People(21, &quot;guojing&quot;); //创建一个对象 People p2 = new People(21, &quot;wujunmin&quot;); //创建一个对象 People p3 = new People(20, &quot;muqing&quot;); //创建一个对象 People p4 = new People(23, &quot;lupan&quot;); //创建一个对象 people.Add(p1); //添加一个对象 people.Add(p2); //添加一个对象 people.Add(p3); //添加一个对象 people.Add(p4); return people;&#125;public class People&#123; public int age &#123; get; set; &#125; //设置属性 public string name &#123; get; set; &#125; //设置属性 public People(int age, string name) //设置属性(构造函数构造) &#123; this.age = age; //初始化属性值age this.name = name; //初始化属性值name &#125;&#125; Func委托 1234567891011121314//最后一个参数为返回值类型static void Main(string[] args)&#123; Func&lt;int, int, bool&gt; gwl = (p, j) =&gt; &#123; if (p + j == 10) &#123; return true; &#125; return false; &#125;; Console.WriteLine(gwl(5,5) + &quot;&quot;); //打印‘True’ Console.ReadKey();&#125; Predicate 一个特殊的Func, 其中入参只能有一个, 返回值只能是bool","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"}],"tags":[{"name":"委托","slug":"委托","permalink":"https://silencejql.github.io/tags/%E5%A7%94%E6%89%98/"},{"name":"匿名方法","slug":"匿名方法","permalink":"https://silencejql.github.io/tags/%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95/"},{"name":"Lambda","slug":"Lambda","permalink":"https://silencejql.github.io/tags/Lambda/"},{"name":"Func<T>委托","slug":"Func-T-委托","permalink":"https://silencejql.github.io/tags/Func-T-%E5%A7%94%E6%89%98/"},{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"}]},{"title":"Hexo Markdown","slug":"Hexo-Markdown","date":"2019-06-15T12:15:05.000Z","updated":"2025-03-25T03:20:38.163Z","comments":true,"path":"Hexo-Markdown.html","link":"","permalink":"https://silencejql.github.io/Hexo-Markdown.html","excerpt":"","text":"Hexo指令 新建文章 12345678$ hexo new 布局 &quot;文章名&quot;$ hexo clean //清除静态页面缓存（清除 public 文件夹) $ hexo g //在本地生成静态页面（生成 public 文件夹） $ hexo s //启动本地服务 http://localhost:4000，进行预览调试 $ hexo d //远程部署，同步到 GitHub $ npm install hexo-deployer-git --save //自动部署$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布 Markdown格式 首行缩进 &amp;ensp; //相当于1个空格 &amp;emsp; //相当于2个空格，1个汉字 分段: 两个回车 换行: 两个空格 + 回车 标题: # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 123*斜体* | **加粗** | ***斜体加粗*** _斜体_ | __加粗__ | ___斜体加粗___ ~~删除线~~ 引用: &gt; 注意后面紧跟个空格 123&gt; 以下为引用效果继续引用&gt; &gt;二级引用 以下为引用效果 继续引用 二级引用 表格: - 和 | 分割行和列 ， : 控制对齐方式 12345| 0 | 1 | 2|| :- | -: | :-: || 0 | 1 | 2 || 0 | 1 | 2 || 0 | 1 | 2 | 0 1 2 0 1 2 0 1 2 0 1 2 代码块: 四个空格开头或三个链接:文字 邮件链接：xxx` 图片: ![图片说明](图片地址)，地址可以是本地路径，也可以是网络地址 列表: * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 设置字体段落格式 1234&lt;center&gt;居中&lt;/center&gt;&lt;font color=&quot;#FF0000&quot;&gt; 设置颜色 &lt;/font&gt; &lt;font size=6&gt; 设置大小 &lt;/font&gt;&lt;font size=5 color=&quot;#FF0000&quot;&gt; 设置颜色和大小&lt;/font&gt; 居中 设置颜色 设置大小 设置颜色和大小 引用站内文章 在写文章的过程中，有时候需要引用站内的其他文章。可以通过内置的标签插件的语法post_link来实现引用。 &#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; Hexo主题设计 头像 头像配置文件位于：主题配置文件中的 avatar下 版权信息 版权信息的配置文件位于：next\\layout\\_macro\\my-copyright中 添加文章密码 方法一(测试可用) 安装hexo-blog-encrypt 根目录的package.json文件夹中添加： 1&quot;hexo-blog-encrypt&quot;: &quot;2.0.*&quot; 然后在命令行输入： 1npm install 根目录下的_config.yml文件中添加： 123# Securityencrypt: enable: true 使用 在需要加密的文章头部写入password： 123password: abc123abstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read. 方法二 在 themes-&gt;next-&gt;layout-&gt;\\_partials-&gt;head.swig 中添加下面内容 12345678910&lt;script&gt; (function()&#123; if(&#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123; if (prompt(&#x27;请输入文章密码&#x27;) !== &#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123; alert(&#x27;密码错误,交钱还是跑路？&#x27;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章头部加入password。 添加边栏背景图 在 themes\\next\\source\\css\\_custom\\custom.styl文件中 添加 123456789.sidebar &#123; background: url([https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg](https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg &quot;https://ws2.sinaimg.cn/large/006tKfTcly1fq2wrm6g3cj309i0hq749.jpg&quot;)) no-repeat !important; background-size: cover !important; position: fixed !important; right: 0 !important; top: 0 !important; bottom: 0 !important;&#125; 网易云音乐插件 主题文件夹 layout\\\\\\_custom\\\\sidebar.swig Warning: LF will be replaced by CRLF git config --global core.autocrlf false //禁用自动转换 更改文章全局属性(标题) D:\\GitProject\\FirstHexo\\themes\\next\\source\\css\\_common\\components\\post\\post.styl 文章模板 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：hexo new photo “My Gallery”，在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md模板，并根据其内容建立文章，默认使用_config.yml 中的 default_layout 参数post代替 网页折叠 更改post-details.js 文件目录：themes/next/source/js/src/post-details.js 12345678$(document).ready(function()&#123; $(document).on(&#x27;click&#x27;, &#x27;.fold_hider&#x27;, function()&#123; $(&#x27;&gt;.fold&#x27;, this.parentNode).slideToggle(); $(&#x27;&gt;:first&#x27;, this).toggleClass(&#x27;open&#x27;); &#125;); //默认情况下折叠 $(&quot;div.fold&quot;).css(&quot;display&quot;,&quot;none&quot;);&#125;); 更改tags.js 文件目录：themes/next/scripts/tags.js 123456789101112131415161718192021222324/* @haohuawu 修复 Nunjucks 的 tag 里写 ```代码块```，最终都会渲染成 undefined 的问题 https://github.com/hexojs/hexo/issues/2400*/const rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;\\/escape&gt;/g;const placeholder = &#x27;\\uFFFD&#x27;;const rPlaceholder = /(?:&lt;|&amp;lt;)\\!--\\uFFFD(\\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return &#x27;&lt;!--&#x27; + placeholder + (cache.push(str) - 1) + &#x27;--&gt;&#x27;;&#125;hexo.extend.filter.register(&#x27;before_post_render&#x27;, function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;); scripts中增加fold.js 12345678/* global hexo */// Usage: &#123;% fold ???? %&#125; Something function fold (args, content) &#123; var text = args[0]; if(!text) text = &quot;点击显/隐&quot;; return &#x27;&lt;div&gt;&lt;div class=&quot;fold_hider&quot;&gt;&lt;div class=&quot;close hider_title&quot;&gt;&#x27; + text + &#x27;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;fold&quot;&gt;\\n&#x27; + hexo.render.renderSync(&#123;text: content, engine: &#x27;markdown&#x27;&#125;) + &#x27;\\n&lt;/div&gt;&lt;/div&gt;&#x27;;&#125;hexo.extend.tag.register(&#x27;fold&#x27;, fold, &#123;ends: true&#125;); 添加样式custom.styl 12345678910.hider_title&#123; font-family: &quot;Microsoft Yahei&quot;; cursor: pointer;&#125;.close:after&#123; content: &quot;▼&quot;;&#125;.open:after&#123; content: &quot;▲&quot;;&#125; 测试 123something you want to fold, include code block. 添加Git公钥SSH 123456cd ~/.sshssh-keygen -t rsa -C &quot;XXX@XXX.com&quot; #没公钥生成公钥#一直回车后公钥生成在id_rsa.pub中#Git中进入个人设置中添加即可ssh -T git@github.com #验证是否成功","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://silencejql.github.io/tags/Markdown/"}]},{"title":"Test Project","slug":"Test-Project","date":"2019-06-11T02:51:25.000Z","updated":"2025-03-25T03:21:03.267Z","comments":true,"path":"Test-Project.html","link":"","permalink":"https://silencejql.github.io/Test-Project.html","excerpt":"","text":"Test File this is my first Hexo text file","categories":[{"name":"Test","slug":"Test","permalink":"https://silencejql.github.io/categories/Test/"}],"tags":[]}],"categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/categories/CSharp/"},{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/categories/BBK/"},{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/categories/KaTeX/"},{"name":"WindowsTerminal","slug":"WindowsTerminal","permalink":"https://silencejql.github.io/categories/WindowsTerminal/"},{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/categories/Git/"},{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"CSharp","slug":"算法/CSharp","permalink":"https://silencejql.github.io/categories/%E7%AE%97%E6%B3%95/CSharp/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://silencejql.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"CSharp","slug":"设计模式/CSharp","permalink":"https://silencejql.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/CSharp/"},{"name":"C++","slug":"C","permalink":"https://silencejql.github.io/categories/C/"},{"name":"工作","slug":"工作","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"手册","slug":"手册","permalink":"https://silencejql.github.io/categories/%E6%89%8B%E5%86%8C/"},{"name":"SQLServer","slug":"SQLServer","permalink":"https://silencejql.github.io/categories/SQLServer/"},{"name":"Postgre","slug":"Postgre","permalink":"https://silencejql.github.io/categories/Postgre/"},{"name":"Python3","slug":"Python3","permalink":"https://silencejql.github.io/categories/Python3/"},{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/categories/Python/"},{"name":"MQ","slug":"MQ","permalink":"https://silencejql.github.io/categories/MQ/"},{"name":"数据库","slug":"工作/数据库","permalink":"https://silencejql.github.io/categories/%E5%B7%A5%E4%BD%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"HTML","slug":"HTML","permalink":"https://silencejql.github.io/categories/HTML/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://silencejql.github.io/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"数据库","slug":"数据库","permalink":"https://silencejql.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据转换","slug":"数据转换","permalink":"https://silencejql.github.io/categories/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"},{"name":"RGB","slug":"RGB","permalink":"https://silencejql.github.io/categories/RGB/"},{"name":"CSS","slug":"CSS","permalink":"https://silencejql.github.io/categories/CSS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/categories/Hexo/"},{"name":"Test","slug":"Test","permalink":"https://silencejql.github.io/categories/Test/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://silencejql.github.io/tags/CSharp/"},{"name":"CSharp 补课笔记","slug":"CSharp-补课笔记","permalink":"https://silencejql.github.io/tags/CSharp-%E8%A1%A5%E8%AF%BE%E7%AC%94%E8%AE%B0/"},{"name":"BBK","slug":"BBK","permalink":"https://silencejql.github.io/tags/BBK/"},{"name":"Docker","slug":"Docker","permalink":"https://silencejql.github.io/tags/Docker/"},{"name":"Hexo","slug":"Hexo","permalink":"https://silencejql.github.io/tags/Hexo/"},{"name":"KaTeX","slug":"KaTeX","permalink":"https://silencejql.github.io/tags/KaTeX/"},{"name":"特性","slug":"特性","permalink":"https://silencejql.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"反射","slug":"反射","permalink":"https://silencejql.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"Ini","slug":"Ini","permalink":"https://silencejql.github.io/tags/Ini/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://silencejql.github.io/tags/OpenCV/"},{"name":"Git","slug":"Git","permalink":"https://silencejql.github.io/tags/Git/"},{"name":"算法","slug":"算法","permalink":"https://silencejql.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Web","slug":"Web","permalink":"https://silencejql.github.io/tags/Web/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://silencejql.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://silencejql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"DoIP","slug":"DoIP","permalink":"https://silencejql.github.io/tags/DoIP/"},{"name":"GitLab","slug":"GitLab","permalink":"https://silencejql.github.io/tags/GitLab/"},{"name":"MiniIO","slug":"MiniIO","permalink":"https://silencejql.github.io/tags/MiniIO/"},{"name":"Markdown","slug":"Markdown","permalink":"https://silencejql.github.io/tags/Markdown/"},{"name":"Http","slug":"Http","permalink":"https://silencejql.github.io/tags/Http/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://silencejql.github.io/tags/PostgreSQL/"},{"name":"Hex","slug":"Hex","permalink":"https://silencejql.github.io/tags/Hex/"},{"name":"轮眉","slug":"轮眉","permalink":"https://silencejql.github.io/tags/%E8%BD%AE%E7%9C%89/"},{"name":"SQLServer","slug":"SQLServer","permalink":"https://silencejql.github.io/tags/SQLServer/"},{"name":"J1939","slug":"J1939","permalink":"https://silencejql.github.io/tags/J1939/"},{"name":"AES","slug":"AES","permalink":"https://silencejql.github.io/tags/AES/"},{"name":"C","slug":"C","permalink":"https://silencejql.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://silencejql.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://silencejql.github.io/tags/Linux/"},{"name":"WebService","slug":"WebService","permalink":"https://silencejql.github.io/tags/WebService/"},{"name":"构造函数","slug":"构造函数","permalink":"https://silencejql.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"UDP","slug":"UDP","permalink":"https://silencejql.github.io/tags/UDP/"},{"name":"委托","slug":"委托","permalink":"https://silencejql.github.io/tags/%E5%A7%94%E6%89%98/"},{"name":"事件","slug":"事件","permalink":"https://silencejql.github.io/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"Flask","slug":"Flask","permalink":"https://silencejql.github.io/tags/Flask/"},{"name":"Modbus","slug":"Modbus","permalink":"https://silencejql.github.io/tags/Modbus/"},{"name":"Python","slug":"Python","permalink":"https://silencejql.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://silencejql.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Script","slug":"Script","permalink":"https://silencejql.github.io/tags/Script/"},{"name":"存储过程","slug":"存储过程","permalink":"https://silencejql.github.io/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"IBMMQ","slug":"IBMMQ","permalink":"https://silencejql.github.io/tags/IBMMQ/"},{"name":"Rabbit MQ","slug":"Rabbit-MQ","permalink":"https://silencejql.github.io/tags/Rabbit-MQ/"},{"name":"链接字符串","slug":"链接字符串","permalink":"https://silencejql.github.io/tags/%E9%93%BE%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"诊断指令","slug":"诊断指令","permalink":"https://silencejql.github.io/tags/%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4/"},{"name":"CAN","slug":"CAN","permalink":"https://silencejql.github.io/tags/CAN/"},{"name":"HTML","slug":"HTML","permalink":"https://silencejql.github.io/tags/HTML/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://silencejql.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"现场问题","slug":"现场问题","permalink":"https://silencejql.github.io/tags/%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98/"},{"name":"现场软件备份","slug":"现场软件备份","permalink":"https://silencejql.github.io/tags/%E7%8E%B0%E5%9C%BA%E8%BD%AF%E4%BB%B6%E5%A4%87%E4%BB%BD/"},{"name":"Postgresql","slug":"Postgresql","permalink":"https://silencejql.github.io/tags/Postgresql/"},{"name":"XML","slug":"XML","permalink":"https://silencejql.github.io/tags/XML/"},{"name":"IEEE","slug":"IEEE","permalink":"https://silencejql.github.io/tags/IEEE/"},{"name":"RGB颜色表","slug":"RGB颜色表","permalink":"https://silencejql.github.io/tags/RGB%E9%A2%9C%E8%89%B2%E8%A1%A8/"},{"name":"CSS","slug":"CSS","permalink":"https://silencejql.github.io/tags/CSS/"},{"name":"泛型","slug":"泛型","permalink":"https://silencejql.github.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"匿名方法","slug":"匿名方法","permalink":"https://silencejql.github.io/tags/%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95/"},{"name":"Lambda","slug":"Lambda","permalink":"https://silencejql.github.io/tags/Lambda/"},{"name":"Func<T>委托","slug":"Func-T-委托","permalink":"https://silencejql.github.io/tags/Func-T-%E5%A7%94%E6%89%98/"}]}